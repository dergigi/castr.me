"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@nostr-dev-kit";
exports.ids = ["vendor-chunks/@nostr-dev-kit"];
exports.modules = {

/***/ "(rsc)/./node_modules/@nostr-dev-kit/ndk/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BECH32_REGEX: () => (/* binding */ BECH32_REGEX),\n/* harmony export */   NDKAppHandlerEvent: () => (/* binding */ NDKAppHandlerEvent),\n/* harmony export */   NDKAppSettings: () => (/* binding */ NDKAppSettings),\n/* harmony export */   NDKArticle: () => (/* binding */ NDKArticle),\n/* harmony export */   NDKCashuMintList: () => (/* binding */ NDKCashuMintList),\n/* harmony export */   NDKCashuToken: () => (/* binding */ NDKCashuToken),\n/* harmony export */   NDKCashuWalletTx: () => (/* binding */ NDKCashuWalletTx),\n/* harmony export */   NDKClassified: () => (/* binding */ NDKClassified),\n/* harmony export */   NDKDVMJobFeedback: () => (/* binding */ NDKDVMJobFeedback),\n/* harmony export */   NDKDVMJobResult: () => (/* binding */ NDKDVMJobResult),\n/* harmony export */   NDKDVMRequest: () => (/* binding */ NDKDVMRequest),\n/* harmony export */   NDKDraft: () => (/* binding */ NDKDraft),\n/* harmony export */   NDKDvmJobFeedbackStatus: () => (/* binding */ NDKDvmJobFeedbackStatus),\n/* harmony export */   NDKEvent: () => (/* binding */ NDKEvent),\n/* harmony export */   NDKHighlight: () => (/* binding */ NDKHighlight),\n/* harmony export */   NDKImage: () => (/* binding */ NDKImage),\n/* harmony export */   NDKKind: () => (/* binding */ NDKKind),\n/* harmony export */   NDKList: () => (/* binding */ NDKList),\n/* harmony export */   NDKListKinds: () => (/* binding */ NDKListKinds),\n/* harmony export */   NDKNip07Signer: () => (/* binding */ NDKNip07Signer),\n/* harmony export */   NDKNip46Backend: () => (/* binding */ NDKNip46Backend),\n/* harmony export */   NDKNip46Signer: () => (/* binding */ NDKNip46Signer),\n/* harmony export */   NDKNostrRpc: () => (/* binding */ NDKNostrRpc),\n/* harmony export */   NDKNutzap: () => (/* binding */ NDKNutzap),\n/* harmony export */   NDKPool: () => (/* binding */ NDKPool),\n/* harmony export */   NDKPrivateKeySigner: () => (/* binding */ NDKPrivateKeySigner),\n/* harmony export */   NDKPublishError: () => (/* binding */ NDKPublishError),\n/* harmony export */   NDKRelay: () => (/* binding */ NDKRelay),\n/* harmony export */   NDKRelayAuthPolicies: () => (/* binding */ NDKRelayAuthPolicies),\n/* harmony export */   NDKRelayList: () => (/* binding */ NDKRelayList),\n/* harmony export */   NDKRelaySet: () => (/* binding */ NDKRelaySet),\n/* harmony export */   NDKRelayStatus: () => (/* binding */ NDKRelayStatus),\n/* harmony export */   NDKRepost: () => (/* binding */ NDKRepost),\n/* harmony export */   NDKSimpleGroup: () => (/* binding */ NDKSimpleGroup),\n/* harmony export */   NDKSimpleGroupMemberList: () => (/* binding */ NDKSimpleGroupMemberList),\n/* harmony export */   NDKSimpleGroupMetadata: () => (/* binding */ NDKSimpleGroupMetadata),\n/* harmony export */   NDKStory: () => (/* binding */ NDKStory),\n/* harmony export */   NDKStorySticker: () => (/* binding */ NDKStorySticker),\n/* harmony export */   NDKStoryStickerType: () => (/* binding */ NDKStoryStickerType),\n/* harmony export */   NDKSubscription: () => (/* binding */ NDKSubscription),\n/* harmony export */   NDKSubscriptionCacheUsage: () => (/* binding */ NDKSubscriptionCacheUsage),\n/* harmony export */   NDKSubscriptionReceipt: () => (/* binding */ NDKSubscriptionReceipt),\n/* harmony export */   NDKSubscriptionStart: () => (/* binding */ NDKSubscriptionStart),\n/* harmony export */   NDKSubscriptionTier: () => (/* binding */ NDKSubscriptionTier),\n/* harmony export */   NDKTranscriptionDVM: () => (/* binding */ NDKTranscriptionDVM),\n/* harmony export */   NDKUser: () => (/* binding */ NDKUser),\n/* harmony export */   NDKVideo: () => (/* binding */ NDKVideo),\n/* harmony export */   NDKWiki: () => (/* binding */ NDKWiki),\n/* harmony export */   NDKZapper: () => (/* binding */ NDKZapper),\n/* harmony export */   NIP33_A_REGEX: () => (/* binding */ NIP33_A_REGEX),\n/* harmony export */   NdkNutzapStatus: () => (/* binding */ NdkNutzapStatus),\n/* harmony export */   calculateRelaySetFromEvent: () => (/* binding */ calculateRelaySetFromEvent),\n/* harmony export */   calculateTermDurationInSeconds: () => (/* binding */ calculateTermDurationInSeconds),\n/* harmony export */   cashuPubkeyToNostrPubkey: () => (/* binding */ cashuPubkeyToNostrPubkey),\n/* harmony export */   compareFilter: () => (/* binding */ compareFilter),\n/* harmony export */   \"default\": () => (/* binding */ NDK),\n/* harmony export */   defaultOpts: () => (/* binding */ defaultOpts),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   dvmSchedule: () => (/* binding */ dvmSchedule),\n/* harmony export */   eventHasETagMarkers: () => (/* binding */ eventHasETagMarkers),\n/* harmony export */   eventIsPartOfThread: () => (/* binding */ eventIsPartOfThread),\n/* harmony export */   eventIsReply: () => (/* binding */ eventIsReply),\n/* harmony export */   eventReplies: () => (/* binding */ eventReplies),\n/* harmony export */   eventThreadIds: () => (/* binding */ eventThreadIds),\n/* harmony export */   eventThreads: () => (/* binding */ eventThreads),\n/* harmony export */   eventsBySameAuthor: () => (/* binding */ eventsBySameAuthor),\n/* harmony export */   filterAndRelaySetFromBech32: () => (/* binding */ filterAndRelaySetFromBech32),\n/* harmony export */   filterFingerprint: () => (/* binding */ filterFingerprint),\n/* harmony export */   filterForEventsTaggingId: () => (/* binding */ filterForEventsTaggingId),\n/* harmony export */   filterFromId: () => (/* binding */ filterFromId),\n/* harmony export */   generateContentTags: () => (/* binding */ generateContentTags),\n/* harmony export */   generateHashtags: () => (/* binding */ generateHashtags),\n/* harmony export */   generateSubId: () => (/* binding */ generateSubId),\n/* harmony export */   generateZapRequest: () => (/* binding */ generateZapRequest),\n/* harmony export */   getEventReplyId: () => (/* binding */ getEventReplyId),\n/* harmony export */   getNip57ZapSpecFromLud: () => (/* binding */ getNip57ZapSpecFromLud),\n/* harmony export */   getRelayListForUser: () => (/* binding */ getRelayListForUser),\n/* harmony export */   getRelayListForUsers: () => (/* binding */ getRelayListForUsers),\n/* harmony export */   getReplyTag: () => (/* binding */ getReplyTag),\n/* harmony export */   getRootEventId: () => (/* binding */ getRootEventId),\n/* harmony export */   getRootTag: () => (/* binding */ getRootTag),\n/* harmony export */   giftUnwrap: () => (/* binding */ giftUnwrap),\n/* harmony export */   giftWrap: () => (/* binding */ giftWrap),\n/* harmony export */   imetaTagToTag: () => (/* binding */ imetaTagToTag),\n/* harmony export */   isEventOriginalPost: () => (/* binding */ isEventOriginalPost),\n/* harmony export */   isNip33AValue: () => (/* binding */ isNip33AValue),\n/* harmony export */   mapImetaTag: () => (/* binding */ mapImetaTag),\n/* harmony export */   matchFilter: () => (/* binding */ matchFilter),\n/* harmony export */   mergeFilters: () => (/* binding */ mergeFilters),\n/* harmony export */   mergeTags: () => (/* binding */ mergeTags),\n/* harmony export */   ndkSignerFromPayload: () => (/* binding */ ndkSignerFromPayload),\n/* harmony export */   newAmount: () => (/* binding */ newAmount),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeRelayUrl: () => (/* binding */ normalizeRelayUrl),\n/* harmony export */   normalizeUrl: () => (/* binding */ normalizeUrl),\n/* harmony export */   parseTagToSubscriptionAmount: () => (/* binding */ parseTagToSubscriptionAmount),\n/* harmony export */   pinEvent: () => (/* binding */ pinEvent),\n/* harmony export */   possibleIntervalFrequencies: () => (/* binding */ possibleIntervalFrequencies),\n/* harmony export */   profileFromEvent: () => (/* binding */ profileFromEvent),\n/* harmony export */   proofP2pk: () => (/* binding */ proofP2pk),\n/* harmony export */   proofP2pkNostr: () => (/* binding */ proofP2pkNostr),\n/* harmony export */   proofsTotalBalance: () => (/* binding */ proofsTotalBalance),\n/* harmony export */   queryFullyFilled: () => (/* binding */ queryFullyFilled),\n/* harmony export */   relayListFromKind3: () => (/* binding */ relayListFromKind3),\n/* harmony export */   relaysFromBech32: () => (/* binding */ relaysFromBech32),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializeProfile: () => (/* binding */ serializeProfile),\n/* harmony export */   signerRegistry: () => (/* binding */ signerRegistry),\n/* harmony export */   strToDimension: () => (/* binding */ strToDimension),\n/* harmony export */   strToPosition: () => (/* binding */ strToPosition),\n/* harmony export */   tryNormalizeRelayUrl: () => (/* binding */ tryNormalizeRelayUrl),\n/* harmony export */   uniqueTag: () => (/* binding */ uniqueTag),\n/* harmony export */   wrapEvent: () => (/* binding */ wrapEvent),\n/* harmony export */   zapInvoiceFromEvent: () => (/* binding */ zapInvoiceFromEvent)\n/* harmony export */ });\n/* harmony import */ var tseep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tseep */ \"(rsc)/./node_modules/tseep/lib/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools */ \"(rsc)/./node_modules/nostr-tools/lib/esm/index.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(rsc)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(rsc)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/utils */ \"(rsc)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! typescript-lru-cache */ \"(rsc)/./node_modules/typescript-lru-cache/dist/index.js\");\n/* harmony import */ var light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! light-bolt11-decoder */ \"(rsc)/./node_modules/light-bolt11-decoder/bolt11.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @scure/base */ \"(rsc)/./node_modules/@scure/base/lib/esm/index.js\");\n// src/types.ts\nvar NdkNutzapStatus = /* @__PURE__ */ ((NdkNutzapStatus2) => {\n  NdkNutzapStatus2[\"INITIAL\"] = \"initial\";\n  NdkNutzapStatus2[\"PROCESSING\"] = \"processing\";\n  NdkNutzapStatus2[\"REDEEMED\"] = \"redeemed\";\n  NdkNutzapStatus2[\"SPENT\"] = \"spent\";\n  NdkNutzapStatus2[\"MISSING_PRIVKEY\"] = \"missing_privkey\";\n  NdkNutzapStatus2[\"TEMPORARY_ERROR\"] = \"temporary_error\";\n  NdkNutzapStatus2[\"PERMANENT_ERROR\"] = \"permanent_error\";\n  NdkNutzapStatus2[\"INVALID_NUTZAP\"] = \"invalid_nutzap\";\n  return NdkNutzapStatus2;\n})(NdkNutzapStatus || {});\n\n// src/events/kinds/index.ts\nvar NDKKind = /* @__PURE__ */ ((NDKKind2) => {\n  NDKKind2[NDKKind2[\"Metadata\"] = 0] = \"Metadata\";\n  NDKKind2[NDKKind2[\"Text\"] = 1] = \"Text\";\n  NDKKind2[NDKKind2[\"RecommendRelay\"] = 2] = \"RecommendRelay\";\n  NDKKind2[NDKKind2[\"Contacts\"] = 3] = \"Contacts\";\n  NDKKind2[NDKKind2[\"EncryptedDirectMessage\"] = 4] = \"EncryptedDirectMessage\";\n  NDKKind2[NDKKind2[\"EventDeletion\"] = 5] = \"EventDeletion\";\n  NDKKind2[NDKKind2[\"Repost\"] = 6] = \"Repost\";\n  NDKKind2[NDKKind2[\"Reaction\"] = 7] = \"Reaction\";\n  NDKKind2[NDKKind2[\"BadgeAward\"] = 8] = \"BadgeAward\";\n  NDKKind2[NDKKind2[\"GroupChat\"] = 9] = \"GroupChat\";\n  NDKKind2[NDKKind2[\"GroupNote\"] = 11] = \"GroupNote\";\n  NDKKind2[NDKKind2[\"GroupReply\"] = 12] = \"GroupReply\";\n  NDKKind2[NDKKind2[\"GiftWrapSeal\"] = 13] = \"GiftWrapSeal\";\n  NDKKind2[NDKKind2[\"PrivateDirectMessage\"] = 14] = \"PrivateDirectMessage\";\n  NDKKind2[NDKKind2[\"Image\"] = 20] = \"Image\";\n  NDKKind2[NDKKind2[\"Video\"] = 21] = \"Video\";\n  NDKKind2[NDKKind2[\"ShortVideo\"] = 22] = \"ShortVideo\";\n  NDKKind2[NDKKind2[\"Story\"] = 23] = \"Story\";\n  NDKKind2[NDKKind2[\"Vanish\"] = 62] = \"Vanish\";\n  NDKKind2[NDKKind2[\"CashuWalletBackup\"] = 375] = \"CashuWalletBackup\";\n  NDKKind2[NDKKind2[\"GiftWrap\"] = 1059] = \"GiftWrap\";\n  NDKKind2[NDKKind2[\"GenericRepost\"] = 16] = \"GenericRepost\";\n  NDKKind2[NDKKind2[\"ChannelCreation\"] = 40] = \"ChannelCreation\";\n  NDKKind2[NDKKind2[\"ChannelMetadata\"] = 41] = \"ChannelMetadata\";\n  NDKKind2[NDKKind2[\"ChannelMessage\"] = 42] = \"ChannelMessage\";\n  NDKKind2[NDKKind2[\"ChannelHideMessage\"] = 43] = \"ChannelHideMessage\";\n  NDKKind2[NDKKind2[\"ChannelMuteUser\"] = 44] = \"ChannelMuteUser\";\n  NDKKind2[NDKKind2[\"GenericReply\"] = 1111] = \"GenericReply\";\n  NDKKind2[NDKKind2[\"Media\"] = 1063] = \"Media\";\n  NDKKind2[NDKKind2[\"Report\"] = 1984] = \"Report\";\n  NDKKind2[NDKKind2[\"Label\"] = 1985] = \"Label\";\n  NDKKind2[NDKKind2[\"DVMReqTextExtraction\"] = 5e3] = \"DVMReqTextExtraction\";\n  NDKKind2[NDKKind2[\"DVMReqTextSummarization\"] = 5001] = \"DVMReqTextSummarization\";\n  NDKKind2[NDKKind2[\"DVMReqTextTranslation\"] = 5002] = \"DVMReqTextTranslation\";\n  NDKKind2[NDKKind2[\"DVMReqTextGeneration\"] = 5050] = \"DVMReqTextGeneration\";\n  NDKKind2[NDKKind2[\"DVMReqImageGeneration\"] = 5100] = \"DVMReqImageGeneration\";\n  NDKKind2[NDKKind2[\"DVMReqTextToSpeech\"] = 5250] = \"DVMReqTextToSpeech\";\n  NDKKind2[NDKKind2[\"DVMReqDiscoveryNostrContent\"] = 5300] = \"DVMReqDiscoveryNostrContent\";\n  NDKKind2[NDKKind2[\"DVMReqDiscoveryNostrPeople\"] = 5301] = \"DVMReqDiscoveryNostrPeople\";\n  NDKKind2[NDKKind2[\"DVMReqTimestamping\"] = 5900] = \"DVMReqTimestamping\";\n  NDKKind2[NDKKind2[\"DVMEventSchedule\"] = 5905] = \"DVMEventSchedule\";\n  NDKKind2[NDKKind2[\"DVMJobFeedback\"] = 7e3] = \"DVMJobFeedback\";\n  NDKKind2[NDKKind2[\"Subscribe\"] = 7001] = \"Subscribe\";\n  NDKKind2[NDKKind2[\"Unsubscribe\"] = 7002] = \"Unsubscribe\";\n  NDKKind2[NDKKind2[\"SubscriptionReceipt\"] = 7003] = \"SubscriptionReceipt\";\n  NDKKind2[NDKKind2[\"CashuReserve\"] = 7373] = \"CashuReserve\";\n  NDKKind2[NDKKind2[\"CashuQuote\"] = 7374] = \"CashuQuote\";\n  NDKKind2[NDKKind2[\"CashuToken\"] = 7375] = \"CashuToken\";\n  NDKKind2[NDKKind2[\"CashuWalletTx\"] = 7376] = \"CashuWalletTx\";\n  NDKKind2[NDKKind2[\"GroupAdminAddUser\"] = 9e3] = \"GroupAdminAddUser\";\n  NDKKind2[NDKKind2[\"GroupAdminRemoveUser\"] = 9001] = \"GroupAdminRemoveUser\";\n  NDKKind2[NDKKind2[\"GroupAdminEditMetadata\"] = 9002] = \"GroupAdminEditMetadata\";\n  NDKKind2[NDKKind2[\"GroupAdminEditStatus\"] = 9006] = \"GroupAdminEditStatus\";\n  NDKKind2[NDKKind2[\"GroupAdminCreateGroup\"] = 9007] = \"GroupAdminCreateGroup\";\n  NDKKind2[NDKKind2[\"GroupAdminRequestJoin\"] = 9021] = \"GroupAdminRequestJoin\";\n  NDKKind2[NDKKind2[\"MuteList\"] = 1e4] = \"MuteList\";\n  NDKKind2[NDKKind2[\"PinList\"] = 10001] = \"PinList\";\n  NDKKind2[NDKKind2[\"RelayList\"] = 10002] = \"RelayList\";\n  NDKKind2[NDKKind2[\"BookmarkList\"] = 10003] = \"BookmarkList\";\n  NDKKind2[NDKKind2[\"CommunityList\"] = 10004] = \"CommunityList\";\n  NDKKind2[NDKKind2[\"PublicChatList\"] = 10005] = \"PublicChatList\";\n  NDKKind2[NDKKind2[\"BlockRelayList\"] = 10006] = \"BlockRelayList\";\n  NDKKind2[NDKKind2[\"SearchRelayList\"] = 10007] = \"SearchRelayList\";\n  NDKKind2[NDKKind2[\"SimpleGroupList\"] = 10009] = \"SimpleGroupList\";\n  NDKKind2[NDKKind2[\"InterestList\"] = 10015] = \"InterestList\";\n  NDKKind2[NDKKind2[\"CashuMintList\"] = 10019] = \"CashuMintList\";\n  NDKKind2[NDKKind2[\"EmojiList\"] = 10030] = \"EmojiList\";\n  NDKKind2[NDKKind2[\"DirectMessageReceiveRelayList\"] = 10050] = \"DirectMessageReceiveRelayList\";\n  NDKKind2[NDKKind2[\"BlossomList\"] = 10063] = \"BlossomList\";\n  NDKKind2[NDKKind2[\"NostrWaletConnectInfo\"] = 13194] = \"NostrWaletConnectInfo\";\n  NDKKind2[NDKKind2[\"TierList\"] = 17e3] = \"TierList\";\n  NDKKind2[NDKKind2[\"CashuWallet\"] = 17375] = \"CashuWallet\";\n  NDKKind2[NDKKind2[\"FollowSet\"] = 3e4] = \"FollowSet\";\n  NDKKind2[NDKKind2[\"CategorizedPeopleList\"] = 3e4 /* FollowSet */] = \"CategorizedPeopleList\";\n  NDKKind2[NDKKind2[\"CategorizedBookmarkList\"] = 30001] = \"CategorizedBookmarkList\";\n  NDKKind2[NDKKind2[\"RelaySet\"] = 30002] = \"RelaySet\";\n  NDKKind2[NDKKind2[\"CategorizedRelayList\"] = 30002 /* RelaySet */] = \"CategorizedRelayList\";\n  NDKKind2[NDKKind2[\"BookmarkSet\"] = 30003] = \"BookmarkSet\";\n  NDKKind2[NDKKind2[\"CurationSet\"] = 30004] = \"CurationSet\";\n  NDKKind2[NDKKind2[\"ArticleCurationSet\"] = 30004] = \"ArticleCurationSet\";\n  NDKKind2[NDKKind2[\"VideoCurationSet\"] = 30005] = \"VideoCurationSet\";\n  NDKKind2[NDKKind2[\"ImageCurationSet\"] = 30006] = \"ImageCurationSet\";\n  NDKKind2[NDKKind2[\"InterestSet\"] = 30015] = \"InterestSet\";\n  NDKKind2[NDKKind2[\"InterestsList\"] = 30015 /* InterestSet */] = \"InterestsList\";\n  NDKKind2[NDKKind2[\"EmojiSet\"] = 30030] = \"EmojiSet\";\n  NDKKind2[NDKKind2[\"ModularArticle\"] = 30040] = \"ModularArticle\";\n  NDKKind2[NDKKind2[\"ModularArticleItem\"] = 30041] = \"ModularArticleItem\";\n  NDKKind2[NDKKind2[\"Wiki\"] = 30818] = \"Wiki\";\n  NDKKind2[NDKKind2[\"Draft\"] = 31234] = \"Draft\";\n  NDKKind2[NDKKind2[\"SubscriptionTier\"] = 37001] = \"SubscriptionTier\";\n  NDKKind2[NDKKind2[\"EcashMintRecommendation\"] = 38e3] = \"EcashMintRecommendation\";\n  NDKKind2[NDKKind2[\"HighlightSet\"] = 39802] = \"HighlightSet\";\n  NDKKind2[NDKKind2[\"CategorizedHighlightList\"] = 39802 /* HighlightSet */] = \"CategorizedHighlightList\";\n  NDKKind2[NDKKind2[\"Nutzap\"] = 9321] = \"Nutzap\";\n  NDKKind2[NDKKind2[\"ZapRequest\"] = 9734] = \"ZapRequest\";\n  NDKKind2[NDKKind2[\"Zap\"] = 9735] = \"Zap\";\n  NDKKind2[NDKKind2[\"Highlight\"] = 9802] = \"Highlight\";\n  NDKKind2[NDKKind2[\"ClientAuth\"] = 22242] = \"ClientAuth\";\n  NDKKind2[NDKKind2[\"NostrWalletConnectReq\"] = 23194] = \"NostrWalletConnectReq\";\n  NDKKind2[NDKKind2[\"NostrWalletConnectRes\"] = 23195] = \"NostrWalletConnectRes\";\n  NDKKind2[NDKKind2[\"NostrConnect\"] = 24133] = \"NostrConnect\";\n  NDKKind2[NDKKind2[\"BlossomUpload\"] = 24242] = \"BlossomUpload\";\n  NDKKind2[NDKKind2[\"HttpAuth\"] = 27235] = \"HttpAuth\";\n  NDKKind2[NDKKind2[\"ProfileBadge\"] = 30008] = \"ProfileBadge\";\n  NDKKind2[NDKKind2[\"BadgeDefinition\"] = 30009] = \"BadgeDefinition\";\n  NDKKind2[NDKKind2[\"MarketStall\"] = 30017] = \"MarketStall\";\n  NDKKind2[NDKKind2[\"MarketProduct\"] = 30018] = \"MarketProduct\";\n  NDKKind2[NDKKind2[\"Article\"] = 30023] = \"Article\";\n  NDKKind2[NDKKind2[\"AppSpecificData\"] = 30078] = \"AppSpecificData\";\n  NDKKind2[NDKKind2[\"Classified\"] = 30402] = \"Classified\";\n  NDKKind2[NDKKind2[\"HorizontalVideo\"] = 34235] = \"HorizontalVideo\";\n  NDKKind2[NDKKind2[\"VerticalVideo\"] = 34236] = \"VerticalVideo\";\n  NDKKind2[NDKKind2[\"LegacyCashuWallet\"] = 37375] = \"LegacyCashuWallet\";\n  NDKKind2[NDKKind2[\"GroupMetadata\"] = 39e3] = \"GroupMetadata\";\n  NDKKind2[NDKKind2[\"GroupAdmins\"] = 39001] = \"GroupAdmins\";\n  NDKKind2[NDKKind2[\"GroupMembers\"] = 39002] = \"GroupMembers\";\n  NDKKind2[NDKKind2[\"AppRecommendation\"] = 31989] = \"AppRecommendation\";\n  NDKKind2[NDKKind2[\"AppHandler\"] = 31990] = \"AppHandler\";\n  return NDKKind2;\n})(NDKKind || {});\nvar NDKListKinds = [\n  1e4 /* MuteList */,\n  10001 /* PinList */,\n  10002 /* RelayList */,\n  10003 /* BookmarkList */,\n  10004 /* CommunityList */,\n  10005 /* PublicChatList */,\n  10006 /* BlockRelayList */,\n  10007 /* SearchRelayList */,\n  10015 /* InterestList */,\n  10030 /* EmojiList */,\n  10050 /* DirectMessageReceiveRelayList */,\n  3e4 /* FollowSet */,\n  30003 /* BookmarkSet */,\n  30001 /* CategorizedBookmarkList */,\n  // Backwards compatibility\n  30002 /* RelaySet */,\n  30004 /* ArticleCurationSet */,\n  30005 /* VideoCurationSet */,\n  30015 /* InterestSet */,\n  30030 /* EmojiSet */,\n  39802 /* HighlightSet */\n];\n\n// src/events/index.ts\n\n\n// src/relay/sets/calculate.ts\n\n\n// src/outbox/write.ts\nfunction getRelaysForSync(ndk, author, type = \"write\") {\n  if (!ndk.outboxTracker) return void 0;\n  const item = ndk.outboxTracker.data.get(author);\n  if (!item) return void 0;\n  if (type === \"write\") {\n    return item.writeRelays;\n  }\n  return item.readRelays;\n}\nasync function getWriteRelaysFor(ndk, author, type = \"write\") {\n  if (!ndk.outboxTracker) return void 0;\n  if (!ndk.outboxTracker.data.has(author)) {\n    await ndk.outboxTracker.trackUsers([author]);\n  }\n  return getRelaysForSync(ndk, author, type);\n}\n\n// src/outbox/relay-ranking.ts\nfunction getTopRelaysForAuthors(ndk, authors) {\n  const relaysWithCount = /* @__PURE__ */ new Map();\n  authors.forEach((author) => {\n    const writeRelays = getRelaysForSync(ndk, author);\n    if (writeRelays) {\n      writeRelays.forEach((relay) => {\n        const count = relaysWithCount.get(relay) || 0;\n        relaysWithCount.set(relay, count + 1);\n      });\n    }\n  });\n  const sortedRelays = Array.from(relaysWithCount.entries()).sort((a, b) => b[1] - a[1]);\n  return sortedRelays.map((entry) => entry[0]);\n}\n\n// src/outbox/index.ts\nfunction getAllRelaysForAllPubkeys(ndk, pubkeys, type = \"read\") {\n  const pubkeysToRelays = /* @__PURE__ */ new Map();\n  const authorsMissingRelays = /* @__PURE__ */ new Set();\n  pubkeys.forEach((pubkey) => {\n    const relays = getRelaysForSync(ndk, pubkey, type);\n    if (relays && relays.size > 0) {\n      relays.forEach((relay) => {\n        const pubkeysInRelay = pubkeysToRelays.get(relay) || /* @__PURE__ */ new Set();\n        pubkeysInRelay.add(pubkey);\n      });\n      pubkeysToRelays.set(pubkey, relays);\n    } else {\n      authorsMissingRelays.add(pubkey);\n    }\n  });\n  return { pubkeysToRelays, authorsMissingRelays };\n}\nfunction chooseRelayCombinationForPubkeys(ndk, pubkeys, type, { count, preferredRelays } = {}) {\n  count ??= 2;\n  preferredRelays ??= /* @__PURE__ */ new Set();\n  const pool = ndk.pool;\n  const connectedRelays = pool.connectedRelays();\n  connectedRelays.forEach((relay) => {\n    preferredRelays?.add(relay.url);\n  });\n  const relayToAuthorsMap = /* @__PURE__ */ new Map();\n  const { pubkeysToRelays, authorsMissingRelays } = getAllRelaysForAllPubkeys(ndk, pubkeys, type);\n  const sortedRelays = getTopRelaysForAuthors(ndk, pubkeys);\n  const addAuthorToRelay = (author, relay) => {\n    const authorsInRelay = relayToAuthorsMap.get(relay) || [];\n    authorsInRelay.push(author);\n    relayToAuthorsMap.set(relay, authorsInRelay);\n  };\n  for (const [author, authorRelays] of pubkeysToRelays.entries()) {\n    let missingRelayCount = count;\n    for (const relay of connectedRelays) {\n      if (authorRelays.has(relay.url)) {\n        addAuthorToRelay(author, relay.url);\n        missingRelayCount--;\n      }\n    }\n    for (const authorRelay of authorRelays) {\n      if (relayToAuthorsMap.has(authorRelay)) {\n        addAuthorToRelay(author, authorRelay);\n        missingRelayCount--;\n      }\n    }\n    if (missingRelayCount <= 0) continue;\n    for (const relay of sortedRelays) {\n      if (missingRelayCount <= 0) break;\n      if (authorRelays.has(relay)) {\n        addAuthorToRelay(author, relay);\n        missingRelayCount--;\n      }\n    }\n  }\n  for (const author of authorsMissingRelays) {\n    pool.permanentAndConnectedRelays().forEach((relay) => {\n      const authorsInRelay = relayToAuthorsMap.get(relay.url) || [];\n      authorsInRelay.push(author);\n      relayToAuthorsMap.set(relay.url, authorsInRelay);\n    });\n  }\n  return relayToAuthorsMap;\n}\n\n// src/outbox/read/with-authors.ts\nfunction getRelaysForFilterWithAuthors(ndk, authors, relayGoalPerAuthor = 2) {\n  return chooseRelayCombinationForPubkeys(ndk, authors, \"write\", { count: relayGoalPerAuthor });\n}\n\n// src/utils/normalize-url.ts\nfunction tryNormalizeRelayUrl(url) {\n  try {\n    return normalizeRelayUrl(url);\n  } catch {\n    return void 0;\n  }\n}\nfunction normalizeRelayUrl(url) {\n  let r = normalizeUrl(url, {\n    stripAuthentication: false,\n    stripWWW: false,\n    stripHash: true\n  });\n  if (!r.endsWith(\"/\")) {\n    r += \"/\";\n  }\n  return r;\n}\nfunction normalize(urls) {\n  const normalized = /* @__PURE__ */ new Set();\n  for (const url of urls) {\n    try {\n      normalized.add(normalizeRelayUrl(url));\n    } catch {\n    }\n  }\n  return Array.from(normalized);\n}\nvar DATA_URL_DEFAULT_MIME_TYPE = \"text/plain\";\nvar DATA_URL_DEFAULT_CHARSET = \"us-ascii\";\nvar testParameter = (name, filters) => filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);\nvar supportedProtocols = /* @__PURE__ */ new Set([\"https:\", \"http:\", \"file:\"]);\nvar hasCustomProtocol = (urlString) => {\n  try {\n    const { protocol } = new URL(urlString);\n    return protocol.endsWith(\":\") && !protocol.includes(\".\") && !supportedProtocols.has(protocol);\n  } catch {\n    return false;\n  }\n};\nvar normalizeDataURL = (urlString, { stripHash }) => {\n  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);\n  if (!match) {\n    throw new Error(`Invalid URL: ${urlString}`);\n  }\n  const type = match.groups?.type ?? \"\";\n  const data = match.groups?.data ?? \"\";\n  let hash = match.groups?.hash ?? \"\";\n  const mediaType = type.split(\";\");\n  hash = stripHash ? \"\" : hash;\n  let isBase64 = false;\n  if (mediaType[mediaType.length - 1] === \"base64\") {\n    mediaType.pop();\n    isBase64 = true;\n  }\n  const mimeType = mediaType.shift()?.toLowerCase() ?? \"\";\n  const attributes = mediaType.map((attribute) => {\n    let [key, value = \"\"] = attribute.split(\"=\").map((string) => string.trim());\n    if (key === \"charset\") {\n      value = value.toLowerCase();\n      if (value === DATA_URL_DEFAULT_CHARSET) {\n        return \"\";\n      }\n    }\n    return `${key}${value ? `=${value}` : \"\"}`;\n  }).filter(Boolean);\n  const normalizedMediaType = [...attributes];\n  if (isBase64) {\n    normalizedMediaType.push(\"base64\");\n  }\n  if (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {\n    normalizedMediaType.unshift(mimeType);\n  }\n  return `data:${normalizedMediaType.join(\";\")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : \"\"}`;\n};\nfunction normalizeUrl(urlString, options = {}) {\n  options = {\n    defaultProtocol: \"http\",\n    normalizeProtocol: true,\n    forceHttp: false,\n    forceHttps: false,\n    stripAuthentication: true,\n    stripHash: false,\n    stripTextFragment: true,\n    stripWWW: true,\n    removeQueryParameters: [/^utm_\\w+/i],\n    removeTrailingSlash: true,\n    removeSingleSlash: true,\n    removeDirectoryIndex: false,\n    removeExplicitPort: false,\n    sortQueryParameters: true,\n    ...options\n  };\n  if (typeof options.defaultProtocol === \"string\" && !options.defaultProtocol.endsWith(\":\")) {\n    options.defaultProtocol = `${options.defaultProtocol}:`;\n  }\n  urlString = urlString.trim();\n  if (/^data:/i.test(urlString)) {\n    return normalizeDataURL(urlString, options);\n  }\n  if (hasCustomProtocol(urlString)) {\n    return urlString;\n  }\n  const hasRelativeProtocol = urlString.startsWith(\"//\");\n  const isRelativeUrl = !hasRelativeProtocol && /^\\.*\\//.test(urlString);\n  if (!isRelativeUrl) {\n    urlString = urlString.replace(/^(?!(?:\\w+:)?\\/\\/)|^\\/\\//, options.defaultProtocol);\n  }\n  const urlObject = new URL(urlString);\n  urlObject.hostname = urlObject.hostname.toLowerCase();\n  if (options.forceHttp && options.forceHttps) {\n    throw new Error(\"The `forceHttp` and `forceHttps` options cannot be used together\");\n  }\n  if (options.forceHttp && urlObject.protocol === \"https:\") {\n    urlObject.protocol = \"http:\";\n  }\n  if (options.forceHttps && urlObject.protocol === \"http:\") {\n    urlObject.protocol = \"https:\";\n  }\n  if (options.stripAuthentication) {\n    urlObject.username = \"\";\n    urlObject.password = \"\";\n  }\n  if (options.stripHash) {\n    urlObject.hash = \"\";\n  } else if (options.stripTextFragment) {\n    urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, \"\");\n  }\n  if (urlObject.pathname) {\n    const protocolRegex = /\\b[a-z][a-z\\d+\\-.]{1,50}:\\/\\//g;\n    let lastIndex = 0;\n    let result = \"\";\n    for (; ; ) {\n      const match = protocolRegex.exec(urlObject.pathname);\n      if (!match) {\n        break;\n      }\n      const protocol = match[0];\n      const protocolAtIndex = match.index;\n      const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);\n      result += intermediate.replace(/\\/{2,}/g, \"/\");\n      result += protocol;\n      lastIndex = protocolAtIndex + protocol.length;\n    }\n    const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);\n    result += remnant.replace(/\\/{2,}/g, \"/\");\n    urlObject.pathname = result;\n  }\n  if (urlObject.pathname) {\n    try {\n      urlObject.pathname = decodeURI(urlObject.pathname);\n    } catch {\n    }\n  }\n  if (options.removeDirectoryIndex === true) {\n    options.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n  }\n  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {\n    let pathComponents = urlObject.pathname.split(\"/\");\n    const lastComponent = pathComponents[pathComponents.length - 1];\n    if (testParameter(lastComponent, options.removeDirectoryIndex)) {\n      pathComponents = pathComponents.slice(0, -1);\n      urlObject.pathname = `${pathComponents.slice(1).join(\"/\")}/`;\n    }\n  }\n  if (urlObject.hostname) {\n    urlObject.hostname = urlObject.hostname.replace(/\\.$/, \"\");\n    if (options.stripWWW && /^www\\.(?!www\\.)[a-z\\-\\d]{1,63}\\.[a-z.\\-\\d]{2,63}$/.test(urlObject.hostname)) {\n      urlObject.hostname = urlObject.hostname.replace(/^www\\./, \"\");\n    }\n  }\n  if (Array.isArray(options.removeQueryParameters)) {\n    for (const key of [...urlObject.searchParams.keys()]) {\n      if (testParameter(key, options.removeQueryParameters)) {\n        urlObject.searchParams.delete(key);\n      }\n    }\n  }\n  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {\n    urlObject.search = \"\";\n  }\n  if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {\n    for (const key of [...urlObject.searchParams.keys()]) {\n      if (!testParameter(key, options.keepQueryParameters)) {\n        urlObject.searchParams.delete(key);\n      }\n    }\n  }\n  if (options.sortQueryParameters) {\n    urlObject.searchParams.sort();\n    try {\n      urlObject.search = decodeURIComponent(urlObject.search);\n    } catch {\n    }\n  }\n  if (options.removeTrailingSlash) {\n    urlObject.pathname = urlObject.pathname.replace(/\\/$/, \"\");\n  }\n  if (options.removeExplicitPort && urlObject.port) {\n    urlObject.port = \"\";\n  }\n  const oldUrlString = urlString;\n  urlString = urlObject.toString();\n  if (!options.removeSingleSlash && urlObject.pathname === \"/\" && !oldUrlString.endsWith(\"/\") && urlObject.hash === \"\") {\n    urlString = urlString.replace(/\\/$/, \"\");\n  }\n  if ((options.removeTrailingSlash || urlObject.pathname === \"/\") && urlObject.hash === \"\" && options.removeSingleSlash) {\n    urlString = urlString.replace(/\\/$/, \"\");\n  }\n  if (hasRelativeProtocol && !options.normalizeProtocol) {\n    urlString = urlString.replace(/^http:\\/\\//, \"//\");\n  }\n  if (options.stripProtocol) {\n    urlString = urlString.replace(/^(?:https?:)?\\/\\//, \"\");\n  }\n  return urlString;\n}\n\n// src/relay/index.ts\n\n\n\n// src/relay/connectivity.ts\nvar MAX_RECONNECT_ATTEMPTS = 5;\nvar FLAPPING_THRESHOLD_MS = 1e3;\nvar NDKRelayConnectivity = class {\n  ndkRelay;\n  ws;\n  _status;\n  timeoutMs;\n  connectedAt;\n  _connectionStats = {\n    attempts: 0,\n    success: 0,\n    durations: []\n  };\n  debug;\n  netDebug;\n  connectTimeout;\n  reconnectTimeout;\n  ndk;\n  openSubs = /* @__PURE__ */ new Map();\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  serial = 0;\n  baseEoseTimeout = 4400;\n  constructor(ndkRelay, ndk) {\n    this.ndkRelay = ndkRelay;\n    this._status = 1 /* DISCONNECTED */;\n    const rand = Math.floor(Math.random() * 1e3);\n    this.debug = this.ndkRelay.debug.extend(`connectivity${rand}`);\n    this.ndk = ndk;\n  }\n  /**\n   * Connects to the NDK relay and handles the connection lifecycle.\n   *\n   * This method attempts to establish a WebSocket connection to the NDK relay specified in the `ndkRelay` object.\n   * If the connection is successful, it updates the connection statistics, sets the connection status to `CONNECTED`,\n   * and emits `connect` and `ready` events on the `ndkRelay` object.\n   *\n   * If the connection attempt fails, it handles the error by either initiating a reconnection attempt or emitting a\n   * `delayed-connect` event on the `ndkRelay` object, depending on the `reconnect` parameter.\n   *\n   * @param timeoutMs - The timeout in milliseconds for the connection attempt. If not provided, the default timeout from the `ndkRelay` object is used.\n   * @param reconnect - Indicates whether a reconnection should be attempted if the connection fails. Defaults to `true`.\n   * @returns A Promise that resolves when the connection is established, or rejects if the connection fails.\n   */\n  async connect(timeoutMs, reconnect = true) {\n    if (this._status !== 2 /* RECONNECTING */ && this._status !== 1 /* DISCONNECTED */ || this.reconnectTimeout) {\n      this.debug(\n        \"Relay requested to be connected but was in state %s or it had a reconnect timeout\",\n        this._status\n      );\n      return;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = void 0;\n    }\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = void 0;\n    }\n    timeoutMs ??= this.timeoutMs;\n    if (!this.timeoutMs && timeoutMs) this.timeoutMs = timeoutMs;\n    if (this.timeoutMs) this.connectTimeout = setTimeout(() => this.onConnectionError(reconnect), this.timeoutMs);\n    try {\n      this.updateConnectionStats.attempt();\n      if (this._status === 1 /* DISCONNECTED */) this._status = 4 /* CONNECTING */;\n      else this._status = 2 /* RECONNECTING */;\n      this.ws = new WebSocket(this.ndkRelay.url);\n      this.ws.onopen = this.onConnect.bind(this);\n      this.ws.onclose = this.onDisconnect.bind(this);\n      this.ws.onmessage = this.onMessage.bind(this);\n      this.ws.onerror = this.onError.bind(this);\n    } catch (e) {\n      this.debug(`Failed to connect to ${this.ndkRelay.url}`, e);\n      this._status = 1 /* DISCONNECTED */;\n      if (reconnect) this.handleReconnection();\n      else this.ndkRelay.emit(\"delayed-connect\", 2 * 24 * 60 * 60 * 1e3);\n      throw e;\n    }\n  }\n  /**\n   * Disconnects the WebSocket connection to the NDK relay.\n   * This method sets the connection status to `NDKRelayStatus.DISCONNECTING`,\n   * attempts to close the WebSocket connection, and sets the status to\n   * `NDKRelayStatus.DISCONNECTED` if the disconnect operation fails.\n   */\n  disconnect() {\n    this._status = 0 /* DISCONNECTING */;\n    try {\n      this.ws?.close();\n    } catch (e) {\n      this.debug(\"Failed to disconnect\", e);\n      this._status = 1 /* DISCONNECTED */;\n    }\n  }\n  /**\n   * Handles the error that occurred when attempting to connect to the NDK relay.\n   * If `reconnect` is `true`, this method will initiate a reconnection attempt.\n   * Otherwise, it will emit a `delayed-connect` event on the `ndkRelay` object,\n   * indicating that a reconnection should be attempted after a delay.\n   *\n   * @param reconnect - Indicates whether a reconnection should be attempted.\n   */\n  onConnectionError(reconnect) {\n    this.debug(`Error connecting to ${this.ndkRelay.url}`, this.timeoutMs);\n    if (reconnect && !this.reconnectTimeout) {\n      this.handleReconnection();\n    }\n  }\n  /**\n   * Handles the connection event when the WebSocket connection is established.\n   * This method is called when the WebSocket connection is successfully opened.\n   * It clears any existing connection and reconnection timeouts, updates the connection statistics,\n   * sets the connection status to `CONNECTED`, and emits `connect` and `ready` events on the `ndkRelay` object.\n   */\n  onConnect() {\n    this.netDebug?.(\"connected\", this.ndkRelay);\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = void 0;\n    }\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = void 0;\n    }\n    this.updateConnectionStats.connected();\n    this._status = 5 /* CONNECTED */;\n    this.ndkRelay.emit(\"connect\");\n    this.ndkRelay.emit(\"ready\");\n  }\n  /**\n   * Handles the disconnection event when the WebSocket connection is closed.\n   * This method is called when the WebSocket connection is successfully closed.\n   * It updates the connection statistics, sets the connection status to `DISCONNECTED`,\n   * initiates a reconnection attempt if we didn't disconnect ourselves,\n   * and emits a `disconnect` event on the `ndkRelay` object.\n   */\n  onDisconnect() {\n    this.netDebug?.(\"disconnected\", this.ndkRelay);\n    this.updateConnectionStats.disconnected();\n    if (this._status === 5 /* CONNECTED */) {\n      this.handleReconnection();\n    }\n    this._status = 1 /* DISCONNECTED */;\n    this.ndkRelay.emit(\"disconnect\");\n  }\n  /**\n   * Handles incoming messages from the NDK relay WebSocket connection.\n   * This method is called whenever a message is received from the relay.\n   * It parses the message data and dispatches the appropriate handling logic based on the message type.\n   *\n   * @param event - The MessageEvent containing the received message data.\n   */\n  onMessage(event) {\n    this.netDebug?.(event.data, this.ndkRelay, \"recv\");\n    try {\n      const data = JSON.parse(event.data);\n      const [cmd, id, ..._rest] = data;\n      switch (cmd) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(id);\n          const event2 = data[2];\n          if (!so) {\n            this.debug(`Received event for unknown subscription ${id}`);\n            return;\n          }\n          so.onevent(event2);\n          return;\n        }\n        case \"COUNT\": {\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(id);\n          if (!so) return;\n          so.oneose(id);\n          return;\n        }\n        case \"OK\": {\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          const firstEp = ep?.pop();\n          if (!ep || !firstEp) {\n            this.debug(\"Received OK for unknown event publish\", id);\n            return;\n          }\n          if (ok) firstEp.resolve(reason);\n          else firstEp.reject(new Error(reason));\n          if (ep.length === 0) {\n            this.openEventPublishes.delete(id);\n          } else {\n            this.openEventPublishes.set(id, ep);\n          }\n          return;\n        }\n        case \"CLOSED\": {\n          const so = this.openSubs.get(id);\n          if (!so) return;\n          so.onclosed(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onNotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.onAuthRequested(data[1]);\n          return;\n        }\n      }\n    } catch (error) {\n      this.debug(`Error parsing message from ${this.ndkRelay.url}: ${error.message}`, error?.stack);\n      return;\n    }\n  }\n  /**\n   * Handles an authentication request from the NDK relay.\n   *\n   * If an authentication policy is configured, it will be used to authenticate the connection.\n   * Otherwise, the `auth` event will be emitted to allow the application to handle the authentication.\n   *\n   * @param challenge - The authentication challenge provided by the NDK relay.\n   */\n  async onAuthRequested(challenge) {\n    const authPolicy = this.ndkRelay.authPolicy ?? this.ndk?.relayAuthDefaultPolicy;\n    this.debug(\"Relay requested authentication\", {\n      havePolicy: !!authPolicy\n    });\n    if (this._status === 7 /* AUTHENTICATING */) {\n      this.debug(\"Already authenticating, ignoring\");\n      return;\n    }\n    this._status = 6 /* AUTH_REQUESTED */;\n    if (authPolicy) {\n      if (this._status >= 5 /* CONNECTED */) {\n        this._status = 7 /* AUTHENTICATING */;\n        let res;\n        try {\n          res = await authPolicy(this.ndkRelay, challenge);\n        } catch (e) {\n          this.debug(\"Authentication policy threw an error\", e);\n          res = false;\n        }\n        this.debug(\"Authentication policy returned\", !!res);\n        if (res instanceof NDKEvent || res === true) {\n          if (res instanceof NDKEvent) {\n            await this.auth(res);\n          }\n          const authenticate = async () => {\n            if (this._status >= 5 /* CONNECTED */ && this._status < 8 /* AUTHENTICATED */) {\n              const event = new NDKEvent(this.ndk);\n              event.kind = 22242 /* ClientAuth */;\n              event.tags = [\n                [\"relay\", this.ndkRelay.url],\n                [\"challenge\", challenge]\n              ];\n              await event.sign();\n              this.auth(event).then(() => {\n                this._status = 8 /* AUTHENTICATED */;\n                this.ndkRelay.emit(\"authed\");\n                this.debug(\"Authentication successful\");\n              }).catch((e) => {\n                this._status = 6 /* AUTH_REQUESTED */;\n                this.ndkRelay.emit(\"auth:failed\", e);\n                this.debug(\"Authentication failed\", e);\n              });\n            } else {\n              this.debug(\"Authentication failed, it changed status, status is %d\", this._status);\n            }\n          };\n          if (res === true) {\n            if (!this.ndk?.signer) {\n              this.debug(\"No signer available for authentication localhost\");\n              this.ndk?.once(\"signer:ready\", authenticate);\n            } else {\n              authenticate().catch((e) => {\n                console.error(\"Error authenticating\", e);\n              });\n            }\n          }\n          this._status = 5 /* CONNECTED */;\n          this.ndkRelay.emit(\"authed\");\n        }\n      }\n    } else {\n      this.ndkRelay.emit(\"auth\", challenge);\n    }\n  }\n  /**\n   * Handles errors that occur on the WebSocket connection to the relay.\n   * @param error - The error or event that occurred.\n   */\n  onError(error) {\n    this.debug(`WebSocket error on ${this.ndkRelay.url}:`, error);\n  }\n  /**\n   * Gets the current status of the NDK relay connection.\n   * @returns {NDKRelayStatus} The current status of the NDK relay connection.\n   */\n  get status() {\n    return this._status;\n  }\n  /**\n   * Checks if the NDK relay connection is currently available.\n   * @returns {boolean} `true` if the relay connection is in the `CONNECTED` status, `false` otherwise.\n   */\n  isAvailable() {\n    return this._status === 5 /* CONNECTED */;\n  }\n  /**\n   * Checks if the NDK relay connection is flapping, which means the connection is rapidly\n   * disconnecting and reconnecting. This is determined by analyzing the durations of the\n   * last three connection attempts. If the standard deviation of the durations is less\n   * than 1000 milliseconds, the connection is considered to be flapping.\n   *\n   * @returns {boolean} `true` if the connection is flapping, `false` otherwise.\n   */\n  isFlapping() {\n    const durations = this._connectionStats.durations;\n    if (durations.length % 3 !== 0) return false;\n    const sum = durations.reduce((a, b) => a + b, 0);\n    const avg = sum / durations.length;\n    const variance = durations.map((x) => (x - avg) ** 2).reduce((a, b) => a + b, 0) / durations.length;\n    const stdDev = Math.sqrt(variance);\n    const isFlapping = stdDev < FLAPPING_THRESHOLD_MS;\n    return isFlapping;\n  }\n  /**\n   * Handles a notice received from the NDK relay.\n   * If the notice indicates the relay is complaining (e.g. \"too many\" or \"maximum\"),\n   * the method disconnects from the relay and attempts to reconnect after a 2-second delay.\n   * A debug message is logged with the relay URL and the notice text.\n   * The \"notice\" event is emitted on the ndkRelay instance with the notice text.\n   *\n   * @param notice - The notice text received from the NDK relay.\n   */\n  async onNotice(notice) {\n    this.ndkRelay.emit(\"notice\", notice);\n  }\n  /**\n   * Attempts to reconnect to the NDK relay after a connection is lost.\n   * This function is called recursively to handle multiple reconnection attempts.\n   * It checks if the relay is flapping and emits a \"flapping\" event if so.\n   * It then calculates a delay before the next reconnection attempt based on the number of previous attempts.\n   * The function sets a timeout to execute the next reconnection attempt after the calculated delay.\n   * If the maximum number of reconnection attempts is reached, a debug message is logged.\n   *\n   * @param attempt - The current attempt number (default is 0).\n   */\n  handleReconnection(attempt = 0) {\n    if (this.reconnectTimeout) return;\n    if (this.isFlapping()) {\n      this.ndkRelay.emit(\"flapping\", this._connectionStats);\n      this._status = 3 /* FLAPPING */;\n      return;\n    }\n    const reconnectDelay = this.connectedAt ? Math.max(0, 6e4 - (Date.now() - this.connectedAt)) : 5e3 * (this._connectionStats.attempts + 1);\n    this.reconnectTimeout = setTimeout(() => {\n      this.reconnectTimeout = void 0;\n      this._status = 2 /* RECONNECTING */;\n      this.connect().catch((_err) => {\n        if (attempt < MAX_RECONNECT_ATTEMPTS) {\n          setTimeout(\n            () => {\n              this.handleReconnection(attempt + 1);\n            },\n            1e3 * (attempt + 1) ^ 4\n          );\n        } else {\n          this.debug(\"Reconnect failed\");\n        }\n      });\n    }, reconnectDelay);\n    this.ndkRelay.emit(\"delayed-connect\", reconnectDelay);\n    this.debug(\"Reconnecting in\", reconnectDelay);\n    this._connectionStats.nextReconnectAt = Date.now() + reconnectDelay;\n  }\n  /**\n   * Sends a message to the NDK relay if the connection is in the CONNECTED state and the WebSocket is open.\n   * If the connection is not in the CONNECTED state or the WebSocket is not open, logs a debug message and throws an error.\n   *\n   * @param message - The message to send to the NDK relay.\n   * @throws {Error} If attempting to send on a closed relay connection.\n   */\n  async send(message) {\n    if (this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN) {\n      this.ws?.send(message);\n      this.netDebug?.(message, this.ndkRelay, \"send\");\n    } else {\n      this.debug(`Not connected to ${this.ndkRelay.url} (%d), not sending message ${message}`, this._status);\n    }\n  }\n  /**\n   * Authenticates the NDK event by sending it to the NDK relay and returning a promise that resolves with the result.\n   *\n   * @param event - The NDK event to authenticate.\n   * @returns A promise that resolves with the authentication result.\n   */\n  async auth(event) {\n    const ret = new Promise((resolve, reject) => {\n      const val = this.openEventPublishes.get(event.id) ?? [];\n      val.push({ resolve, reject });\n      this.openEventPublishes.set(event.id, val);\n    });\n    this.send(`[\"AUTH\",${JSON.stringify(event.rawEvent())}]`);\n    return ret;\n  }\n  /**\n   * Publishes an NDK event to the relay and returns a promise that resolves with the result.\n   *\n   * @param event - The NDK event to publish.\n   * @returns A promise that resolves with the result of the event publication.\n   * @throws {Error} If attempting to publish on a closed relay connection.\n   */\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      const val = this.openEventPublishes.get(event.id) ?? [];\n      if (val.length > 0) {\n        console.warn(`Duplicate event publishing detected, you are publishing event ${event.id} twice`);\n      }\n      val.push({ resolve, reject });\n      this.openEventPublishes.set(event.id, val);\n    });\n    this.send(`[\"EVENT\",${JSON.stringify(event)}]`);\n    return ret;\n  }\n  /**\n   * Counts the number of events that match the provided filters.\n   *\n   * @param filters - The filters to apply to the count request.\n   * @param params - An optional object containing a custom id for the count request.\n   * @returns A promise that resolves with the number of matching events.\n   * @throws {Error} If attempting to send the count request on a closed relay connection.\n   */\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || `count:${this.serial}`;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send(`[\"COUNT\",\"${id}\",${JSON.stringify(filters).substring(1)}`);\n    return ret;\n  }\n  close(subId, reason) {\n    this.send(`[\"CLOSE\",\"${subId}\"]`);\n    const sub = this.openSubs.get(subId);\n    this.openSubs.delete(subId);\n    if (sub) sub.onclose(reason);\n  }\n  /**\n   * Subscribes to the NDK relay with the provided filters and parameters.\n   *\n   * @param filters - The filters to apply to the subscription.\n   * @param params - The subscription parameters, including an optional custom id.\n   * @returns A new NDKRelaySubscription instance.\n   */\n  req(relaySub) {\n    `${this.send(`[\"REQ\",\"${relaySub.subId}\",${JSON.stringify(relaySub.executeFilters).substring(1)}`)}]`;\n    this.openSubs.set(relaySub.subId, relaySub);\n  }\n  /**\n   * Utility functions to update the connection stats.\n   */\n  updateConnectionStats = {\n    connected: () => {\n      this._connectionStats.success++;\n      this._connectionStats.connectedAt = Date.now();\n    },\n    disconnected: () => {\n      if (this._connectionStats.connectedAt) {\n        this._connectionStats.durations.push(Date.now() - this._connectionStats.connectedAt);\n        if (this._connectionStats.durations.length > 100) {\n          this._connectionStats.durations.shift();\n        }\n      }\n      this._connectionStats.connectedAt = void 0;\n    },\n    attempt: () => {\n      this._connectionStats.attempts++;\n      this._connectionStats.connectedAt = Date.now();\n    }\n  };\n  /** Returns the connection stats. */\n  get connectionStats() {\n    return this._connectionStats;\n  }\n  /** Returns the relay URL */\n  get url() {\n    return this.ndkRelay.url;\n  }\n  get connected() {\n    return this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN;\n  }\n};\n\n// src/relay/publisher.ts\nvar NDKRelayPublisher = class {\n  ndkRelay;\n  debug;\n  constructor(ndkRelay) {\n    this.ndkRelay = ndkRelay;\n    this.debug = ndkRelay.debug.extend(\"publisher\");\n  }\n  /**\n   * Published an event to the relay; if the relay is not connected, it will\n   * wait for the relay to connect before publishing the event.\n   *\n   * If the relay does not connect within the timeout, the publish operation\n   * will fail.\n   * @param event  The event to publish\n   * @param timeoutMs  The timeout for the publish operation in milliseconds\n   * @returns A promise that resolves when the event has been published or rejects if the operation times out\n   */\n  async publish(event, timeoutMs = 2500) {\n    let timeout;\n    const publishConnected = () => {\n      return new Promise((resolve, reject) => {\n        try {\n          this.publishEvent(event).then((_result) => {\n            this.ndkRelay.emit(\"published\", event);\n            event.emit(\"relay:published\", this.ndkRelay);\n            resolve(true);\n          }).catch(reject);\n        } catch (err) {\n          reject(err);\n        }\n      });\n    };\n    const timeoutPromise = new Promise((_, reject) => {\n      timeout = setTimeout(() => {\n        timeout = void 0;\n        reject(new Error(`Timeout: ${timeoutMs}ms`));\n      }, timeoutMs);\n    });\n    const onConnectHandler = () => {\n      publishConnected().then((result) => connectResolve(result)).catch((err) => connectReject(err));\n    };\n    let connectResolve;\n    let connectReject;\n    const onError = (err) => {\n      this.ndkRelay.debug(\"Publish failed\", err, event.id);\n      this.ndkRelay.emit(\"publish:failed\", event, err);\n      event.emit(\"relay:publish:failed\", this.ndkRelay, err);\n      throw err;\n    };\n    const onFinally = () => {\n      if (timeout) clearTimeout(timeout);\n      this.ndkRelay.removeListener(\"connect\", onConnectHandler);\n    };\n    if (this.ndkRelay.status >= 5 /* CONNECTED */) {\n      return Promise.race([publishConnected(), timeoutPromise]).catch(onError).finally(onFinally);\n    }\n    if (this.ndkRelay.status <= 1 /* DISCONNECTED */) {\n      console.warn(\"Relay is disconnected, trying to connect to publish an event\", this.ndkRelay.url);\n      this.ndkRelay.connect();\n    } else {\n      console.warn(\"Relay not connected, waiting for connection to publish an event\", this.ndkRelay.url);\n    }\n    return Promise.race([\n      new Promise((resolve, reject) => {\n        connectResolve = resolve;\n        connectReject = reject;\n        this.ndkRelay.once(\"connect\", onConnectHandler);\n      }),\n      timeoutPromise\n    ]).catch(onError).finally(onFinally);\n  }\n  async publishEvent(event) {\n    return this.ndkRelay.connectivity.publish(event.rawEvent());\n  }\n};\n\n// src/subscription/grouping.ts\nfunction filterFingerprint(filters, closeOnEose) {\n  const elements = [];\n  for (const filter of filters) {\n    const keys = Object.entries(filter || {}).map(([key, values]) => {\n      if ([\"since\", \"until\"].includes(key)) {\n        return `${key}:${values}`;\n      }\n      return key;\n    }).sort().join(\"-\");\n    elements.push(keys);\n  }\n  let id = closeOnEose ? \"+\" : \"\";\n  id += elements.join(\"|\");\n  return id;\n}\nfunction mergeFilters(filters) {\n  const result = [];\n  const lastResult = {};\n  filters.filter((f) => !!f.limit).forEach((filterWithLimit) => result.push(filterWithLimit));\n  filters = filters.filter((f) => !f.limit);\n  if (filters.length === 0) return result;\n  filters.forEach((filter) => {\n    Object.entries(filter).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        if (lastResult[key] === void 0) {\n          lastResult[key] = [...value];\n        } else {\n          lastResult[key] = Array.from(/* @__PURE__ */ new Set([...lastResult[key], ...value]));\n        }\n      } else {\n        lastResult[key] = value;\n      }\n    });\n  });\n  return [...result, lastResult];\n}\n\n// src/relay/subscription.ts\nvar NDKRelaySubscription = class {\n  fingerprint;\n  items = /* @__PURE__ */ new Map();\n  topSubManager;\n  debug;\n  /**\n   * Tracks the status of this REQ.\n   */\n  status = 0 /* INITIAL */;\n  onClose;\n  relay;\n  /**\n   * Whether this subscription has reached EOSE.\n   */\n  eosed = false;\n  /**\n   * Timeout at which this subscription will\n   * start executing.\n   */\n  executionTimer;\n  /**\n   * Track the time at which this subscription will fire.\n   */\n  fireTime;\n  /**\n   * The delay type that the current fireTime was calculated with.\n   */\n  delayType;\n  /**\n   * The filters that have been executed.\n   */\n  executeFilters;\n  id = Math.random().toString(36).substring(7);\n  /**\n   *\n   * @param fingerprint The fingerprint of this subscription.\n   */\n  constructor(relay, fingerprint, topSubManager) {\n    this.relay = relay;\n    this.topSubManager = topSubManager;\n    this.debug = relay.debug.extend(`sub[${this.id}]`);\n    this.fingerprint = fingerprint || Math.random().toString(36).substring(7);\n  }\n  _subId;\n  get subId() {\n    if (this._subId) return this._subId;\n    this._subId = this.fingerprint.slice(0, 15);\n    return this._subId;\n  }\n  subIdParts = /* @__PURE__ */ new Set();\n  addSubIdPart(part) {\n    this.subIdParts.add(part);\n  }\n  addItem(subscription, filters) {\n    this.debug(\"Adding item\", {\n      filters,\n      internalId: subscription.internalId,\n      status: this.status,\n      fingerprint: this.fingerprint,\n      id: this.subId,\n      items: this.items,\n      itemsSize: this.items.size\n    });\n    if (this.items.has(subscription.internalId)) return;\n    subscription.on(\"close\", this.removeItem.bind(this, subscription));\n    this.items.set(subscription.internalId, { subscription, filters });\n    if (this.status !== 3 /* RUNNING */) {\n      if (subscription.subId && (!this._subId || this._subId.length < 48)) {\n        if (this.status === 0 /* INITIAL */ || this.status === 1 /* PENDING */) {\n          this.addSubIdPart(subscription.subId);\n        }\n      }\n    }\n    switch (this.status) {\n      case 0 /* INITIAL */:\n        this.evaluateExecutionPlan(subscription);\n        break;\n      case 3 /* RUNNING */:\n        break;\n      case 1 /* PENDING */:\n        this.evaluateExecutionPlan(subscription);\n        break;\n      case 4 /* CLOSED */:\n        this.debug(\"Subscription is closed, cannot add new items %o (%o)\", subscription, filters);\n        throw new Error(\"Cannot add new items to a closed subscription\");\n    }\n  }\n  /**\n   * A subscription has been closed, remove it from the list of items.\n   * @param subscription\n   */\n  removeItem(subscription) {\n    this.items.delete(subscription.internalId);\n    if (this.items.size === 0) {\n      if (!this.eosed) return;\n      this.close();\n      this.cleanup();\n    }\n  }\n  close() {\n    if (this.status === 4 /* CLOSED */) return;\n    const prevStatus = this.status;\n    this.status = 4 /* CLOSED */;\n    if (prevStatus === 3 /* RUNNING */) {\n      try {\n        this.relay.close(this.subId);\n      } catch (e) {\n        this.debug(\"Error closing subscription\", e, this);\n      }\n    } else {\n      this.debug(\"Subscription wanted to close but it wasn't running, this is probably ok\", {\n        subId: this.subId,\n        prevStatus,\n        sub: this\n      });\n    }\n    this.cleanup();\n  }\n  cleanup() {\n    if (this.executionTimer) clearTimeout(this.executionTimer);\n    this.relay.off(\"ready\", this.executeOnRelayReady);\n    this.relay.off(\"authed\", this.reExecuteAfterAuth);\n    if (this.onClose) this.onClose(this);\n  }\n  evaluateExecutionPlan(subscription) {\n    if (!subscription.isGroupable()) {\n      this.status = 1 /* PENDING */;\n      this.execute();\n      return;\n    }\n    if (subscription.filters.find((filter) => !!filter.limit)) {\n      this.executeFilters = this.compileFilters();\n      if (this.executeFilters.length >= 10) {\n        this.status = 1 /* PENDING */;\n        this.execute();\n        return;\n      }\n    }\n    const delay = subscription.groupableDelay;\n    const delayType = subscription.groupableDelayType;\n    if (!delay) throw new Error(\"Cannot group a subscription without a delay\");\n    if (this.status === 0 /* INITIAL */) {\n      this.schedule(delay, delayType);\n    } else {\n      const existingDelayType = this.delayType;\n      const timeUntilFire = this.fireTime - Date.now();\n      if (existingDelayType === \"at-least\" && delayType === \"at-least\") {\n        if (timeUntilFire < delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-least\" && delayType === \"at-most\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-most\" && delayType === \"at-most\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-most\" && delayType === \"at-least\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else {\n        throw new Error(`Unknown delay type combination ${existingDelayType} ${delayType}`);\n      }\n    }\n  }\n  schedule(delay, delayType) {\n    this.status = 1 /* PENDING */;\n    const currentTime = Date.now();\n    this.fireTime = currentTime + delay;\n    this.delayType = delayType;\n    const timer = setTimeout(this.execute.bind(this), delay);\n    if (delayType === \"at-least\") {\n      this.executionTimer = timer;\n    }\n  }\n  executeOnRelayReady = () => {\n    if (this.status !== 2 /* WAITING */) return;\n    if (this.items.size === 0) {\n      this.debug(\"No items to execute; this relay was probably too slow to respond and the caller gave up\", {\n        status: this.status,\n        fingerprint: this.fingerprint,\n        items: this.items,\n        itemsSize: this.items.size,\n        id: this.id,\n        subId: this.subId\n      });\n      this.cleanup();\n      return;\n    }\n    this.debug(\"Executing on relay ready\", {\n      status: this.status,\n      fingerprint: this.fingerprint,\n      items: this.items,\n      itemsSize: this.items.size\n    });\n    this.status = 1 /* PENDING */;\n    this.execute();\n  };\n  finalizeSubId() {\n    if (this.subIdParts.size > 0) {\n      this._subId = Array.from(this.subIdParts).join(\"-\");\n    } else {\n      this._subId = this.fingerprint.slice(0, 15);\n    }\n    this._subId += `-${Math.random().toString(36).substring(2, 7)}`;\n  }\n  // we do it this way so that we can remove the listener\n  reExecuteAfterAuth = (() => {\n    const oldSubId = this.subId;\n    this.debug(\"Re-executing after auth\", this.items.size);\n    if (this.eosed) {\n      this.relay.close(this.subId);\n    } else {\n      this.debug(\"We are abandoning an opened subscription, once it EOSE's, the handler will close it\", {\n        oldSubId\n      });\n    }\n    this._subId = void 0;\n    this.status = 1 /* PENDING */;\n    this.execute();\n    this.debug(\"Re-executed after auth %s \\u{1F449} %s\", oldSubId, this.subId);\n  }).bind(this);\n  execute() {\n    if (this.status !== 1 /* PENDING */) {\n      return;\n    }\n    if (!this.relay.connected) {\n      this.status = 2 /* WAITING */;\n      this.debug(\"Waiting for relay to be ready\", {\n        status: this.status,\n        id: this.subId,\n        fingerprint: this.fingerprint,\n        items: this.items,\n        itemsSize: this.items.size\n      });\n      this.relay.once(\"ready\", this.executeOnRelayReady);\n      return;\n    }\n    if (this.relay.status < 8 /* AUTHENTICATED */) {\n      this.relay.once(\"authed\", this.reExecuteAfterAuth);\n    }\n    this.status = 3 /* RUNNING */;\n    this.finalizeSubId();\n    this.executeFilters = this.compileFilters();\n    this.relay.req(this);\n  }\n  onstart() {\n  }\n  onevent(event) {\n    this.topSubManager.dispatchEvent(event, this.relay);\n  }\n  oneose(subId) {\n    this.eosed = true;\n    if (subId !== this.subId) {\n      this.debug(\"Received EOSE for an abandoned subscription\", subId, this.subId);\n      this.relay.close(subId);\n      return;\n    }\n    if (this.items.size === 0) {\n      this.close();\n    }\n    for (const { subscription } of this.items.values()) {\n      subscription.eoseReceived(this.relay);\n      if (subscription.closeOnEose) {\n        this.debug(\"Removing item because of EOSE\", {\n          filters: subscription.filters,\n          internalId: subscription.internalId,\n          status: this.status,\n          fingerprint: this.fingerprint,\n          items: this.items,\n          itemsSize: this.items.size\n        });\n        this.removeItem(subscription);\n      }\n    }\n  }\n  onclose(_reason) {\n    this.status = 4 /* CLOSED */;\n  }\n  onclosed(reason) {\n    if (!reason) return;\n    for (const { subscription } of this.items.values()) {\n      subscription.closedReceived(this.relay, reason);\n    }\n  }\n  /**\n   * Grabs the filters from all the subscriptions\n   * and merges them into a single filter.\n   */\n  compileFilters() {\n    const mergedFilters = [];\n    const filters = Array.from(this.items.values()).map((item) => item.filters);\n    if (!filters[0]) {\n      this.debug(\"\\u{1F440} No filters to merge\", this.items);\n      console.error(\"BUG: No filters to merge!\", this.items);\n      return [];\n    }\n    const filterCount = filters[0].length;\n    for (let i = 0; i < filterCount; i++) {\n      const allFiltersAtIndex = filters.map((filter) => filter[i]);\n      mergedFilters.push(...mergeFilters(allFiltersAtIndex));\n    }\n    return mergedFilters;\n  }\n};\n\n// src/relay/sub-manager.ts\nvar NDKRelaySubscriptionManager = class {\n  relay;\n  subscriptions;\n  generalSubManager;\n  /**\n   * @param relay - The relay instance.\n   * @param generalSubManager - The subscription manager instance.\n   */\n  constructor(relay, generalSubManager) {\n    this.relay = relay;\n    this.subscriptions = /* @__PURE__ */ new Map();\n    this.generalSubManager = generalSubManager;\n  }\n  /**\n   * Adds a subscription to the manager.\n   */\n  addSubscription(sub, filters) {\n    let relaySub;\n    if (!sub.isGroupable()) {\n      relaySub = this.createSubscription(sub, filters);\n    } else {\n      const filterFp = filterFingerprint(filters, sub.closeOnEose);\n      if (filterFp) {\n        const existingSubs = this.subscriptions.get(filterFp);\n        relaySub = (existingSubs || []).find((sub2) => sub2.status < 3 /* RUNNING */);\n      }\n      relaySub ??= this.createSubscription(sub, filters, filterFp);\n    }\n    relaySub.addItem(sub, filters);\n  }\n  createSubscription(_sub, _filters, fingerprint) {\n    const relaySub = new NDKRelaySubscription(this.relay, fingerprint || null, this.generalSubManager);\n    relaySub.onClose = this.onRelaySubscriptionClose.bind(this);\n    const currentVal = this.subscriptions.get(relaySub.fingerprint) ?? [];\n    this.subscriptions.set(relaySub.fingerprint, [...currentVal, relaySub]);\n    return relaySub;\n  }\n  onRelaySubscriptionClose(sub) {\n    let currentVal = this.subscriptions.get(sub.fingerprint) ?? [];\n    if (!currentVal) {\n      console.warn(\"Unexpectedly did not find a subscription with fingerprint\", sub.fingerprint);\n    } else if (currentVal.length === 1) {\n      this.subscriptions.delete(sub.fingerprint);\n    } else {\n      currentVal = currentVal.filter((s) => s.id !== sub.id);\n      this.subscriptions.set(sub.fingerprint, currentVal);\n    }\n  }\n};\n\n// src/relay/index.ts\nvar NDKRelayStatus = /* @__PURE__ */ ((NDKRelayStatus2) => {\n  NDKRelayStatus2[NDKRelayStatus2[\"DISCONNECTING\"] = 0] = \"DISCONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"DISCONNECTED\"] = 1] = \"DISCONNECTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"FLAPPING\"] = 3] = \"FLAPPING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"CONNECTING\"] = 4] = \"CONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"CONNECTED\"] = 5] = \"CONNECTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTH_REQUESTED\"] = 6] = \"AUTH_REQUESTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTHENTICATING\"] = 7] = \"AUTHENTICATING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTHENTICATED\"] = 8] = \"AUTHENTICATED\";\n  return NDKRelayStatus2;\n})(NDKRelayStatus || {});\nvar NDKRelay = class _NDKRelay extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  url;\n  scores;\n  connectivity;\n  subs;\n  publisher;\n  authPolicy;\n  /**\n   * The lowest validation ratio this relay can reach.\n   */\n  lowestValidationRatio;\n  /**\n   * Current validation ratio this relay is targeting.\n   */\n  targetValidationRatio;\n  validationRatioFn;\n  /**\n   * This tracks events that have been seen by this relay\n   * with a valid signature.\n   */\n  validatedEventCount = 0;\n  /**\n   * This tracks events that have been seen by this relay\n   * but have not been validated.\n   */\n  nonValidatedEventCount = 0;\n  /**\n   * Whether this relay is trusted.\n   *\n   * Trusted relay's events do not get their signature verified.\n   */\n  trusted = false;\n  complaining = false;\n  debug;\n  static defaultValidationRatioUpdateFn = (relay, validatedCount, _nonValidatedCount) => {\n    if (relay.lowestValidationRatio === void 0 || relay.targetValidationRatio === void 0) return 1;\n    let newRatio = relay.validationRatio;\n    if (relay.validationRatio > relay.targetValidationRatio) {\n      const factor = validatedCount / 100;\n      newRatio = Math.max(relay.lowestValidationRatio, relay.validationRatio - factor);\n    }\n    if (newRatio < relay.validationRatio) {\n      return newRatio;\n    }\n    return relay.validationRatio;\n  };\n  constructor(url, authPolicy, ndk) {\n    super();\n    this.url = normalizeRelayUrl(url);\n    this.scores = /* @__PURE__ */ new Map();\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(`ndk:relay:${url}`);\n    this.connectivity = new NDKRelayConnectivity(this, ndk);\n    this.connectivity.netDebug = ndk?.netDebug;\n    this.req = this.connectivity.req.bind(this.connectivity);\n    this.close = this.connectivity.close.bind(this.connectivity);\n    this.subs = new NDKRelaySubscriptionManager(this, ndk.subManager);\n    this.publisher = new NDKRelayPublisher(this);\n    this.authPolicy = authPolicy;\n    this.targetValidationRatio = ndk?.initialValidationRatio;\n    this.lowestValidationRatio = ndk?.lowestValidationRatio;\n    this.validationRatioFn = (ndk?.validationRatioFn ?? _NDKRelay.defaultValidationRatioUpdateFn).bind(this);\n    this.updateValidationRatio();\n    if (!ndk) {\n      console.trace(\"relay created without ndk\");\n    }\n  }\n  updateValidationRatio() {\n    setTimeout(() => {\n      this.updateValidationRatio();\n    }, 3e4);\n  }\n  get status() {\n    return this.connectivity.status;\n  }\n  get connectionStats() {\n    return this.connectivity.connectionStats;\n  }\n  /**\n   * Connects to the relay.\n   */\n  async connect(timeoutMs, reconnect = true) {\n    return this.connectivity.connect(timeoutMs, reconnect);\n  }\n  /**\n   * Disconnects from the relay.\n   */\n  disconnect() {\n    if (this.status === 1 /* DISCONNECTED */) {\n      return;\n    }\n    this.connectivity.disconnect();\n  }\n  /**\n   * Queues or executes the subscription of a specific set of filters\n   * within this relay.\n   *\n   * @param subscription NDKSubscription this filters belong to.\n   * @param filters Filters to execute\n   */\n  subscribe(subscription, filters) {\n    this.subs.addSubscription(subscription, filters);\n  }\n  /**\n   * Publishes an event to the relay with an optional timeout.\n   *\n   * If the relay is not connected, the event will be published when the relay connects,\n   * unless the timeout is reached before the relay connects.\n   *\n   * @param event The event to publish\n   * @param timeoutMs The timeout for the publish operation in milliseconds\n   * @returns A promise that resolves when the event has been published or rejects if the operation times out\n   */\n  async publish(event, timeoutMs = 2500) {\n    return this.publisher.publish(event, timeoutMs);\n  }\n  referenceTags() {\n    return [[\"r\", this.url]];\n  }\n  addValidatedEvent() {\n    this.validatedEventCount++;\n  }\n  addNonValidatedEvent() {\n    this.nonValidatedEventCount++;\n  }\n  /**\n   * The current validation ratio this relay has achieved.\n   */\n  get validationRatio() {\n    if (this.nonValidatedEventCount === 0) {\n      return 1;\n    }\n    return this.validatedEventCount / (this.validatedEventCount + this.nonValidatedEventCount);\n  }\n  shouldValidateEvent() {\n    if (this.trusted) {\n      return false;\n    }\n    if (this.targetValidationRatio === void 0) {\n      return true;\n    }\n    return this.validationRatio < this.targetValidationRatio;\n  }\n  get connected() {\n    return this.connectivity.connected;\n  }\n  req;\n  close;\n};\n\n// src/relay/sets/index.ts\nvar NDKPublishError = class extends Error {\n  errors;\n  publishedToRelays;\n  /**\n   * Intended relay set where the publishing was intended to happen.\n   */\n  intendedRelaySet;\n  constructor(message, errors, publishedToRelays, intendedRelaySet) {\n    super(message);\n    this.errors = errors;\n    this.publishedToRelays = publishedToRelays;\n    this.intendedRelaySet = intendedRelaySet;\n  }\n  get relayErrors() {\n    const errors = [];\n    for (const [relay, err] of this.errors) {\n      errors.push(`${relay.url}: ${err}`);\n    }\n    return errors.join(\"\\n\");\n  }\n};\nvar NDKRelaySet = class _NDKRelaySet {\n  relays;\n  debug;\n  ndk;\n  pool;\n  constructor(relays, ndk, pool) {\n    this.relays = relays;\n    this.ndk = ndk;\n    this.pool = pool ?? ndk.pool;\n    this.debug = ndk.debug.extend(\"relayset\");\n  }\n  /**\n   * Adds a relay to this set.\n   */\n  addRelay(relay) {\n    this.relays.add(relay);\n  }\n  get relayUrls() {\n    return Array.from(this.relays).map((r) => r.url);\n  }\n  /**\n   * Creates a relay set from a list of relay URLs.\n   *\n   * If no connection to the relay is found in the pool it will temporarily\n   * connect to it.\n   *\n   * @param relayUrls - list of relay URLs to include in this set\n   * @param ndk\n   * @param connect - whether to connect to the relay immediately if it was already in the pool but not connected\n   * @returns NDKRelaySet\n   */\n  static fromRelayUrls(relayUrls, ndk, connect = true, pool) {\n    pool = pool ?? ndk.pool;\n    if (!pool) throw new Error(\"No pool provided\");\n    const relays = /* @__PURE__ */ new Set();\n    for (const url of relayUrls) {\n      const relay = pool.relays.get(normalizeRelayUrl(url));\n      if (relay) {\n        if (relay.status < 5 /* CONNECTED */ && connect) {\n          relay.connect();\n        }\n        relays.add(relay);\n      } else {\n        const temporaryRelay = new NDKRelay(normalizeRelayUrl(url), ndk?.relayAuthDefaultPolicy, ndk);\n        pool.useTemporaryRelay(temporaryRelay, void 0, `requested from fromRelayUrls ${relayUrls}`);\n        relays.add(temporaryRelay);\n      }\n    }\n    return new _NDKRelaySet(new Set(relays), ndk, pool);\n  }\n  /**\n   * Publish an event to all relays in this relay set.\n   *\n   * This method implements a robust mechanism for publishing events to multiple relays with\n   * built-in handling for race conditions, timeouts, and partial failures. The implementation\n   * uses a dual-tracking mechanism to ensure accurate reporting of which relays successfully\n   * received an event.\n   *\n   * Key aspects of this implementation:\n   *\n   * 1. DUAL-TRACKING MECHANISM:\n   *    - Promise-based tracking: Records successes/failures from the promises returned by relay.publish()\n   *    - Event-based tracking: Listens for 'relay:published' events that indicate successful publishing\n   *    This approach ensures we don't miss successful publishes even if there are subsequent errors in\n   *    the promise chain.\n   *\n   * 2. RACE CONDITION HANDLING:\n   *    - If a relay emits a success event but later fails in the promise chain, we still count it as a success\n   *    - If a relay times out after successfully publishing, we still count it as a success\n   *    - All relay operations happen in parallel, with proper tracking regardless of completion order\n   *\n   * 3. TIMEOUT MANAGEMENT:\n   *    - Individual timeouts for each relay operation\n   *    - Proper cleanup of timeouts to prevent memory leaks\n   *    - Clear timeout error reporting\n   *\n   * 4. ERROR HANDLING:\n   *    - Detailed tracking of specific errors for each failed relay\n   *    - Special handling for ephemeral events (which don't expect acknowledgement)\n   *    - RequiredRelayCount parameter to control the minimum success threshold\n   *\n   * @param event Event to publish\n   * @param timeoutMs Timeout in milliseconds for each relay publish operation\n   * @param requiredRelayCount The minimum number of relays we expect the event to be published to\n   * @returns A set of relays the event was published to\n   * @throws {NDKPublishError} If the event could not be published to at least `requiredRelayCount` relays\n   * @example\n   * ```typescript\n   * const relaySet = new NDKRelaySet(new Set([relay1, relay2]), ndk);\n   * const publishedToRelays = await relaySet.publish(event);\n   * // publishedToRelays can contain relay1, relay2, both, or none\n   * // depending on which relays the event was successfully published to\n   * if (publishedToRelays.size > 0) {\n   *   console.log(\"Event published to at least one relay\");\n   * }\n   * ```\n   */\n  async publish(event, timeoutMs, requiredRelayCount = 1) {\n    const publishedToRelays = /* @__PURE__ */ new Set();\n    const errors = /* @__PURE__ */ new Map();\n    const isEphemeral2 = event.isEphemeral();\n    event.publishStatus = \"pending\";\n    const relayPublishedHandler = (relay) => {\n      publishedToRelays.add(relay);\n    };\n    event.on(\"relay:published\", relayPublishedHandler);\n    try {\n      const promises = Array.from(this.relays).map((relay) => {\n        return new Promise((resolve) => {\n          const timeoutId = timeoutMs ? setTimeout(() => {\n            if (!publishedToRelays.has(relay)) {\n              errors.set(relay, new Error(`Publish timeout after ${timeoutMs}ms`));\n              resolve(false);\n            }\n          }, timeoutMs) : null;\n          relay.publish(event, timeoutMs).then((success) => {\n            if (timeoutId) clearTimeout(timeoutId);\n            if (success) {\n              publishedToRelays.add(relay);\n              resolve(true);\n            } else {\n              resolve(false);\n            }\n          }).catch((err) => {\n            if (timeoutId) clearTimeout(timeoutId);\n            if (!isEphemeral2) {\n              errors.set(relay, err);\n            }\n            resolve(false);\n          });\n        });\n      });\n      await Promise.all(promises);\n      if (publishedToRelays.size < requiredRelayCount) {\n        if (!isEphemeral2) {\n          const error = new NDKPublishError(\n            \"Not enough relays received the event\",\n            errors,\n            publishedToRelays,\n            this\n          );\n          event.publishStatus = \"error\";\n          event.publishError = error;\n          this.ndk?.emit(\"event:publish-failed\", event, error, this.relayUrls);\n          throw error;\n        }\n      } else {\n        event.publishStatus = \"success\";\n        event.emit(\"published\", { relaySet: this, publishedToRelays });\n      }\n      return publishedToRelays;\n    } finally {\n      event.off(\"relay:published\", relayPublishedHandler);\n    }\n  }\n  get size() {\n    return this.relays.size;\n  }\n};\n\n// src/relay/sets/calculate.ts\nvar d = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:outbox:calculate\");\nasync function calculateRelaySetFromEvent(ndk, event) {\n  const relays = /* @__PURE__ */ new Set();\n  const authorWriteRelays = await getWriteRelaysFor(ndk, event.pubkey);\n  if (authorWriteRelays) {\n    authorWriteRelays.forEach((relayUrl) => {\n      const relay = ndk.pool?.getRelay(relayUrl);\n      if (relay) relays.add(relay);\n    });\n  }\n  let relayHints = event.tags.filter((tag) => [\"a\", \"e\"].includes(tag[0])).map((tag) => tag[2]).filter((url) => url?.startsWith(\"wss://\")).filter((url) => {\n    try {\n      new URL(url);\n      return true;\n    } catch {\n      return false;\n    }\n  }).map((url) => normalizeRelayUrl(url));\n  relayHints = Array.from(new Set(relayHints)).slice(0, 5);\n  relayHints.forEach((relayUrl) => {\n    const relay = ndk.pool?.getRelay(relayUrl, true, true);\n    if (relay) {\n      d(\"Adding relay hint %s\", relayUrl);\n      relays.add(relay);\n    }\n  });\n  const pTags = event.getMatchingTags(\"p\").map((tag) => tag[1]);\n  if (pTags.length < 5) {\n    const pTaggedRelays = Array.from(\n      chooseRelayCombinationForPubkeys(ndk, pTags, \"read\", {\n        preferredRelays: new Set(authorWriteRelays)\n      }).keys()\n    );\n    pTaggedRelays.forEach((relayUrl) => {\n      const relay = ndk.pool?.getRelay(relayUrl, false, true);\n      if (relay) {\n        d(\"Adding p-tagged relay %s\", relayUrl);\n        relays.add(relay);\n      }\n    });\n  } else {\n    d(\"Too many p-tags to consider %d\", pTags.length);\n  }\n  ndk.pool?.permanentAndConnectedRelays().forEach((relay) => relays.add(relay));\n  return new NDKRelaySet(relays, ndk);\n}\nfunction calculateRelaySetsFromFilter(ndk, filters, pool) {\n  const result = /* @__PURE__ */ new Map();\n  const authors = /* @__PURE__ */ new Set();\n  filters.forEach((filter) => {\n    if (filter.authors) {\n      filter.authors.forEach((author) => authors.add(author));\n    }\n  });\n  if (authors.size > 0) {\n    const authorToRelaysMap = getRelaysForFilterWithAuthors(ndk, Array.from(authors));\n    for (const relayUrl of authorToRelaysMap.keys()) {\n      result.set(relayUrl, []);\n    }\n    for (const filter of filters) {\n      if (filter.authors) {\n        for (const [relayUrl, authors2] of authorToRelaysMap.entries()) {\n          const authorFilterAndRelayPubkeyIntersection = filter.authors.filter(\n            (author) => authors2.includes(author)\n          );\n          result.set(relayUrl, [\n            ...result.get(relayUrl),\n            {\n              ...filter,\n              // Overwrite authors sent to this relay with the authors that were\n              // present in the filter and are also present in the relay\n              authors: authorFilterAndRelayPubkeyIntersection\n            }\n          ]);\n        }\n      } else {\n        for (const relayUrl of authorToRelaysMap.keys()) {\n          result.set(relayUrl, [...result.get(relayUrl), filter]);\n        }\n      }\n    }\n  } else {\n    if (ndk.explicitRelayUrls) {\n      ndk.explicitRelayUrls.forEach((relayUrl) => {\n        result.set(relayUrl, filters);\n      });\n    }\n  }\n  if (result.size === 0) {\n    pool.permanentAndConnectedRelays().slice(0, 5).forEach((relay) => {\n      result.set(relay.url, filters);\n    });\n  }\n  return result;\n}\nfunction calculateRelaySetsFromFilters(ndk, filters, pool) {\n  const a = calculateRelaySetsFromFilter(ndk, filters, pool);\n  return a;\n}\n\n// src/events/content-tagger.ts\n\nfunction mergeTags(tags1, tags2) {\n  const tagMap = /* @__PURE__ */ new Map();\n  const generateKey = (tag) => tag.join(\",\");\n  const isContained = (smaller, larger) => {\n    return smaller.every((value, index) => value === larger[index]);\n  };\n  const processTag = (tag) => {\n    for (const [key, existingTag] of tagMap) {\n      if (isContained(existingTag, tag) || isContained(tag, existingTag)) {\n        if (tag.length >= existingTag.length) {\n          tagMap.set(key, tag);\n        }\n        return;\n      }\n    }\n    tagMap.set(generateKey(tag), tag);\n  };\n  tags1.concat(tags2).forEach(processTag);\n  return Array.from(tagMap.values());\n}\nfunction uniqueTag(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  const sameLength = aLength === bLength;\n  if (sameLength) {\n    if (a.every((v, i) => v === b[i])) {\n      return [a];\n    }\n    return [a, b];\n  }\n  if (aLength > bLength && a.every((v, i) => v === b[i])) {\n    return [a];\n  }\n  if (bLength > aLength && b.every((v, i) => v === a[i])) {\n    return [b];\n  }\n  return [a, b];\n}\nvar hashtagRegex = /(?<=\\s|^)(#[^\\s!@#$%^&*()=+./,[{\\]};:'\"?><]+)/g;\nfunction generateHashtags(content) {\n  const hashtags = content.match(hashtagRegex);\n  const tagIds = /* @__PURE__ */ new Set();\n  const tag = /* @__PURE__ */ new Set();\n  if (hashtags) {\n    for (const hashtag of hashtags) {\n      if (tagIds.has(hashtag.slice(1))) continue;\n      tag.add(hashtag.slice(1));\n      tagIds.add(hashtag.slice(1));\n    }\n  }\n  return Array.from(tag);\n}\nasync function generateContentTags(content, tags = []) {\n  const tagRegex = /(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g;\n  const promises = [];\n  const addTagIfNew = (t) => {\n    if (!tags.find((t2) => [\"q\", t[0]].includes(t2[0]) && t2[1] === t[1])) {\n      tags.push(t);\n    }\n  };\n  content = content.replace(tagRegex, (tag) => {\n    try {\n      const entity = tag.split(/(@|nostr:)/)[2];\n      const { type, data } = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(entity);\n      let t;\n      switch (type) {\n        case \"npub\":\n          t = [\"p\", data];\n          break;\n        case \"nprofile\":\n          t = [\"p\", data.pubkey];\n          break;\n        case \"note\":\n          promises.push(\n            new Promise(async (resolve) => {\n              addTagIfNew([\"q\", data, await maybeGetEventRelayUrl(entity)]);\n              resolve();\n            })\n          );\n          break;\n        case \"nevent\":\n          promises.push(\n            new Promise(async (resolve) => {\n              const { id, author } = data;\n              let { relays } = data;\n              if (!relays || relays.length === 0) {\n                relays = [await maybeGetEventRelayUrl(entity)];\n              }\n              addTagIfNew([\"q\", id, relays[0]]);\n              if (author) addTagIfNew([\"p\", author]);\n              resolve();\n            })\n          );\n          break;\n        case \"naddr\":\n          promises.push(\n            new Promise(async (resolve) => {\n              const id = [data.kind, data.pubkey, data.identifier].join(\":\");\n              let relays = data.relays ?? [];\n              if (relays.length === 0) {\n                relays = [await maybeGetEventRelayUrl(entity)];\n              }\n              addTagIfNew([\"q\", id, relays[0]]);\n              addTagIfNew([\"p\", data.pubkey]);\n              resolve();\n            })\n          );\n          break;\n        default:\n          return tag;\n      }\n      if (t) addTagIfNew(t);\n      return `nostr:${entity}`;\n    } catch (_error) {\n      return tag;\n    }\n  });\n  await Promise.all(promises);\n  const newTags = generateHashtags(content).map((hashtag) => [\"t\", hashtag]);\n  tags = mergeTags(tags, newTags);\n  return { content, tags };\n}\nasync function maybeGetEventRelayUrl(_nip19Id) {\n  return \"\";\n}\n\n// src/events/encryption.ts\nasync function encrypt(recipient, signer, scheme = \"nip44\") {\n  let encrypted;\n  if (!this.ndk) throw new Error(\"No NDK instance found!\");\n  let currentSigner = signer;\n  if (!currentSigner) {\n    this.ndk.assertSigner();\n    currentSigner = this.ndk.signer;\n  }\n  if (!currentSigner) throw new Error(\"no NDK signer\");\n  const currentRecipient = recipient || (() => {\n    const pTags = this.getMatchingTags(\"p\");\n    if (pTags.length !== 1) {\n      throw new Error(\"No recipient could be determined and no explicit recipient was provided\");\n    }\n    return this.ndk.getUser({ pubkey: pTags[0][1] });\n  })();\n  if (scheme === \"nip44\" && await isEncryptionEnabled(currentSigner, \"nip44\")) {\n    encrypted = await currentSigner.encrypt(currentRecipient, this.content, \"nip44\");\n  }\n  if ((!encrypted || scheme === \"nip04\") && await isEncryptionEnabled(currentSigner, \"nip04\")) {\n    encrypted = await currentSigner.encrypt(currentRecipient, this.content, \"nip04\");\n  }\n  if (!encrypted) throw new Error(\"Failed to encrypt event.\");\n  this.content = encrypted;\n}\nasync function decrypt(sender, signer, scheme) {\n  if (this.ndk?.cacheAdapter?.getDecryptedEvent) {\n    let cachedEvent = null;\n    if (typeof this.ndk.cacheAdapter.getDecryptedEvent === \"function\") {\n      cachedEvent = this.ndk.cacheAdapter.getDecryptedEvent(this.id);\n    }\n    if (cachedEvent) {\n      this.content = cachedEvent.content;\n      return;\n    }\n  }\n  let decrypted;\n  if (!this.ndk) throw new Error(\"No NDK instance found!\");\n  let currentSigner = signer;\n  if (!currentSigner) {\n    this.ndk.assertSigner();\n    currentSigner = this.ndk.signer;\n  }\n  if (!currentSigner) throw new Error(\"no NDK signer\");\n  const currentSender = sender || this.author;\n  if (!currentSender) throw new Error(\"No sender provided and no author available\");\n  const currentScheme = scheme || (this.content.match(/\\\\?iv=/) ? \"nip04\" : \"nip44\");\n  if ((currentScheme === \"nip04\" || this.kind === 4) && await isEncryptionEnabled(currentSigner, \"nip04\") && this.content.search(\"\\\\?iv=\")) {\n    decrypted = await currentSigner.decrypt(currentSender, this.content, \"nip04\");\n  }\n  if (!decrypted && currentScheme === \"nip44\" && await isEncryptionEnabled(currentSigner, \"nip44\")) {\n    decrypted = await currentSigner.decrypt(currentSender, this.content, \"nip44\");\n  }\n  if (!decrypted) throw new Error(\"Failed to decrypt event.\");\n  this.content = decrypted;\n  if (this.ndk?.cacheAdapter?.addDecryptedEvent) {\n    this.ndk.cacheAdapter.addDecryptedEvent(this);\n  }\n}\nasync function isEncryptionEnabled(signer, scheme) {\n  if (!signer.encryptionEnabled) return false;\n  if (!scheme) return true;\n  return Boolean(await signer.encryptionEnabled(scheme));\n}\n\n// src/thread/index.ts\nfunction eventsBySameAuthor(op, events) {\n  const eventsByAuthor = /* @__PURE__ */ new Map();\n  eventsByAuthor.set(op.id, op);\n  events.forEach((event) => {\n    if (event.pubkey === op.pubkey) {\n      eventsByAuthor.set(event.id, event);\n    }\n  });\n  return eventsByAuthor;\n}\nvar hasMarkers = (event, tagType) => {\n  return event.getMatchingTags(tagType).some((tag) => tag[3] && tag[3] !== \"\");\n};\nfunction eventIsReply(op, event, threadIds = /* @__PURE__ */ new Set(), tagType) {\n  tagType ??= op.tagType();\n  const tags = event.getMatchingTags(tagType);\n  threadIds.add(op.tagId());\n  if (threadIds.has(event.tagId())) return false;\n  const heedExplicitReplyMarker = () => {\n    let eventIsTagged = false;\n    for (const tag of tags) {\n      if (tag[3] === \"reply\") return threadIds.has(tag[1]);\n      const markerIsEmpty = tag[3] === \"\" || tag[3] === void 0;\n      const markerIsRoot = tag[3] === \"root\";\n      if (tag[1] === op.tagId() && (markerIsEmpty || markerIsRoot)) {\n        eventIsTagged = markerIsRoot ? \"root\" : true;\n      }\n    }\n    if (!eventIsTagged) return false;\n    if (eventIsTagged === \"root\") return true;\n  };\n  const explicitReplyMarker = heedExplicitReplyMarker();\n  if (explicitReplyMarker !== void 0) return explicitReplyMarker;\n  if (hasMarkers(event, tagType)) return false;\n  const expectedTags = op.getMatchingTags(\"e\").map((tag) => tag[1]);\n  expectedTags.push(op.id);\n  return event.getMatchingTags(\"e\").every((tag) => expectedTags.includes(tag[1]));\n}\nfunction eventThreads(op, events) {\n  const eventsByAuthor = eventsBySameAuthor(op, events);\n  const threadEvents = events.filter((event) => eventIsPartOfThread(op, event, eventsByAuthor));\n  return threadEvents.sort((a, b) => a.created_at - b.created_at);\n}\nfunction getEventReplyId(event) {\n  const replyTag = getReplyTag(event);\n  if (replyTag) return replyTag[1];\n  const rootTag = getRootTag(event);\n  if (rootTag) return rootTag[1];\n}\nfunction isEventOriginalPost(event) {\n  return getEventReplyId(event) === void 0;\n}\nfunction eventThreadIds(op, events) {\n  const threadIds = /* @__PURE__ */ new Map();\n  const threadEvents = eventThreads(op, events);\n  threadEvents.forEach((event) => threadIds.set(event.id, event));\n  return threadIds;\n}\nfunction eventReplies(op, events, threadEventIds) {\n  threadEventIds ??= new Set(eventThreadIds(op, events).keys());\n  return events.filter((event) => eventIsReply(op, event, threadEventIds));\n}\nfunction eventIsPartOfThread(op, event, eventsByAuthor) {\n  if (op.pubkey !== event.pubkey) return false;\n  const taggedEventIds = event.getMatchingTags(\"e\").map((tag) => tag[1]);\n  const allTaggedEventsAreByOriginalAuthor = taggedEventIds.every((id) => eventsByAuthor.has(id));\n  return allTaggedEventsAreByOriginalAuthor;\n}\nfunction eventHasETagMarkers(event) {\n  for (const tag of event.tags) {\n    if (tag[0] === \"e\" && (tag[3] ?? \"\").length > 0) return true;\n  }\n  return false;\n}\nfunction getRootEventId(event, searchTag) {\n  searchTag ??= event.tagType();\n  const rootEventTag = getRootTag(event, searchTag);\n  if (rootEventTag) return rootEventTag[1];\n  const replyTag = getReplyTag(event, searchTag);\n  return replyTag?.[1];\n}\nfunction getRootTag(event, searchTag) {\n  searchTag ??= event.tagType();\n  const rootEventTag = event.tags.find(isTagRootTag);\n  if (!rootEventTag) {\n    if (eventHasETagMarkers(event)) return;\n    const matchingTags = event.getMatchingTags(searchTag);\n    if (matchingTags.length < 3) return matchingTags[0];\n  }\n  return rootEventTag;\n}\nvar nip22RootTags = /* @__PURE__ */ new Set([\"A\", \"E\", \"I\"]);\nvar nip22ReplyTags = /* @__PURE__ */ new Set([\"a\", \"e\", \"i\"]);\nfunction getReplyTag(event, searchTag) {\n  if (event.kind === 1111 /* GenericReply */) {\n    let replyTag2;\n    for (const tag of event.tags) {\n      if (nip22RootTags.has(tag[0])) replyTag2 = tag;\n      else if (nip22ReplyTags.has(tag[0])) {\n        replyTag2 = tag;\n        break;\n      }\n    }\n    return replyTag2;\n  }\n  searchTag ??= event.tagType();\n  let hasMarkers2 = false;\n  let replyTag;\n  for (const tag of event.tags) {\n    if (tag[0] !== searchTag) continue;\n    if ((tag[3] ?? \"\").length > 0) hasMarkers2 = true;\n    if (hasMarkers2 && tag[3] === \"reply\") return tag;\n    if (hasMarkers2 && tag[3] === \"root\") replyTag = tag;\n    if (!hasMarkers2) replyTag = tag;\n  }\n  return replyTag;\n}\nfunction isTagRootTag(tag) {\n  return tag[0] === \"E\" || tag[3] === \"root\";\n}\n\n// src/events/fetch-tagged-event.ts\nasync function fetchTaggedEvent(tag, marker) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const t = this.getMatchingTags(tag, marker);\n  if (t.length === 0) return void 0;\n  const [_, id, hint] = t[0];\n  let relay = hint !== \"\" ? this.ndk.pool.getRelay(hint) : void 0;\n  const event = await this.ndk.fetchEvent(id, {}, relay);\n  return event;\n}\nasync function fetchRootEvent(subOpts) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const rootTag = getRootTag(this);\n  if (!rootTag) return void 0;\n  return this.ndk.fetchEventFromTag(rootTag, this, subOpts);\n}\nasync function fetchReplyEvent(subOpts) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const replyTag = getReplyTag(this);\n  if (!replyTag) return void 0;\n  return this.ndk.fetchEventFromTag(replyTag, this, subOpts);\n}\n\n// src/events/kind.ts\nfunction isReplaceable() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return [0, 3].includes(this.kind) || this.kind >= 1e4 && this.kind < 2e4 || this.kind >= 3e4 && this.kind < 4e4;\n}\nfunction isEphemeral() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return this.kind >= 2e4 && this.kind < 3e4;\n}\nfunction isParamReplaceable() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return this.kind >= 3e4 && this.kind < 4e4;\n}\n\n// src/events/nip19.ts\n\nvar DEFAULT_RELAY_COUNT = 2;\nfunction encode(maxRelayCount = DEFAULT_RELAY_COUNT) {\n  let relays = [];\n  if (this.onRelays.length > 0) {\n    relays = this.onRelays.map((relay) => relay.url);\n  } else if (this.relay) {\n    relays = [this.relay.url];\n  }\n  if (relays.length > maxRelayCount) {\n    relays = relays.slice(0, maxRelayCount);\n  }\n  if (this.isParamReplaceable()) {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.naddrEncode({\n      kind: this.kind,\n      pubkey: this.pubkey,\n      identifier: this.replaceableDTag(),\n      relays\n    });\n  }\n  if (relays.length > 0) {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.neventEncode({\n      id: this.tagId(),\n      relays,\n      author: this.pubkey\n    });\n  }\n  return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.noteEncode(this.tagId());\n}\n\n// src/events/repost.ts\nasync function repost(publish = true, signer) {\n  if (!signer && publish) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    signer = this.ndk.signer;\n  }\n  const e = new NDKEvent(this.ndk, {\n    kind: getKind(this)\n  });\n  if (!this.isProtected) e.content = JSON.stringify(this.rawEvent());\n  e.tag(this);\n  if (this.kind !== 1 /* Text */) {\n    e.tags.push([\"k\", `${this.kind}`]);\n  }\n  if (signer) await e.sign(signer);\n  if (publish) await e.publish();\n  return e;\n}\nfunction getKind(event) {\n  if (event.kind === 1) {\n    return 6 /* Repost */;\n  }\n  return 16 /* GenericRepost */;\n}\n\n// src/events/serializer.ts\nfunction serialize(includeSig = false, includeId = false) {\n  const payload = [0, this.pubkey, this.created_at, this.kind, this.tags, this.content];\n  if (includeSig) payload.push(this.sig);\n  if (includeId) payload.push(this.id);\n  return JSON.stringify(payload);\n}\nfunction deserialize(serializedEvent) {\n  const eventArray = JSON.parse(serializedEvent);\n  const ret = {\n    pubkey: eventArray[1],\n    created_at: eventArray[2],\n    kind: eventArray[3],\n    tags: eventArray[4],\n    content: eventArray[5]\n  };\n  if (eventArray.length >= 7) ret.sig = eventArray[6];\n  if (eventArray.length >= 8) ret.id = eventArray[7];\n  return ret;\n}\n\n// src/events/validation.ts\n\n\n\n\n\n// src/events/signature.ts\nvar worker;\nvar processingQueue = {};\nfunction signatureVerificationInit(w) {\n  worker = w;\n  worker.onmessage = (msg) => {\n    const [eventId, result] = msg.data;\n    const record = processingQueue[eventId];\n    if (!record) {\n      console.error(\"No record found for event\", eventId);\n      return;\n    }\n    delete processingQueue[eventId];\n    for (const resolve of record.resolves) {\n      resolve(result);\n    }\n  };\n}\nasync function verifySignatureAsync(event, _persist) {\n  const promise = new Promise((resolve) => {\n    const serialized = event.serialize();\n    let enqueue = false;\n    if (!processingQueue[event.id]) {\n      processingQueue[event.id] = { event, resolves: [] };\n      enqueue = true;\n    }\n    processingQueue[event.id].resolves.push(resolve);\n    if (!enqueue) return;\n    worker?.postMessage({\n      serialized,\n      id: event.id,\n      sig: event.sig,\n      pubkey: event.pubkey\n    });\n  });\n  return promise;\n}\n\n// src/events/validation.ts\nvar PUBKEY_REGEX = /^[a-f0-9]{64}$/;\nfunction validate() {\n  if (typeof this.kind !== \"number\") return false;\n  if (typeof this.content !== \"string\") return false;\n  if (typeof this.created_at !== \"number\") return false;\n  if (typeof this.pubkey !== \"string\") return false;\n  if (!this.pubkey.match(PUBKEY_REGEX)) return false;\n  if (!Array.isArray(this.tags)) return false;\n  for (let i = 0; i < this.tags.length; i++) {\n    const tag = this.tags[i];\n    if (!Array.isArray(tag)) return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\") return false;\n    }\n  }\n  return true;\n}\nvar verifiedSignatures = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n  maxSize: 1e3,\n  entryExpirationTimeInMS: 6e4\n});\nfunction verifySignature(persist) {\n  if (typeof this.signatureVerified === \"boolean\") return this.signatureVerified;\n  const prevVerification = verifiedSignatures.get(this.id);\n  if (prevVerification !== null) {\n    this.signatureVerified = !!prevVerification;\n    return this.signatureVerified;\n  }\n  try {\n    if (this.ndk?.asyncSigVerification) {\n      verifySignatureAsync(this, persist).then((result) => {\n        if (persist) {\n          this.signatureVerified = result;\n          if (result) verifiedSignatures.set(this.id, this.sig);\n        }\n        if (!result) {\n          this.ndk?.emit(\"event:invalid-sig\", this);\n          verifiedSignatures.set(this.id, false);\n        }\n      });\n    } else {\n      const hash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(new TextEncoder().encode(this.serialize()));\n      const res = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__.schnorr.verify(this.sig, hash, this.pubkey);\n      if (res) verifiedSignatures.set(this.id, this.sig);\n      else verifiedSignatures.set(this.id, false);\n      this.signatureVerified = res;\n      return res;\n    }\n  } catch (_err) {\n    this.signatureVerified = false;\n    return false;\n  }\n}\nfunction getEventHash() {\n  return getEventHashFromSerializedEvent(this.serialize());\n}\nfunction getEventHashFromSerializedEvent(serializedEvent) {\n  const eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(new TextEncoder().encode(serializedEvent));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(eventHash);\n}\n\n// src/events/index.ts\nvar skipClientTagOnKinds = /* @__PURE__ */ new Set([\n  0 /* Metadata */,\n  4 /* EncryptedDirectMessage */,\n  1059 /* GiftWrap */,\n  13 /* GiftWrapSeal */,\n  3 /* Contacts */,\n  9734 /* ZapRequest */,\n  5 /* EventDeletion */\n]);\nvar NDKEvent = class _NDKEvent extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  created_at;\n  content = \"\";\n  tags = [];\n  kind;\n  id = \"\";\n  sig;\n  pubkey = \"\";\n  signatureVerified;\n  _author = void 0;\n  /**\n   * The relay that this event was first received from.\n   */\n  relay;\n  /**\n   * The relays that this event was received from and/or successfully published to.\n   */\n  get onRelays() {\n    let res = [];\n    if (!this.ndk) {\n      if (this.relay) res.push(this.relay);\n    } else {\n      res = this.ndk.subManager.seenEvents.get(this.id) || [];\n    }\n    return res;\n  }\n  /**\n   * The status of the publish operation.\n   */\n  publishStatus = \"success\";\n  publishError;\n  constructor(ndk, event) {\n    super();\n    this.ndk = ndk;\n    this.created_at = event?.created_at;\n    this.content = event?.content || \"\";\n    this.tags = event?.tags || [];\n    this.id = event?.id || \"\";\n    this.sig = event?.sig;\n    this.pubkey = event?.pubkey || \"\";\n    this.kind = event?.kind;\n    if (event instanceof _NDKEvent) {\n      if (this.relay) {\n        this.relay = event.relay;\n        this.ndk?.subManager.seenEvent(event.id, this.relay);\n      }\n      this.publishStatus = event.publishStatus;\n      this.publishError = event.publishError;\n    }\n  }\n  /**\n   * Deserialize an NDKEvent from a serialized payload.\n   * @param ndk\n   * @param event\n   * @returns\n   */\n  static deserialize(ndk, event) {\n    return new _NDKEvent(ndk, deserialize(event));\n  }\n  /**\n   * Returns the event as is.\n   */\n  rawEvent() {\n    return {\n      created_at: this.created_at,\n      content: this.content,\n      tags: this.tags,\n      kind: this.kind,\n      pubkey: this.pubkey,\n      id: this.id,\n      sig: this.sig\n    };\n  }\n  set author(user) {\n    this.pubkey = user.pubkey;\n    this._author = user;\n    this._author.ndk ??= this.ndk;\n  }\n  /**\n   * Returns an NDKUser for the author of the event.\n   */\n  get author() {\n    if (this._author) return this._author;\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const user = this.ndk.getUser({ pubkey: this.pubkey });\n    this._author = user;\n    return user;\n  }\n  /**\n   * NIP-73 tagging of external entities\n   * @param entity to be tagged\n   * @param type of the entity\n   * @param markerUrl to be used as the marker URL\n   *\n   * @example\n   * ```typescript\n   * event.tagExternal(\"https://example.com/article/123#nostr\", \"url\");\n   * event.tags => [[\"i\", \"https://example.com/123\"], [\"k\", \"https://example.com\"]]\n   * ```\n   *\n   * @example tag a podcast:item:guid\n   * ```typescript\n   * event.tagExternal(\"e32b4890-b9ea-4aef-a0bf-54b787833dc5\", \"podcast:item:guid\");\n   * event.tags => [[\"i\", \"podcast:item:guid:e32b4890-b9ea-4aef-a0bf-54b787833dc5\"], [\"k\", \"podcast:item:guid\"]]\n   * ```\n   *\n   * @see https://github.com/nostr-protocol/nips/blob/master/73.md\n   */\n  tagExternal(entity, type, markerUrl) {\n    const iTag = [\"i\"];\n    const kTag = [\"k\"];\n    switch (type) {\n      case \"url\": {\n        const url = new URL(entity);\n        url.hash = \"\";\n        iTag.push(url.toString());\n        kTag.push(`${url.protocol}//${url.host}`);\n        break;\n      }\n      case \"hashtag\":\n        iTag.push(`#${entity.toLowerCase()}`);\n        kTag.push(\"#\");\n        break;\n      case \"geohash\":\n        iTag.push(`geo:${entity.toLowerCase()}`);\n        kTag.push(\"geo\");\n        break;\n      case \"isbn\":\n        iTag.push(`isbn:${entity.replace(/-/g, \"\")}`);\n        kTag.push(\"isbn\");\n        break;\n      case \"podcast:guid\":\n        iTag.push(`podcast:guid:${entity}`);\n        kTag.push(\"podcast:guid\");\n        break;\n      case \"podcast:item:guid\":\n        iTag.push(`podcast:item:guid:${entity}`);\n        kTag.push(\"podcast:item:guid\");\n        break;\n      case \"podcast:publisher:guid\":\n        iTag.push(`podcast:publisher:guid:${entity}`);\n        kTag.push(\"podcast:publisher:guid\");\n        break;\n      case \"isan\":\n        iTag.push(`isan:${entity.split(\"-\").slice(0, 4).join(\"-\")}`);\n        kTag.push(\"isan\");\n        break;\n      case \"doi\":\n        iTag.push(`doi:${entity.toLowerCase()}`);\n        kTag.push(\"doi\");\n        break;\n      default:\n        throw new Error(`Unsupported NIP-73 entity type: ${type}`);\n    }\n    if (markerUrl) {\n      iTag.push(markerUrl);\n    }\n    this.tags.push(iTag);\n    this.tags.push(kTag);\n  }\n  /**\n   * Tag a user with an optional marker.\n   * @param target What is to be tagged. Can be an NDKUser, NDKEvent, or an NDKTag.\n   * @param marker The marker to use in the tag.\n   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event.\n   * @param forceTag Force a specific tag to be used instead of the default \"e\" or \"a\" tag.\n   * @example\n   * ```typescript\n   * reply.tag(opEvent, \"reply\");\n   * // reply.tags => [[\"e\", <id>, <relay>, \"reply\"]]\n   * ```\n   */\n  tag(target, marker, skipAuthorTag, forceTag) {\n    let tags = [];\n    const isNDKUser = target.fetchProfile !== void 0;\n    if (isNDKUser) {\n      forceTag ??= \"p\";\n      const tag = [forceTag, target.pubkey];\n      if (marker) tag.push(...[\"\", marker]);\n      tags.push(tag);\n    } else if (target instanceof _NDKEvent) {\n      const event = target;\n      skipAuthorTag ??= event?.pubkey === this.pubkey;\n      tags = event.referenceTags(marker, skipAuthorTag, forceTag);\n      for (const pTag of event.getMatchingTags(\"p\")) {\n        if (pTag[1] === this.pubkey) continue;\n        if (this.tags.find((t) => t[0] === \"p\" && t[1] === pTag[1])) continue;\n        this.tags.push([\"p\", pTag[1]]);\n      }\n    } else if (Array.isArray(target)) {\n      tags = [target];\n    } else {\n      throw new Error(\"Invalid argument\", target);\n    }\n    this.tags = mergeTags(this.tags, tags);\n  }\n  /**\n   * Return a NostrEvent object, trying to fill in missing fields\n   * when possible, adding tags when necessary.\n   * @param pubkey {string} The pubkey of the user who the event belongs to.\n   * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.\n   */\n  async toNostrEvent(pubkey) {\n    if (!pubkey && this.pubkey === \"\") {\n      const user = await this.ndk?.signer?.user();\n      this.pubkey = user?.pubkey || \"\";\n    }\n    if (!this.created_at) {\n      this.created_at = Math.floor(Date.now() / 1e3);\n    }\n    const { content, tags } = await this.generateTags();\n    this.content = content || \"\";\n    this.tags = tags;\n    try {\n      this.id = this.getEventHash();\n    } catch (_e) {\n    }\n    return this.rawEvent();\n  }\n  serialize = serialize.bind(this);\n  getEventHash = getEventHash.bind(this);\n  validate = validate.bind(this);\n  verifySignature = verifySignature.bind(this);\n  /**\n   * Is this event replaceable (whether parameterized or not)?\n   *\n   * This will return true for kind 0, 3, 10k-20k and 30k-40k\n   */\n  isReplaceable = isReplaceable.bind(this);\n  isEphemeral = isEphemeral.bind(this);\n  isDvm = () => this.kind && this.kind >= 5e3 && this.kind <= 7e3;\n  /**\n   * Is this event parameterized replaceable?\n   *\n   * This will return true for kind 30k-40k\n   */\n  isParamReplaceable = isParamReplaceable.bind(this);\n  /**\n   * Encodes a bech32 id.\n   *\n   * @param relays {string[]} The relays to encode in the id\n   * @returns {string} - Encoded naddr, note or nevent.\n   */\n  encode = encode.bind(this);\n  encrypt = encrypt.bind(this);\n  decrypt = decrypt.bind(this);\n  /**\n   * Get all tags with the given name\n   * @param tagName {string} The name of the tag to search for\n   * @returns {NDKTag[]} An array of the matching tags\n   */\n  getMatchingTags(tagName, marker) {\n    const t = this.tags.filter((tag) => tag[0] === tagName);\n    if (marker === void 0) return t;\n    return t.filter((tag) => tag[3] === marker);\n  }\n  /**\n   * Check if the event has a tag with the given name\n   * @param tagName\n   * @param marker\n   * @returns\n   */\n  hasTag(tagName, marker) {\n    return this.tags.some((tag) => tag[0] === tagName && (!marker || tag[3] === marker));\n  }\n  /**\n   * Get the first tag with the given name\n   * @param tagName Tag name to search for\n   * @returns The value of the first tag with the given name, or undefined if no such tag exists\n   */\n  tagValue(tagName) {\n    const tags = this.getMatchingTags(tagName);\n    if (tags.length === 0) return void 0;\n    return tags[0][1];\n  }\n  /**\n   * Gets the NIP-31 \"alt\" tag of the event.\n   */\n  get alt() {\n    return this.tagValue(\"alt\");\n  }\n  /**\n   * Sets the NIP-31 \"alt\" tag of the event. Use this to set an alt tag so\n   * clients that don't handle a particular event kind can display something\n   * useful for users.\n   */\n  set alt(alt) {\n    this.removeTag(\"alt\");\n    if (alt) this.tags.push([\"alt\", alt]);\n  }\n  /**\n   * Gets the NIP-33 \"d\" tag of the event.\n   */\n  get dTag() {\n    return this.tagValue(\"d\");\n  }\n  /**\n   * Sets the NIP-33 \"d\" tag of the event.\n   */\n  set dTag(value) {\n    this.removeTag(\"d\");\n    if (value) this.tags.push([\"d\", value]);\n  }\n  /**\n   * Remove all tags with the given name (e.g. \"d\", \"a\", \"p\")\n   * @param tagName Tag name(s) to search for and remove\n   * @returns {void}\n   */\n  removeTag(tagName) {\n    const tagNames = Array.isArray(tagName) ? tagName : [tagName];\n    this.tags = this.tags.filter((tag) => !tagNames.includes(tag[0]));\n  }\n  /**\n   * Replace a tag with a new value. If not found, it will be added.\n   * @param tag The tag to replace.\n   * @param value The new value for the tag.\n   */\n  replaceTag(tag) {\n    this.removeTag(tag[0]);\n    this.tags.push(tag);\n  }\n  /**\n   * Sign the event if a signer is present.\n   *\n   * It will generate tags.\n   * Repleacable events will have their created_at field set to the current time.\n   * @param signer {NDKSigner} The NDKSigner to use to sign the event\n   * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.\n   */\n  async sign(signer) {\n    if (!signer) {\n      this.ndk?.assertSigner();\n      signer = this.ndk?.signer;\n    } else {\n      this.author = await signer.user();\n    }\n    const nostrEvent = await this.toNostrEvent();\n    this.sig = await signer.sign(nostrEvent);\n    return this.sig;\n  }\n  /**\n   *\n   * @param relaySet\n   * @param timeoutMs\n   * @param requiredRelayCount\n   * @returns\n   */\n  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {\n    this.id = \"\";\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.sig = \"\";\n    return this.publish(relaySet, timeoutMs, requiredRelayCount);\n  }\n  /**\n   * Attempt to sign and then publish an NDKEvent to a given relaySet.\n   * If no relaySet is provided, the relaySet will be calculated by NDK.\n   * @param relaySet {NDKRelaySet} The relaySet to publish the even to.\n   * @param timeoutM {number} The timeout for the publish operation in milliseconds.\n   * @param requiredRelayCount The number of relays that must receive the event for the publish to be considered successful.\n   * @returns A promise that resolves to the relays the event was published to.\n   */\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    if (!this.sig) await this.sign();\n    if (!this.ndk) throw new Error(\"NDKEvent must be associated with an NDK instance to publish\");\n    if (!relaySet || relaySet.size === 0) {\n      relaySet = this.ndk.devWriteRelaySet || await calculateRelaySetFromEvent(this.ndk, this);\n    }\n    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {\n      const eTags = this.getMatchingTags(\"e\").map((tag) => tag[1]);\n      this.ndk.cacheAdapter.deleteEventIds(eTags);\n    }\n    const rawEvent = this.rawEvent();\n    if (this.ndk.cacheAdapter?.addUnpublishedEvent && shouldTrackUnpublishedEvent(this)) {\n      try {\n        this.ndk.cacheAdapter.addUnpublishedEvent(this, relaySet.relayUrls);\n      } catch (e) {\n        console.error(\"Error adding unpublished event to cache\", e);\n      }\n    }\n    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {\n      this.ndk.cacheAdapter.deleteEventIds(this.getMatchingTags(\"e\").map((tag) => tag[1]));\n    }\n    this.ndk.subManager.dispatchEvent(rawEvent, void 0, true);\n    const relays = await relaySet.publish(this, timeoutMs, requiredRelayCount);\n    relays.forEach((relay) => this.ndk?.subManager.seenEvent(this.id, relay));\n    return relays;\n  }\n  /**\n   * Generates tags for users, notes, and other events tagged in content.\n   * Will also generate random \"d\" tag for parameterized replaceable events where needed.\n   * @returns {ContentTag} The tags and content of the event.\n   */\n  async generateTags() {\n    let tags = [];\n    const g = await generateContentTags(this.content, this.tags);\n    const content = g.content;\n    tags = g.tags;\n    if (this.kind && this.isParamReplaceable()) {\n      const dTag = this.getMatchingTags(\"d\")[0];\n      if (!dTag) {\n        const title = this.tagValue(\"title\");\n        const randLength = title ? 6 : 16;\n        let str = [...Array(randLength)].map(() => Math.random().toString(36)[2]).join(\"\");\n        if (title && title.length > 0) {\n          str = `${title.replace(/[^a-z0-9]+/gi, \"-\").replace(/^-|-$/g, \"\")}-${str}`;\n        }\n        tags.push([\"d\", str]);\n      }\n    }\n    if (this.shouldAddClientTag) {\n      const clientTag = [\"client\", this.ndk?.clientName ?? \"\"];\n      if (this.ndk?.clientNip89) clientTag.push(this.ndk?.clientNip89);\n      tags.push(clientTag);\n    } else if (this.shouldStripClientTag) {\n      tags = tags.filter((tag) => tag[0] !== \"client\");\n    }\n    return { content: content || \"\", tags };\n  }\n  get shouldAddClientTag() {\n    if (!this.ndk?.clientName && !this.ndk?.clientNip89) return false;\n    if (skipClientTagOnKinds.has(this.kind)) return false;\n    if (this.isEphemeral()) return false;\n    if (this.isReplaceable() && !this.isParamReplaceable()) return false;\n    if (this.isDvm()) return false;\n    if (this.hasTag(\"client\")) return false;\n    return true;\n  }\n  get shouldStripClientTag() {\n    return skipClientTagOnKinds.has(this.kind);\n  }\n  muted() {\n    const authorMutedEntry = this.ndk?.mutedIds.get(this.pubkey);\n    if (authorMutedEntry && authorMutedEntry === \"p\") return \"author\";\n    const eventTagReference = this.tagReference();\n    const eventMutedEntry = this.ndk?.mutedIds.get(eventTagReference[1]);\n    if (eventMutedEntry && eventMutedEntry === eventTagReference[0]) return \"event\";\n    return null;\n  }\n  /**\n   * Returns the \"d\" tag of a parameterized replaceable event or throws an error if the event isn't\n   * a parameterized replaceable event.\n   * @returns {string} the \"d\" tag of the event.\n   *\n   * @deprecated Use `dTag` instead.\n   */\n  replaceableDTag() {\n    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {\n      const dTag = this.getMatchingTags(\"d\")[0];\n      const dTagId = dTag ? dTag[1] : \"\";\n      return dTagId;\n    }\n    throw new Error(\"Event is not a parameterized replaceable event\");\n  }\n  /**\n   * Provides a deduplication key for the event.\n   *\n   * For kinds 0, 3, 10k-20k this will be the event <kind>:<pubkey>\n   * For kinds 30k-40k this will be the event <kind>:<pubkey>:<d-tag>\n   * For all other kinds this will be the event id\n   */\n  deduplicationKey() {\n    if (this.kind === 0 || this.kind === 3 || this.kind && this.kind >= 1e4 && this.kind < 2e4) {\n      return `${this.kind}:${this.pubkey}`;\n    }\n    return this.tagId();\n  }\n  /**\n   * Returns the id of the event or, if it's a parameterized event, the generated id of the event using \"d\" tag, pubkey, and kind.\n   * @returns {string} The id\n   */\n  tagId() {\n    if (this.isParamReplaceable()) {\n      return this.tagAddress();\n    }\n    return this.id;\n  }\n  /**\n   * Returns a stable reference value for a replaceable event.\n   *\n   * Param replaceable events are returned in the expected format of `<kind>:<pubkey>:<d-tag>`.\n   * Kind-replaceable events are returned in the format of `<kind>:<pubkey>:`.\n   *\n   * @returns {string} A stable reference value for replaceable events\n   */\n  tagAddress() {\n    if (this.isParamReplaceable()) {\n      const dTagId = this.dTag ?? \"\";\n      return `${this.kind}:${this.pubkey}:${dTagId}`;\n    }\n    if (this.isReplaceable()) {\n      return `${this.kind}:${this.pubkey}:`;\n    }\n    throw new Error(\"Event is not a replaceable event\");\n  }\n  /**\n   * Determines the type of tag that can be used to reference this event from another event.\n   * @returns {string} The tag type\n   * @example\n   * event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   * event.tagType(); // \"a\"\n   */\n  tagType() {\n    return this.isParamReplaceable() ? \"a\" : \"e\";\n  }\n  /**\n   * Get the tag that can be used to reference this event from another event.\n   *\n   * Consider using referenceTags() instead (unless you have a good reason to use this)\n   *\n   * @example\n   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *     event.tagReference(); // [\"a\", \"30000:pubkey:d-code\"]\n   *\n   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *     event.tagReference(); // [\"e\", \"eventid\"]\n   * @returns {NDKTag} The NDKTag object referencing this event\n   */\n  tagReference(marker) {\n    let tag;\n    if (this.isParamReplaceable()) {\n      tag = [\"a\", this.tagAddress()];\n    } else {\n      tag = [\"e\", this.tagId()];\n    }\n    if (this.relay) {\n      tag.push(this.relay.url);\n    } else {\n      tag.push(\"\");\n    }\n    tag.push(marker ?? \"\");\n    if (!this.isParamReplaceable()) {\n      tag.push(this.pubkey);\n    }\n    return tag;\n  }\n  /**\n   * Get the tags that can be used to reference this event from another event\n   * @param marker The marker to use in the tag\n   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event\n   * @param forceTag Force a specific tag to be used instead of the default \"e\" or \"a\" tag\n   * @example\n   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *     event.referenceTags(); // [[\"a\", \"30000:pubkey:d-code\"], [\"e\", \"parent-id\"]]\n   *\n   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *     event.referenceTags(); // [[\"e\", \"parent-id\"]]\n   * @returns {NDKTag} The NDKTag object referencing this event\n   */\n  referenceTags(marker, skipAuthorTag, forceTag) {\n    let tags = [];\n    if (this.isParamReplaceable()) {\n      tags = [\n        [forceTag ?? \"a\", this.tagAddress()],\n        [forceTag ?? \"e\", this.id]\n      ];\n    } else {\n      tags = [[forceTag ?? \"e\", this.id]];\n    }\n    tags = tags.map((tag) => {\n      if (tag[0] === \"e\" || marker) {\n        tag.push(this.relay?.url ?? \"\");\n      } else if (this.relay?.url) {\n        tag.push(this.relay?.url);\n      }\n      return tag;\n    });\n    tags.forEach((tag) => {\n      if (tag[0] === \"e\") {\n        tag.push(marker ?? \"\");\n        tag.push(this.pubkey);\n      } else if (marker) {\n        tag.push(marker);\n      }\n    });\n    tags = [...tags, ...this.getMatchingTags(\"h\")];\n    if (!skipAuthorTag) tags.push(...this.author.referenceTags());\n    return tags;\n  }\n  /**\n   * Provides the filter that will return matching events for this event.\n   *\n   * @example\n   *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *    event.filter(); // { \"#a\": [\"30000:pubkey:d-code\"] }\n   * @example\n   *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *    event.filter(); // { \"#e\": [\"eventid\"] }\n   *\n   * @returns The filter that will return matching events for this event\n   */\n  filter() {\n    if (this.isParamReplaceable()) {\n      return { \"#a\": [this.tagId()] };\n    }\n    return { \"#e\": [this.tagId()] };\n  }\n  nip22Filter() {\n    if (this.isParamReplaceable()) {\n      return { \"#A\": [this.tagId()] };\n    }\n    return { \"#E\": [this.tagId()] };\n  }\n  /**\n   * Generates a deletion event of the current event\n   *\n   * @param reason The reason for the deletion\n   * @param publish Whether to publish the deletion event automatically\n   * @returns The deletion event\n   */\n  async delete(reason, publish = true) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const e = new _NDKEvent(this.ndk, {\n      kind: 5 /* EventDeletion */,\n      content: reason || \"\"\n    });\n    e.tag(this, void 0, true);\n    e.tags.push([\"k\", this.kind?.toString()]);\n    if (publish) {\n      this.emit(\"deleted\");\n      await e.publish();\n    }\n    return e;\n  }\n  /**\n   * Establishes whether this is a NIP-70-protectede event.\n   * @@satisfies NIP-70\n   */\n  set isProtected(val) {\n    this.removeTag(\"-\");\n    if (val) this.tags.push([\"-\"]);\n  }\n  /**\n   * Whether this is a NIP-70-protected event.\n   * @@satisfies NIP-70\n   */\n  get isProtected() {\n    return this.hasTag(\"-\");\n  }\n  /**\n   * Fetch an event tagged with the given tag following relay hints if provided.\n   * @param tag The tag to search for\n   * @param marker The marker to use in the tag (e.g. \"root\")\n   * @returns The fetched event or null if no event was found, undefined if no matching tag was found in the event\n   * * @example\n   * const replyEvent = await ndk.fetchEvent(\"nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd\")\n   * const originalEvent = await replyEvent.fetchTaggedEvent(\"e\", \"reply\");\n   * console.log(replyEvent.encode() + \" is a reply to event \" + originalEvent?.encode());\n   */\n  fetchTaggedEvent = fetchTaggedEvent.bind(this);\n  /**\n   * Fetch the root event of the current event.\n   * @returns The fetched root event or null if no event was found\n   * @example\n   * const replyEvent = await ndk.fetchEvent(\"nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd\")\n   * const rootEvent = await replyEvent.fetchRootEvent();\n   * console.log(replyEvent.encode() + \" is a reply in the thread \" + rootEvent?.encode());\n   */\n  fetchRootEvent = fetchRootEvent.bind(this);\n  /**\n   * Fetch the event the current event is replying to.\n   * @returns The fetched reply event or null if no event was found\n   */\n  fetchReplyEvent = fetchReplyEvent.bind(this);\n  /**\n   * NIP-18 reposting event.\n   *\n   * @param publish Whether to publish the reposted event automatically @default true\n   * @param signer The signer to use for signing the reposted event\n   * @returns The reposted event\n   *\n   * @function\n   */\n  repost = repost.bind(this);\n  /**\n   * React to an existing event\n   *\n   * @param content The content of the reaction\n   */\n  async react(content, publish = true) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const e = new _NDKEvent(this.ndk, {\n      kind: 7 /* Reaction */,\n      content\n    });\n    e.tag(this);\n    if (publish) await e.publish();\n    return e;\n  }\n  /**\n   * Checks whether the event is valid per underlying NIPs.\n   *\n   * This method is meant to be overridden by subclasses that implement specific NIPs\n   * to allow the enforcement of NIP-specific validation rules.\n   *\n   * Otherwise, it will only check for basic event properties.\n   *\n   */\n  get isValid() {\n    return this.validate();\n  }\n  get inspect() {\n    return JSON.stringify(this.rawEvent(), null, 4);\n  }\n  /**\n   * Dump the event to console for debugging purposes.\n   * Prints a JSON stringified version of rawEvent() with indentation\n   * and also lists all relay URLs for onRelays.\n   */\n  dump() {\n    console.debug(JSON.stringify(this.rawEvent(), null, 4));\n    console.debug(\"Event on relays:\", this.onRelays.map((relay) => relay.url).join(\", \"));\n  }\n  /**\n   * Creates a reply event for the current event.\n   *\n   * This function will use NIP-22 when appropriate (i.e. replies to non-kind:1 events).\n   * This function does not have side-effects; it will just return an event with the appropriate tags\n   * to generate the reply event; the caller is responsible for publishing the event.\n   */\n  reply() {\n    const reply = new _NDKEvent(this.ndk);\n    if (this.kind === 1) {\n      reply.kind = 1;\n      const opHasETag = this.hasTag(\"e\");\n      if (opHasETag) {\n        reply.tags = [\n          ...reply.tags,\n          ...this.getMatchingTags(\"e\"),\n          ...this.getMatchingTags(\"p\"),\n          ...this.getMatchingTags(\"a\"),\n          ...this.referenceTags(\"reply\")\n        ];\n      } else {\n        reply.tag(this, \"root\");\n      }\n    } else {\n      reply.kind = 1111 /* GenericReply */;\n      const carryOverTags = [\"A\", \"E\", \"I\", \"P\"];\n      const rootTags = this.tags.filter((tag) => carryOverTags.includes(tag[0]));\n      if (rootTags.length > 0) {\n        const rootKind = this.tagValue(\"K\");\n        reply.tags.push(...rootTags);\n        if (rootKind) reply.tags.push([\"K\", rootKind]);\n        const [type, id, _, ...extra] = this.tagReference();\n        const tag = [type, id, ...extra];\n        reply.tags.push(tag);\n      } else {\n        const [type, id, _, relayHint] = this.tagReference();\n        const tag = [type, id, relayHint ?? \"\"];\n        if (type === \"e\") tag.push(this.pubkey);\n        reply.tags.push(tag);\n        const uppercaseTag = [...tag];\n        uppercaseTag[0] = uppercaseTag[0].toUpperCase();\n        reply.tags.push(uppercaseTag);\n        reply.tags.push([\"K\", this.kind?.toString()]);\n        reply.tags.push([\"P\", this.pubkey]);\n      }\n      reply.tags.push([\"k\", this.kind?.toString()]);\n      reply.tags.push(...this.getMatchingTags(\"p\"));\n      reply.tags.push([\"p\", this.pubkey]);\n    }\n    return reply;\n  }\n};\nvar untrackedUnpublishedEvents = /* @__PURE__ */ new Set([\n  24133 /* NostrConnect */,\n  13194 /* NostrWaletConnectInfo */,\n  23194 /* NostrWalletConnectReq */,\n  23195 /* NostrWalletConnectRes */\n]);\nfunction shouldTrackUnpublishedEvent(event) {\n  return !untrackedUnpublishedEvents.has(event.kind);\n}\n\n// src/relay/pool/index.ts\n\nvar NDKPool = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  // TODO: This should probably be an LRU cache\n  _relays = /* @__PURE__ */ new Map();\n  status = \"idle\";\n  autoConnectRelays = /* @__PURE__ */ new Set();\n  poolBlacklistRelayUrls = /* @__PURE__ */ new Set();\n  debug;\n  temporaryRelayTimers = /* @__PURE__ */ new Map();\n  flappingRelays = /* @__PURE__ */ new Set();\n  // A map to store timeouts for each flapping relay.\n  backoffTimes = /* @__PURE__ */ new Map();\n  ndk;\n  get blacklistRelayUrls() {\n    const val = new Set(this.ndk.blacklistRelayUrls);\n    this.poolBlacklistRelayUrls.forEach((url) => val.add(url));\n    return val;\n  }\n  /**\n   * @param relayUrls - The URLs of the relays to connect to.\n   * @param blacklistedRelayUrls - URLs to blacklist for this pool IN ADDITION to those blacklisted at the ndk-level\n   * @param ndk - The NDK instance.\n   * @param opts - Options for the pool.\n   */\n  constructor(relayUrls, blacklistedRelayUrls, ndk, {\n    debug: debug8,\n    name\n  } = {}) {\n    super();\n    this.debug = debug8 ?? ndk.debug.extend(\"pool\");\n    if (name) this._name = name;\n    this.ndk = ndk;\n    this.relayUrls = relayUrls;\n    this.poolBlacklistRelayUrls = new Set(blacklistedRelayUrls);\n    this.ndk.pools.push(this);\n  }\n  get relays() {\n    return this._relays;\n  }\n  set relayUrls(urls) {\n    this._relays.clear();\n    for (const relayUrl of urls) {\n      const relay = new NDKRelay(relayUrl, void 0, this.ndk);\n      relay.connectivity.netDebug = this.ndk.netDebug;\n      this.addRelay(relay);\n    }\n  }\n  _name = \"unnamed\";\n  get name() {\n    return this._name;\n  }\n  set name(name) {\n    this._name = name;\n    this.debug = this.debug.extend(name);\n  }\n  /**\n   * Adds a relay to the pool, and sets a timer to remove it if it is not used within the specified time.\n   * @param relay - The relay to add to the pool.\n   * @param removeIfUnusedAfter - The time in milliseconds to wait before removing the relay from the pool after it is no longer used.\n   */\n  useTemporaryRelay(relay, removeIfUnusedAfter = 3e4, filters) {\n    const relayAlreadyInPool = this.relays.has(relay.url);\n    if (!relayAlreadyInPool) {\n      this.addRelay(relay);\n      this.debug(\"Adding temporary relay %s for filters %o\", relay.url, filters);\n    }\n    const existingTimer = this.temporaryRelayTimers.get(relay.url);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n    if (!relayAlreadyInPool || existingTimer) {\n      const timer = setTimeout(() => {\n        if (this.ndk.explicitRelayUrls?.includes(relay.url)) return;\n        this.removeRelay(relay.url);\n      }, removeIfUnusedAfter);\n      this.temporaryRelayTimers.set(relay.url, timer);\n    }\n  }\n  /**\n   * Adds a relay to the pool.\n   *\n   * @param relay - The relay to add to the pool.\n   * @param connect - Whether or not to connect to the relay.\n   */\n  addRelay(relay, connect = true) {\n    const isAlreadyInPool = this.relays.has(relay.url);\n    const isBlacklisted = this.blacklistRelayUrls?.has(relay.url);\n    const isCustomRelayUrl = relay.url.includes(\"/npub1\");\n    let reconnect = true;\n    const relayUrl = relay.url;\n    if (isAlreadyInPool) return;\n    if (isBlacklisted) {\n      this.debug(`Refusing to add relay ${relayUrl}: blacklisted`);\n      return;\n    }\n    if (isCustomRelayUrl) {\n      this.debug(`Refusing to add relay ${relayUrl}: is a filter relay`);\n      return;\n    }\n    if (this.ndk.cacheAdapter?.getRelayStatus) {\n      const info = this.ndk.cacheAdapter.getRelayStatus(relayUrl);\n      if (info?.dontConnectBefore) {\n        if (info.dontConnectBefore > Date.now()) {\n          const delay = info.dontConnectBefore - Date.now();\n          this.debug(`Refusing to add relay ${relayUrl}: delayed connect for ${delay}ms`);\n          setTimeout(() => {\n            this.addRelay(relay, connect);\n          }, delay);\n          return;\n        }\n        reconnect = false;\n      }\n    }\n    const noticeHandler = (notice) => this.emit(\"notice\", relay, notice);\n    const connectHandler = () => this.handleRelayConnect(relayUrl);\n    const readyHandler = () => this.handleRelayReady(relay);\n    const disconnectHandler = () => this.emit(\"relay:disconnect\", relay);\n    const flappingHandler = () => this.handleFlapping(relay);\n    const authHandler = (challenge) => this.emit(\"relay:auth\", relay, challenge);\n    const authedHandler = () => this.emit(\"relay:authed\", relay);\n    relay.off(\"notice\", noticeHandler);\n    relay.off(\"connect\", connectHandler);\n    relay.off(\"ready\", readyHandler);\n    relay.off(\"disconnect\", disconnectHandler);\n    relay.off(\"flapping\", flappingHandler);\n    relay.off(\"auth\", authHandler);\n    relay.off(\"authed\", authedHandler);\n    relay.on(\"notice\", noticeHandler);\n    relay.on(\"connect\", connectHandler);\n    relay.on(\"ready\", readyHandler);\n    relay.on(\"disconnect\", disconnectHandler);\n    relay.on(\"flapping\", flappingHandler);\n    relay.on(\"auth\", authHandler);\n    relay.on(\"authed\", authedHandler);\n    relay.on(\"delayed-connect\", (delay) => {\n      if (this.ndk.cacheAdapter?.updateRelayStatus) {\n        this.ndk.cacheAdapter.updateRelayStatus(relay.url, {\n          dontConnectBefore: Date.now() + delay\n        });\n      }\n    });\n    this._relays.set(relayUrl, relay);\n    if (connect) this.autoConnectRelays.add(relayUrl);\n    if (connect && this.status === \"active\") {\n      this.emit(\"relay:connecting\", relay);\n      relay.connect(void 0, reconnect).catch((e) => {\n        this.debug(`Failed to connect to relay ${relayUrl}`, e);\n      });\n    }\n  }\n  /**\n   * Removes a relay from the pool.\n   * @param relayUrl - The URL of the relay to remove.\n   * @returns {boolean} True if the relay was removed, false if it was not found.\n   */\n  removeRelay(relayUrl) {\n    const relay = this.relays.get(relayUrl);\n    if (relay) {\n      relay.disconnect();\n      this.relays.delete(relayUrl);\n      this.autoConnectRelays.delete(relayUrl);\n      this.emit(\"relay:disconnect\", relay);\n      return true;\n    }\n    const existingTimer = this.temporaryRelayTimers.get(relayUrl);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n      this.temporaryRelayTimers.delete(relayUrl);\n    }\n    return false;\n  }\n  /**\n   * Checks whether a relay is already connected in the pool.\n   */\n  isRelayConnected(url) {\n    const normalizedUrl = normalizeRelayUrl(url);\n    const relay = this.relays.get(normalizedUrl);\n    if (!relay) return false;\n    return relay.status === 5 /* CONNECTED */;\n  }\n  /**\n   * Fetches a relay from the pool, or creates a new one if it does not exist.\n   *\n   * New relays will be attempted to be connected.\n   */\n  getRelay(url, connect = true, temporary = false, filters) {\n    let relay = this.relays.get(normalizeRelayUrl(url));\n    if (!relay) {\n      relay = new NDKRelay(url, void 0, this.ndk);\n      relay.connectivity.netDebug = this.ndk.netDebug;\n      if (temporary) {\n        this.useTemporaryRelay(relay, 3e4, filters);\n      } else {\n        this.addRelay(relay, connect);\n      }\n    }\n    return relay;\n  }\n  handleRelayConnect(relayUrl) {\n    const relay = this.relays.get(relayUrl);\n    if (!relay) {\n      console.error(\"NDK BUG: relay not found in pool\", { relayUrl });\n      return;\n    }\n    this.emit(\"relay:connect\", relay);\n    if (this.stats().connected === this.relays.size) {\n      this.emit(\"connect\");\n    }\n  }\n  handleRelayReady(relay) {\n    this.emit(\"relay:ready\", relay);\n  }\n  /**\n   * Attempts to establish a connection to each relay in the pool.\n   *\n   * @async\n   * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.\n   * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.\n   * @throws {Error} If any of the connection attempts result in an error or timeout.\n   */\n  async connect(timeoutMs) {\n    const promises = [];\n    this.status = \"active\";\n    this.debug(`Connecting to ${this.relays.size} relays${timeoutMs ? `, timeout ${timeoutMs}...` : \"\"}`);\n    const relaysToConnect = new Set(this.autoConnectRelays.keys());\n    for (const relayUrl of relaysToConnect) {\n      const relay = this.relays.get(relayUrl);\n      if (!relay) {\n        continue;\n      }\n      const connectPromise = new Promise((resolve, reject) => {\n        this.emit(\"relay:connecting\", relay);\n        return relay.connect(timeoutMs).then(resolve).catch(reject);\n      });\n      if (timeoutMs) {\n        const timeoutPromise = new Promise((_, reject) => {\n          setTimeout(() => reject(`Timed out after ${timeoutMs}ms`), timeoutMs);\n        });\n        promises.push(\n          Promise.race([connectPromise, timeoutPromise]).catch((e) => {\n            this.debug(`Failed to connect to relay ${relay.url}: ${e ?? \"No reason specified\"}`);\n          })\n        );\n      } else {\n        promises.push(connectPromise);\n      }\n    }\n    const maybeEmitConnect = () => {\n      const allConnected = this.stats().connected === this.relays.size;\n      const someConnected = this.stats().connected > 0;\n      if (!allConnected && someConnected) {\n        this.emit(\"connect\");\n      }\n    };\n    if (timeoutMs) setTimeout(maybeEmitConnect, timeoutMs);\n    await Promise.all(promises);\n    maybeEmitConnect();\n  }\n  checkOnFlappingRelays() {\n    const flappingRelaysCount = this.flappingRelays.size;\n    const totalRelays = this.relays.size;\n    if (flappingRelaysCount / totalRelays >= 0.8) {\n      for (const relayUrl of this.flappingRelays) {\n        this.backoffTimes.set(relayUrl, 0);\n      }\n    }\n  }\n  handleFlapping(relay) {\n    this.debug(`Relay ${relay.url} is flapping`);\n    let currentBackoff = this.backoffTimes.get(relay.url) || 5e3;\n    currentBackoff = currentBackoff * 2;\n    this.backoffTimes.set(relay.url, currentBackoff);\n    this.debug(`Backoff time for ${relay.url} is ${currentBackoff}ms`);\n    setTimeout(() => {\n      this.debug(`Attempting to reconnect to ${relay.url}`);\n      this.emit(\"relay:connecting\", relay);\n      relay.connect();\n      this.checkOnFlappingRelays();\n    }, currentBackoff);\n    relay.disconnect();\n    this.emit(\"flapping\", relay);\n  }\n  size() {\n    return this.relays.size;\n  }\n  /**\n   * Returns the status of each relay in the pool.\n   * @returns {NDKPoolStats} An object containing the number of relays in each status.\n   */\n  stats() {\n    const stats = {\n      total: 0,\n      connected: 0,\n      disconnected: 0,\n      connecting: 0\n    };\n    for (const relay of this.relays.values()) {\n      stats.total++;\n      if (relay.status === 5 /* CONNECTED */) {\n        stats.connected++;\n      } else if (relay.status === 1 /* DISCONNECTED */) {\n        stats.disconnected++;\n      } else if (relay.status === 4 /* CONNECTING */) {\n        stats.connecting++;\n      }\n    }\n    return stats;\n  }\n  connectedRelays() {\n    return Array.from(this.relays.values()).filter((relay) => relay.status >= 5 /* CONNECTED */);\n  }\n  permanentAndConnectedRelays() {\n    return Array.from(this.relays.values()).filter(\n      (relay) => relay.status >= 5 /* CONNECTED */ && !this.temporaryRelayTimers.has(relay.url)\n    );\n  }\n  /**\n   * Get a list of all relay urls in the pool.\n   */\n  urls() {\n    return Array.from(this.relays.keys());\n  }\n};\n\n// src/user/index.ts\n\n\n// src/events/kinds/nutzap/mint-list.ts\nvar NDKCashuMintList = class _NDKCashuMintList extends NDKEvent {\n  static kind = 10019 /* CashuMintList */;\n  static kinds = [10019 /* CashuMintList */];\n  _p2pk;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 10019 /* CashuMintList */;\n  }\n  static from(event) {\n    return new _NDKCashuMintList(event.ndk, event);\n  }\n  set relays(urls) {\n    this.tags = this.tags.filter((t) => t[0] !== \"relay\");\n    for (const url of urls) {\n      this.tags.push([\"relay\", url]);\n    }\n  }\n  get relays() {\n    const r = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"relay\") {\n        r.push(tag[1]);\n      }\n    }\n    return r;\n  }\n  set mints(urls) {\n    this.tags = this.tags.filter((t) => t[0] !== \"mint\");\n    for (const url of urls) {\n      this.tags.push([\"mint\", url]);\n    }\n  }\n  get mints() {\n    const r = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"mint\") {\n        r.push(tag[1]);\n      }\n    }\n    return Array.from(new Set(r));\n  }\n  get p2pk() {\n    if (this._p2pk) {\n      return this._p2pk;\n    }\n    this._p2pk = this.tagValue(\"pubkey\") ?? this.pubkey;\n    return this._p2pk;\n  }\n  set p2pk(pubkey) {\n    this._p2pk = pubkey;\n    this.removeTag(\"pubkey\");\n    if (pubkey) {\n      this.tags.push([\"pubkey\", pubkey]);\n    }\n  }\n  get relaySet() {\n    return NDKRelaySet.fromRelayUrls(this.relays, this.ndk);\n  }\n};\n\n// src/subscription/index.ts\n\n\n// src/events/kinds/article.ts\nvar NDKArticle = class _NDKArticle extends NDKEvent {\n  static kind = 30023 /* Article */;\n  static kinds = [30023 /* Article */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30023 /* Article */;\n  }\n  /**\n   * Creates a NDKArticle from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKArticle from.\n   * @returns NDKArticle\n   */\n  static from(event) {\n    return new _NDKArticle(event.ndk, event);\n  }\n  /**\n   * Getter for the article title.\n   *\n   * @returns {string | undefined} - The article title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the article title.\n   *\n   * @param {string | undefined} title - The title to set for the article.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the article image.\n   *\n   * @returns {string | undefined} - The article image if available, otherwise undefined.\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Setter for the article image.\n   *\n   * @param {string | undefined} image - The image to set for the article.\n   */\n  set image(image) {\n    this.removeTag(\"image\");\n    if (image) this.tags.push([\"image\", image]);\n  }\n  get summary() {\n    return this.tagValue(\"summary\");\n  }\n  set summary(summary) {\n    this.removeTag(\"summary\");\n    if (summary) this.tags.push([\"summary\", summary]);\n  }\n  /**\n   * Getter for the article's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      let val = Number.parseInt(tag);\n      if (val > 1e12) {\n        val = Math.floor(val / 1e3);\n      }\n      return val;\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the article's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Generates content tags for the article.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n  /**\n   * Getter for the article's URL.\n   *\n   * @returns {string | undefined} - The article's URL if available, otherwise undefined.\n   */\n  get url() {\n    return this.tagValue(\"url\");\n  }\n  /**\n   * Setter for the article's URL.\n   *\n   * @param {string | undefined} url - The URL to set for the article.\n   */\n  set url(url) {\n    if (url) {\n      this.tags.push([\"url\", url]);\n    } else {\n      this.removeTag(\"url\");\n    }\n  }\n};\n\n// src/events/kinds/cashu/token.ts\nfunction proofsTotalBalance(proofs) {\n  return proofs.reduce((acc, proof) => {\n    if (proof.amount < 0) {\n      throw new Error(\"proof amount is negative\");\n    }\n    return acc + proof.amount;\n  }, 0);\n}\nvar NDKCashuToken = class _NDKCashuToken extends NDKEvent {\n  _proofs = [];\n  _mint;\n  static kind = 7375 /* CashuToken */;\n  static kinds = [7375 /* CashuToken */];\n  /**\n   * Tokens that this token superseeds\n   */\n  _deletes = [];\n  original;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7375 /* CashuToken */;\n  }\n  static async from(event) {\n    const token = new _NDKCashuToken(event.ndk, event);\n    token.original = event;\n    try {\n      await token.decrypt();\n    } catch {\n      token.content = token.original.content;\n    }\n    try {\n      const content = JSON.parse(token.content);\n      token.proofs = content.proofs;\n      token.mint = content.mint ?? token.tagValue(\"mint\");\n      token.deletedTokens = content.del ?? [];\n      if (!Array.isArray(token.proofs)) return;\n    } catch (_e) {\n      return;\n    }\n    return token;\n  }\n  get proofs() {\n    return this._proofs;\n  }\n  set proofs(proofs) {\n    const cs = /* @__PURE__ */ new Set();\n    this._proofs = proofs.filter((proof) => {\n      if (cs.has(proof.C)) {\n        console.warn(\"Passed in proofs had duplicates, ignoring\", proof.C);\n        return false;\n      }\n      if (proof.amount < 0) {\n        console.warn(\"Invalid proof with negative amount\", proof);\n        return false;\n      }\n      cs.add(proof.C);\n      return true;\n    }).map(this.cleanProof);\n  }\n  /**\n   * Returns a minimal proof object with only essential properties\n   */\n  cleanProof(proof) {\n    return {\n      id: proof.id,\n      amount: proof.amount,\n      C: proof.C,\n      secret: proof.secret\n    };\n  }\n  async toNostrEvent(pubkey) {\n    if (!this.ndk) throw new Error(\"no ndk\");\n    if (!this.ndk.signer) throw new Error(\"no signer\");\n    const payload = {\n      proofs: this.proofs.map(this.cleanProof),\n      mint: this.mint,\n      del: this.deletedTokens ?? []\n    };\n    this.content = JSON.stringify(payload);\n    const user = await this.ndk.signer.user();\n    await this.encrypt(user, void 0, \"nip44\");\n    return super.toNostrEvent(pubkey);\n  }\n  set mint(mint) {\n    this._mint = mint;\n  }\n  get mint() {\n    return this._mint;\n  }\n  /**\n   * Tokens that were deleted by the creation of this token.\n   */\n  get deletedTokens() {\n    return this._deletes;\n  }\n  /**\n   * Marks tokens that were deleted by the creation of this token.\n   */\n  set deletedTokens(tokenIds) {\n    this._deletes = tokenIds;\n  }\n  get amount() {\n    return proofsTotalBalance(this.proofs);\n  }\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    if (this.original) {\n      return this.original.publish(relaySet, timeoutMs, requiredRelayCount);\n    }\n    return super.publish(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/events/kinds/highlight.ts\n\nvar NDKHighlight = class _NDKHighlight extends NDKEvent {\n  _article;\n  static kind = 9802 /* Highlight */;\n  static kinds = [9802 /* Highlight */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 9802 /* Highlight */;\n  }\n  static from(event) {\n    return new _NDKHighlight(event.ndk, event);\n  }\n  get url() {\n    return this.tagValue(\"r\");\n  }\n  /**\n   * Context tag.\n   */\n  set context(context) {\n    if (context === void 0) {\n      this.tags = this.tags.filter(([tag, _value]) => tag !== \"context\");\n    } else {\n      this.tags = this.tags.filter(([tag, _value]) => tag !== \"context\");\n      this.tags.push([\"context\", context]);\n    }\n  }\n  get context() {\n    return this.tags.find(([tag, _value]) => tag === \"context\")?.[1] ?? void 0;\n  }\n  /**\n   * Will return the article URL or NDKEvent if they have already been\n   * set (it won't attempt to load remote events)\n   */\n  get article() {\n    return this._article;\n  }\n  /**\n   * Article the highlight is coming from.\n   *\n   * @param article Article URL or NDKEvent.\n   */\n  set article(article) {\n    this._article = article;\n    if (typeof article === \"string\") {\n      this.tags.push([\"r\", article]);\n    } else {\n      this.tag(article);\n    }\n  }\n  getArticleTag() {\n    return this.getMatchingTags(\"a\")[0] || this.getMatchingTags(\"e\")[0] || this.getMatchingTags(\"r\")[0];\n  }\n  async getArticle() {\n    if (this._article !== void 0) return this._article;\n    let taggedBech32;\n    const articleTag = this.getArticleTag();\n    if (!articleTag) return void 0;\n    switch (articleTag[0]) {\n      case \"a\": {\n        const [kind, pubkey, identifier] = articleTag[1].split(\":\");\n        taggedBech32 = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.naddrEncode({\n          kind: Number.parseInt(kind),\n          pubkey,\n          identifier\n        });\n        break;\n      }\n      case \"e\":\n        taggedBech32 = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.noteEncode(articleTag[1]);\n        break;\n      case \"r\":\n        this._article = articleTag[1];\n        break;\n    }\n    if (taggedBech32) {\n      let a = await this.ndk?.fetchEvent(taggedBech32);\n      if (a) {\n        if (a.kind === 30023 /* Article */) {\n          a = NDKArticle.from(a);\n        }\n        this._article = a;\n      }\n    }\n    return this._article;\n  }\n};\n\n// src/utils/imeta.ts\nfunction mapImetaTag(tag) {\n  const data = {};\n  if (tag.length === 2) {\n    const parts = tag[1].split(\" \");\n    for (let i = 0; i < parts.length; i += 2) {\n      const key = parts[i];\n      const value = parts[i + 1];\n      if (key === \"fallback\") {\n        if (!data.fallback) data.fallback = [];\n        data.fallback.push(value);\n      } else {\n        data[key] = value;\n      }\n    }\n    return data;\n  }\n  const tags = tag.slice(1);\n  for (const val of tags) {\n    const parts = val.split(\" \");\n    const key = parts[0];\n    const value = parts.slice(1).join(\" \");\n    if (key === \"fallback\") {\n      if (!data.fallback) data.fallback = [];\n      data.fallback.push(value);\n    } else {\n      data[key] = value;\n    }\n  }\n  return data;\n}\nfunction imetaTagToTag(imeta) {\n  const tag = [\"imeta\"];\n  for (const [key, value] of Object.entries(imeta)) {\n    if (Array.isArray(value)) {\n      for (const v of value) {\n        tag.push(`${key} ${v}`);\n      }\n    } else if (value) {\n      tag.push(`${key} ${value}`);\n    }\n  }\n  return tag;\n}\n\n// src/events/kinds/image.ts\nvar NDKImage = class _NDKImage extends NDKEvent {\n  static kind = 20 /* Image */;\n  static kinds = [20 /* Image */];\n  _imetas;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 20 /* Image */;\n  }\n  /**\n   * Creates a NDKImage from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKImage from.\n   * @returns NDKImage\n   */\n  static from(event) {\n    return new _NDKImage(event.ndk, event.rawEvent());\n  }\n  get isValid() {\n    return this.imetas.length > 0;\n  }\n  get imetas() {\n    if (this._imetas) return this._imetas;\n    this._imetas = this.tags.filter((tag) => tag[0] === \"imeta\").map(mapImetaTag).filter((imeta) => !!imeta.url);\n    return this._imetas;\n  }\n  set imetas(tags) {\n    this._imetas = tags;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\");\n    this.tags.push(...tags.map(imetaTagToTag));\n  }\n};\n\n// src/events/kinds/lists/index.ts\nvar NDKList = class _NDKList extends NDKEvent {\n  _encryptedTags;\n  static kinds = [\n    10063 /* BlossomList */,\n    30001 /* CategorizedBookmarkList */,\n    10004 /* CommunityList */,\n    10050 /* DirectMessageReceiveRelayList */,\n    10030 /* EmojiList */,\n    10015 /* InterestList */,\n    10001 /* PinList */,\n    10002 /* RelayList */,\n    10007 /* SearchRelayList */,\n    10006 /* BlockRelayList */,\n    10003 /* BookmarkList */\n  ];\n  /**\n   * Stores the number of bytes the content was before decryption\n   * to expire the cache when the content changes.\n   */\n  encryptedTagsLength;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30001 /* CategorizedBookmarkList */;\n  }\n  /**\n   * Wrap a NDKEvent into a NDKList\n   */\n  static from(ndkEvent) {\n    return new _NDKList(ndkEvent.ndk, ndkEvent);\n  }\n  /**\n   * Returns the title of the list. Falls back on fetching the name tag value.\n   */\n  get title() {\n    const titleTag = this.tagValue(\"title\") || this.tagValue(\"name\");\n    if (titleTag) return titleTag;\n    if (this.kind === 3 /* Contacts */) {\n      return \"Contacts\";\n    }\n    if (this.kind === 1e4 /* MuteList */) {\n      return \"Mute\";\n    }\n    if (this.kind === 10001 /* PinList */) {\n      return \"Pinned Notes\";\n    }\n    if (this.kind === 10002 /* RelayList */) {\n      return \"Relay Metadata\";\n    }\n    if (this.kind === 10003 /* BookmarkList */) {\n      return \"Bookmarks\";\n    }\n    if (this.kind === 10004 /* CommunityList */) {\n      return \"Communities\";\n    }\n    if (this.kind === 10005 /* PublicChatList */) {\n      return \"Public Chats\";\n    }\n    if (this.kind === 10006 /* BlockRelayList */) {\n      return \"Blocked Relays\";\n    }\n    if (this.kind === 10007 /* SearchRelayList */) {\n      return \"Search Relays\";\n    }\n    if (this.kind === 10050 /* DirectMessageReceiveRelayList */) {\n      return \"Direct Message Receive Relays\";\n    }\n    if (this.kind === 10015 /* InterestList */) {\n      return \"Interests\";\n    }\n    if (this.kind === 10030 /* EmojiList */) {\n      return \"Emojis\";\n    }\n    return this.tagValue(\"d\");\n  }\n  /**\n   * Sets the title of the list.\n   */\n  set title(title) {\n    this.removeTag([\"title\", \"name\"]);\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Returns the name of the list.\n   * @deprecated Please use \"title\" instead.\n   */\n  get name() {\n    return this.title;\n  }\n  /**\n   * Sets the name of the list.\n   * @deprecated Please use \"title\" instead. This method will use the `title` tag instead.\n   */\n  set name(name) {\n    this.title = name;\n  }\n  /**\n   * Returns the description of the list.\n   */\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  /**\n   * Sets the description of the list.\n   */\n  set description(name) {\n    this.removeTag(\"description\");\n    if (name) this.tags.push([\"description\", name]);\n  }\n  /**\n   * Returns the image of the list.\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Sets the image of the list.\n   */\n  set image(name) {\n    this.removeTag(\"image\");\n    if (name) this.tags.push([\"image\", name]);\n  }\n  isEncryptedTagsCacheValid() {\n    return !!(this._encryptedTags && this.encryptedTagsLength === this.content.length);\n  }\n  /**\n   * Returns the decrypted content of the list.\n   */\n  async encryptedTags(useCache = true) {\n    if (useCache && this.isEncryptedTagsCacheValid()) return this._encryptedTags;\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    const user = await this.ndk.signer.user();\n    try {\n      if (this.content.length > 0) {\n        try {\n          const decryptedContent = await this.ndk.signer.decrypt(user, this.content);\n          const a = JSON.parse(decryptedContent);\n          if (a?.[0]) {\n            this.encryptedTagsLength = this.content.length;\n            return this._encryptedTags = a;\n          }\n          this.encryptedTagsLength = this.content.length;\n          return this._encryptedTags = [];\n        } catch (_e) {\n        }\n      }\n    } catch (_e) {\n    }\n    return [];\n  }\n  /**\n   * This method can be overriden to validate that a tag is valid for this list.\n   *\n   * (i.e. the NDKPersonList can validate that items are NDKUser instances)\n   */\n  validateTag(_tagValue) {\n    return true;\n  }\n  getItems(type) {\n    return this.tags.filter((tag) => tag[0] === type);\n  }\n  /**\n   * Returns the unecrypted items in this list.\n   */\n  get items() {\n    return this.tags.filter((t) => {\n      return ![\n        \"d\",\n        \"L\",\n        \"l\",\n        \"title\",\n        \"name\",\n        \"description\",\n        \"published_at\",\n        \"summary\",\n        \"image\",\n        \"thumb\",\n        \"alt\",\n        \"expiration\",\n        \"subject\",\n        \"client\"\n      ].includes(t[0]);\n    });\n  }\n  /**\n   * Adds a new item to the list.\n   * @param relay Relay to add\n   * @param mark Optional mark to add to the item\n   * @param encrypted Whether to encrypt the item\n   * @param position Where to add the item in the list (top or bottom)\n   */\n  async addItem(item, mark = void 0, encrypted = false, position = \"bottom\") {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    let tags;\n    if (item instanceof NDKEvent) {\n      tags = [item.tagReference(mark)];\n    } else if (item instanceof NDKUser) {\n      tags = item.referenceTags();\n    } else if (item instanceof NDKRelay) {\n      tags = item.referenceTags();\n    } else if (Array.isArray(item)) {\n      tags = [item];\n    } else {\n      throw new Error(\"Invalid object type\");\n    }\n    if (mark) tags[0].push(mark);\n    if (encrypted) {\n      const user = await this.ndk.signer.user();\n      const currentList = await this.encryptedTags();\n      if (position === \"top\") currentList.unshift(...tags);\n      else currentList.push(...tags);\n      this._encryptedTags = currentList;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(currentList);\n      await this.encrypt(user);\n    } else {\n      if (position === \"top\") this.tags.unshift(...tags);\n      else this.tags.push(...tags);\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n  }\n  /**\n   * Removes an item from the list from both the encrypted and unencrypted lists.\n   * @param value value of item to remove from the list\n   * @param publish whether to publish the change\n   * @returns\n   */\n  async removeItemByValue(value, publish = true) {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    const index = this.tags.findIndex((tag) => tag[1] === value);\n    if (index >= 0) {\n      this.tags.splice(index, 1);\n    }\n    const user = await this.ndk.signer.user();\n    const encryptedTags = await this.encryptedTags();\n    const encryptedIndex = encryptedTags.findIndex((tag) => tag[1] === value);\n    if (encryptedIndex >= 0) {\n      encryptedTags.splice(encryptedIndex, 1);\n      this._encryptedTags = encryptedTags;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(encryptedTags);\n      await this.encrypt(user);\n    }\n    if (publish) {\n      return this.publishReplaceable();\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n  }\n  /**\n   * Removes an item from the list.\n   *\n   * @param index The index of the item to remove.\n   * @param encrypted Whether to remove from the encrypted list or not.\n   */\n  async removeItem(index, encrypted) {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    if (encrypted) {\n      const user = await this.ndk.signer.user();\n      const currentList = await this.encryptedTags();\n      currentList.splice(index, 1);\n      this._encryptedTags = currentList;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(currentList);\n      await this.encrypt(user);\n    } else {\n      this.tags.splice(index, 1);\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n    return this;\n  }\n  has(item) {\n    return this.items.some((tag) => tag[1] === item);\n  }\n  /**\n   * Creates a filter that will result in fetching\n   * the items of this list\n   * @example\n   * const list = new NDKList(...);\n   * const filters = list.filterForItems();\n   * const events = await ndk.fetchEvents(filters);\n   */\n  filterForItems() {\n    const ids = /* @__PURE__ */ new Set();\n    const nip33Queries = /* @__PURE__ */ new Map();\n    const filters = [];\n    for (const tag of this.items) {\n      if (tag[0] === \"e\" && tag[1]) {\n        ids.add(tag[1]);\n      } else if (tag[0] === \"a\" && tag[1]) {\n        const [kind, pubkey, dTag] = tag[1].split(\":\");\n        if (!kind || !pubkey) continue;\n        const key = `${kind}:${pubkey}`;\n        const item = nip33Queries.get(key) || [];\n        item.push(dTag || \"\");\n        nip33Queries.set(key, item);\n      }\n    }\n    if (ids.size > 0) {\n      filters.push({ ids: Array.from(ids) });\n    }\n    if (nip33Queries.size > 0) {\n      for (const [key, values] of nip33Queries.entries()) {\n        const [kind, pubkey] = key.split(\":\");\n        filters.push({\n          kinds: [Number.parseInt(kind)],\n          authors: [pubkey],\n          \"#d\": values\n        });\n      }\n    }\n    return filters;\n  }\n};\nvar lists_default = NDKList;\n\n// src/events/kinds/nutzap/index.ts\n\nvar NDKNutzap = class _NDKNutzap extends NDKEvent {\n  debug;\n  _proofs = [];\n  static kind = 9321 /* Nutzap */;\n  static kinds = [_NDKNutzap.kind];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 9321 /* Nutzap */;\n    this.debug = ndk?.debug.extend(\"nutzap\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:nutzap\");\n    if (!this.alt) this.alt = \"This is a nutzap\";\n    try {\n      const proofTags = this.getMatchingTags(\"proof\");\n      if (proofTags.length) {\n        this._proofs = proofTags.map((tag) => JSON.parse(tag[1]));\n      } else {\n        this._proofs = JSON.parse(this.content);\n      }\n    } catch {\n      return;\n    }\n  }\n  static from(event) {\n    const e = new _NDKNutzap(event.ndk, event);\n    if (!e._proofs || !e._proofs.length) return;\n    return e;\n  }\n  set comment(comment) {\n    this.content = comment ?? \"\";\n  }\n  get comment() {\n    const c = this.tagValue(\"comment\");\n    if (c) return c;\n    return this.content;\n  }\n  set proofs(proofs) {\n    this._proofs = proofs;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"proof\");\n    for (const proof of proofs) {\n      this.tags.push([\"proof\", JSON.stringify(proof)]);\n    }\n  }\n  get proofs() {\n    return this._proofs;\n  }\n  get rawP2pk() {\n    const firstProof = this.proofs[0];\n    try {\n      const secret = JSON.parse(firstProof.secret);\n      let payload;\n      if (typeof secret === \"string\") {\n        payload = JSON.parse(secret);\n        this.debug(\"stringified payload\", firstProof.secret);\n      } else if (typeof secret === \"object\") {\n        payload = secret;\n      }\n      if (Array.isArray(payload) && payload[0] === \"P2PK\" && payload.length > 1 && typeof payload[1] === \"object\" && payload[1] !== null) {\n        return payload[1].data;\n      }\n      if (typeof payload === \"object\" && payload !== null && typeof payload[1]?.data === \"string\") {\n        return payload[1].data;\n      }\n    } catch (e) {\n      this.debug(\"error parsing p2pk pubkey\", e, this.proofs[0]);\n    }\n    return void 0;\n  }\n  /**\n   * Gets the p2pk pubkey that is embedded in the first proof.\n   *\n   * Note that this returns a nostr pubkey, not a cashu pubkey (no \"02\" prefix)\n   */\n  get p2pk() {\n    const rawP2pk = this.rawP2pk;\n    if (!rawP2pk) return;\n    return rawP2pk.startsWith(\"02\") ? rawP2pk.slice(2) : rawP2pk;\n  }\n  /**\n   * Get the mint where this nutzap proofs exist\n   */\n  get mint() {\n    return this.tagValue(\"u\");\n  }\n  set mint(value) {\n    this.replaceTag([\"u\", value]);\n  }\n  get unit() {\n    let _unit = this.tagValue(\"unit\") ?? \"sat\";\n    if (_unit?.startsWith(\"msat\")) _unit = \"sat\";\n    return _unit;\n  }\n  set unit(value) {\n    this.removeTag(\"unit\");\n    if (value?.startsWith(\"msat\")) throw new Error(\"msat is not allowed, use sat denomination instead\");\n    if (value) this.tag([\"unit\", value]);\n  }\n  get amount() {\n    const amount = this.proofs.reduce((total, proof) => total + proof.amount, 0);\n    return amount;\n  }\n  sender = this.author;\n  /**\n   * Set the target of the nutzap\n   * @param target The target of the nutzap (a user or an event)\n   */\n  set target(target) {\n    this.tags = this.tags.filter((t) => t[0] !== \"p\");\n    if (target instanceof NDKEvent) {\n      this.tags.push(target.tagReference());\n    }\n  }\n  set recipientPubkey(pubkey) {\n    this.removeTag(\"p\");\n    this.tag([\"p\", pubkey]);\n  }\n  get recipientPubkey() {\n    return this.tagValue(\"p\");\n  }\n  get recipient() {\n    const pubkey = this.recipientPubkey;\n    if (this.ndk) return this.ndk.getUser({ pubkey });\n    return new NDKUser({ pubkey });\n  }\n  async toNostrEvent() {\n    if (this.unit === \"msat\") {\n      this.unit = \"sat\";\n    }\n    this.removeTag(\"amount\");\n    this.tags.push([\"amount\", this.amount.toString()]);\n    const event = await super.toNostrEvent();\n    event.content = this.comment;\n    return event;\n  }\n  /**\n   * Validates that the nutzap conforms to NIP-61\n   */\n  get isValid() {\n    let eTagCount = 0;\n    let pTagCount = 0;\n    let mintTagCount = 0;\n    for (const tag of this.tags) {\n      if (tag[0] === \"e\") eTagCount++;\n      if (tag[0] === \"p\") pTagCount++;\n      if (tag[0] === \"u\") mintTagCount++;\n    }\n    return (\n      // exactly one recipient and mint\n      pTagCount === 1 && mintTagCount === 1 && // must have at most one e tag\n      eTagCount <= 1 && // must have at least one proof\n      this.proofs.length > 0\n    );\n  }\n};\nfunction proofP2pk(proof) {\n  try {\n    const secret = JSON.parse(proof.secret);\n    let payload = {};\n    if (typeof secret === \"string\") {\n      payload = JSON.parse(secret);\n    } else if (typeof secret === \"object\") {\n      payload = secret;\n    }\n    const isP2PKLocked = payload[0] === \"P2PK\" && payload[1]?.data;\n    if (isP2PKLocked) {\n      return payload[1].data;\n    }\n  } catch (e) {\n    console.error(\"error parsing p2pk pubkey\", e, proof);\n  }\n}\nfunction proofP2pkNostr(proof) {\n  const p2pk = proofP2pk(proof);\n  if (!p2pk) return;\n  if (p2pk.startsWith(\"02\") && p2pk.length === 66) return p2pk.slice(2);\n  return p2pk;\n}\nfunction cashuPubkeyToNostrPubkey(cashuPubkey) {\n  if (cashuPubkey.startsWith(\"02\") && cashuPubkey.length === 66) return cashuPubkey.slice(2);\n  return void 0;\n}\n\n// src/events/kinds/simple-group/member-list.ts\nvar NDKSimpleGroupMemberList = class _NDKSimpleGroupMemberList extends NDKEvent {\n  relaySet;\n  memberSet = /* @__PURE__ */ new Set();\n  static kind = 39002 /* GroupMembers */;\n  static kinds = [39002 /* GroupMembers */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39002 /* GroupMembers */;\n    this.memberSet = new Set(this.members);\n  }\n  static from(event) {\n    return new _NDKSimpleGroupMemberList(event.ndk, event);\n  }\n  get members() {\n    return this.getMatchingTags(\"p\").map((tag) => tag[1]);\n  }\n  hasMember(member) {\n    return this.memberSet.has(member);\n  }\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    relaySet ??= this.relaySet;\n    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/events/kinds/simple-group/metadata.ts\nvar NDKSimpleGroupMetadata = class _NDKSimpleGroupMetadata extends NDKEvent {\n  static kind = 39e3 /* GroupMetadata */;\n  static kinds = [39e3 /* GroupMetadata */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39e3 /* GroupMetadata */;\n  }\n  static from(event) {\n    return new _NDKSimpleGroupMetadata(event.ndk, event);\n  }\n  get name() {\n    return this.tagValue(\"name\");\n  }\n  get picture() {\n    return this.tagValue(\"picture\");\n  }\n  get about() {\n    return this.tagValue(\"about\");\n  }\n  get scope() {\n    if (this.getMatchingTags(\"public\").length > 0) return \"public\";\n    if (this.getMatchingTags(\"public\").length > 0) return \"private\";\n    return void 0;\n  }\n  set scope(scope) {\n    this.removeTag(\"public\");\n    this.removeTag(\"private\");\n    if (scope === \"public\") {\n      this.tags.push([\"public\", \"\"]);\n    } else if (scope === \"private\") {\n      this.tags.push([\"private\", \"\"]);\n    }\n  }\n  get access() {\n    if (this.getMatchingTags(\"open\").length > 0) return \"open\";\n    if (this.getMatchingTags(\"closed\").length > 0) return \"closed\";\n    return void 0;\n  }\n  set access(access) {\n    this.removeTag(\"open\");\n    this.removeTag(\"closed\");\n    if (access === \"open\") {\n      this.tags.push([\"open\", \"\"]);\n    } else if (access === \"closed\") {\n      this.tags.push([\"closed\", \"\"]);\n    }\n  }\n};\n\n// src/events/kinds/story.ts\nvar NDKStoryStickerType = /* @__PURE__ */ ((NDKStoryStickerType2) => {\n  NDKStoryStickerType2[\"Pubkey\"] = \"pubkey\";\n  NDKStoryStickerType2[\"Event\"] = \"event\";\n  NDKStoryStickerType2[\"Prompt\"] = \"prompt\";\n  NDKStoryStickerType2[\"Text\"] = \"text\";\n  NDKStoryStickerType2[\"Countdown\"] = \"countdown\";\n  return NDKStoryStickerType2;\n})(NDKStoryStickerType || {});\nfunction strToPosition(positionStr) {\n  const [x, y] = positionStr.split(\",\").map(Number);\n  return { x, y };\n}\nfunction strToDimension(dimensionStr) {\n  const [width, height] = dimensionStr.split(\"x\").map(Number);\n  return { width, height };\n}\nvar NDKStorySticker = class _NDKStorySticker {\n  static Text = \"text\" /* Text */;\n  static Pubkey = \"pubkey\" /* Pubkey */;\n  static Event = \"event\" /* Event */;\n  static Prompt = \"prompt\" /* Prompt */;\n  static Countdown = \"countdown\" /* Countdown */;\n  type;\n  value;\n  position;\n  dimension;\n  properties;\n  constructor(arg) {\n    if (Array.isArray(arg)) {\n      const tag = arg;\n      if (tag[0] !== \"sticker\" || tag.length < 5) {\n        throw new Error(\"Invalid sticker tag\");\n      }\n      this.type = tag[1];\n      this.value = tag[2];\n      this.position = strToPosition(tag[3]);\n      this.dimension = strToDimension(tag[4]);\n      const props = {};\n      for (let i = 5; i < tag.length; i++) {\n        const [key, ...rest] = tag[i].split(\" \");\n        props[key] = rest.join(\" \");\n      }\n      if (Object.keys(props).length > 0) {\n        this.properties = props;\n      }\n    } else {\n      this.type = arg;\n      this.value = void 0;\n      this.position = { x: 0, y: 0 };\n      this.dimension = { width: 0, height: 0 };\n    }\n  }\n  static fromTag(tag) {\n    try {\n      return new _NDKStorySticker(tag);\n    } catch {\n      return null;\n    }\n  }\n  get style() {\n    return this.properties?.style;\n  }\n  set style(style) {\n    if (style) this.properties = { ...this.properties, style };\n    else delete this.properties?.style;\n  }\n  get rotation() {\n    return this.properties?.rot ? Number.parseFloat(this.properties.rot) : void 0;\n  }\n  set rotation(rotation) {\n    if (rotation !== void 0) {\n      this.properties = { ...this.properties, rot: rotation.toString() };\n    } else {\n      delete this.properties?.rot;\n    }\n  }\n  /**\n   * Checks if the sticker is valid.\n   *\n   * @returns {boolean} - True if the sticker is valid, false otherwise.\n   */\n  get isValid() {\n    return this.hasValidDimensions() && this.hasValidPosition();\n  }\n  hasValidDimensions = () => {\n    return typeof this.dimension.width === \"number\" && typeof this.dimension.height === \"number\" && !Number.isNaN(this.dimension.width) && !Number.isNaN(this.dimension.height);\n  };\n  hasValidPosition = () => {\n    return typeof this.position.x === \"number\" && typeof this.position.y === \"number\" && !Number.isNaN(this.position.x) && !Number.isNaN(this.position.y);\n  };\n  toTag() {\n    if (!this.isValid) {\n      const errors = [\n        !this.hasValidDimensions() ? \"dimensions is invalid\" : void 0,\n        !this.hasValidPosition() ? \"position is invalid\" : void 0\n      ].filter(Boolean);\n      throw new Error(`Invalid sticker: ${errors.join(\", \")}`);\n    }\n    let value;\n    switch (this.type) {\n      case \"event\" /* Event */:\n        value = this.value.tagId();\n        break;\n      case \"pubkey\" /* Pubkey */:\n        value = this.value.pubkey;\n        break;\n      default:\n        value = this.value;\n    }\n    const tag = [\"sticker\", this.type, value, coordinates(this.position), dimension(this.dimension)];\n    if (this.properties) {\n      for (const [key, propValue] of Object.entries(this.properties)) {\n        tag.push(`${key} ${propValue}`);\n      }\n    }\n    return tag;\n  }\n};\nvar NDKStory = class _NDKStory extends NDKEvent {\n  static kind = 23 /* Story */;\n  static kinds = [23 /* Story */];\n  _imeta;\n  _dimensions;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 23 /* Story */;\n    if (rawEvent) {\n      for (const tag of rawEvent.tags) {\n        switch (tag[0]) {\n          case \"imeta\":\n            this._imeta = mapImetaTag(tag);\n            break;\n          case \"dim\":\n            this.dimensions = strToDimension(tag[1]);\n            break;\n        }\n      }\n    }\n  }\n  /**\n   * Creates a NDKStory from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKStory from.\n   * @returns NDKStory\n   */\n  static from(event) {\n    return new _NDKStory(event.ndk, event);\n  }\n  /**\n   * Checks if the story is valid (has exactly one imeta tag).\n   */\n  get isValid() {\n    return !!this.imeta;\n  }\n  /**\n   * Gets the first imeta tag (there should only be one).\n   */\n  get imeta() {\n    return this._imeta;\n  }\n  /**\n   * Sets a single imeta tag, replacing any existing ones.\n   */\n  set imeta(tag) {\n    this._imeta = tag;\n    this.tags = this.tags.filter((t) => t[0] !== \"imeta\");\n    if (tag) {\n      this.tags.push(imetaTagToTag(tag));\n    }\n  }\n  /**\n   * Getter for the story dimensions.\n   *\n   * @returns {NDKStoryDimension | undefined} - The story dimensions if available, otherwise undefined.\n   */\n  get dimensions() {\n    const dimTag = this.tagValue(\"dim\");\n    if (!dimTag) return void 0;\n    return strToDimension(dimTag);\n  }\n  /**\n   * Setter for the story dimensions.\n   *\n   * @param {NDKStoryDimension | undefined} dimensions - The dimensions to set for the story.\n   */\n  set dimensions(dimensions) {\n    this.removeTag(\"dim\");\n    if (dimensions) {\n      this.tags.push([\"dim\", `${dimensions.width}x${dimensions.height}`]);\n    }\n  }\n  /**\n   * Getter for the story duration.\n   *\n   * @returns {number | undefined} - The story duration in seconds if available, otherwise undefined.\n   */\n  get duration() {\n    const durTag = this.tagValue(\"dur\");\n    if (!durTag) return void 0;\n    return Number.parseInt(durTag);\n  }\n  /**\n   * Setter for the story duration.\n   *\n   * @param {number | undefined} duration - The duration in seconds to set for the story.\n   */\n  set duration(duration) {\n    this.removeTag(\"dur\");\n    if (duration !== void 0) {\n      this.tags.push([\"dur\", duration.toString()]);\n    }\n  }\n  /**\n   * Gets all stickers from the story.\n   *\n   * @returns {NDKStorySticker[]} - Array of stickers in the story.\n   */\n  get stickers() {\n    const stickers = [];\n    for (const tag of this.tags) {\n      if (tag[0] !== \"sticker\" || tag.length < 5) continue;\n      const sticker = NDKStorySticker.fromTag(tag);\n      if (sticker) stickers.push(sticker);\n    }\n    return stickers;\n  }\n  /**\n   * Adds a sticker to the story.\n   *\n   * @param {NDKStorySticker|StorySticker} sticker - The sticker to add.\n   */\n  addSticker(sticker) {\n    let stickerToAdd;\n    if (sticker instanceof NDKStorySticker) {\n      stickerToAdd = sticker;\n    } else {\n      const tag = [\n        \"sticker\",\n        sticker.type,\n        typeof sticker.value === \"string\" ? sticker.value : \"\",\n        coordinates(sticker.position),\n        dimension(sticker.dimension)\n      ];\n      if (sticker.properties) {\n        for (const [key, value] of Object.entries(sticker.properties)) {\n          tag.push(`${key} ${value}`);\n        }\n      }\n      stickerToAdd = new NDKStorySticker(tag);\n      stickerToAdd.value = sticker.value;\n    }\n    if (stickerToAdd.type === \"pubkey\" /* Pubkey */) {\n      this.tag(stickerToAdd.value);\n    } else if (stickerToAdd.type === \"event\" /* Event */) {\n      this.tag(stickerToAdd.value);\n    }\n    this.tags.push(stickerToAdd.toTag());\n  }\n  /**\n   * Removes a sticker from the story.\n   *\n   * @param {number} index - The index of the sticker to remove.\n   */\n  removeSticker(index) {\n    const stickers = this.stickers;\n    if (index < 0 || index >= stickers.length) return;\n    let stickerCount = 0;\n    for (let i = 0; i < this.tags.length; i++) {\n      if (this.tags[i][0] === \"sticker\") {\n        if (stickerCount === index) {\n          this.tags.splice(i, 1);\n          break;\n        }\n        stickerCount++;\n      }\n    }\n  }\n};\nvar coordinates = (position) => `${position.x},${position.y}`;\nvar dimension = (dimension2) => `${dimension2.width}x${dimension2.height}`;\n\n// src/events/kinds/subscriptions/amount.ts\nvar possibleIntervalFrequencies = [\n  \"daily\",\n  \"weekly\",\n  \"monthly\",\n  \"quarterly\",\n  \"yearly\"\n];\nfunction calculateTermDurationInSeconds(term) {\n  switch (term) {\n    case \"daily\":\n      return 24 * 60 * 60;\n    case \"weekly\":\n      return 7 * 24 * 60 * 60;\n    case \"monthly\":\n      return 30 * 24 * 60 * 60;\n    case \"quarterly\":\n      return 3 * 30 * 24 * 60 * 60;\n    case \"yearly\":\n      return 365 * 24 * 60 * 60;\n  }\n}\nfunction newAmount(amount, currency, term) {\n  return [\"amount\", amount.toString(), currency, term];\n}\nfunction parseTagToSubscriptionAmount(tag) {\n  const amount = Number.parseInt(tag[1]);\n  if (Number.isNaN(amount) || amount === void 0 || amount === null || amount <= 0) return void 0;\n  const currency = tag[2];\n  if (currency === void 0 || currency === \"\") return void 0;\n  const term = tag[3];\n  if (term === void 0) return void 0;\n  if (!possibleIntervalFrequencies.includes(term)) return void 0;\n  return {\n    amount,\n    currency,\n    term\n  };\n}\n\n// src/events/kinds/subscriptions/tier.ts\nvar NDKSubscriptionTier = class _NDKSubscriptionTier extends NDKArticle {\n  static kind = 37001 /* SubscriptionTier */;\n  static kinds = [37001 /* SubscriptionTier */];\n  constructor(ndk, rawEvent) {\n    const k = rawEvent?.kind ?? 37001 /* SubscriptionTier */;\n    super(ndk, rawEvent);\n    this.kind = k;\n  }\n  /**\n   * Creates a new NDKSubscriptionTier from an event\n   * @param event\n   * @returns NDKSubscriptionTier\n   */\n  static from(event) {\n    return new _NDKSubscriptionTier(event.ndk, event);\n  }\n  /**\n   * Returns perks for this tier\n   */\n  get perks() {\n    return this.getMatchingTags(\"perk\").map((tag) => tag[1]).filter((perk) => perk !== void 0);\n  }\n  /**\n   * Adds a perk to this tier\n   */\n  addPerk(perk) {\n    this.tags.push([\"perk\", perk]);\n  }\n  /**\n   * Returns the amount for this tier\n   */\n  get amounts() {\n    return this.getMatchingTags(\"amount\").map((tag) => parseTagToSubscriptionAmount(tag)).filter((a) => a !== void 0);\n  }\n  /**\n   * Adds an amount to this tier\n   * @param amount Amount in the smallest unit of the currency (e.g. cents, msats)\n   * @param currency Currency code. Use msat for millisatoshis\n   * @param term One of daily, weekly, monthly, quarterly, yearly\n   */\n  addAmount(amount, currency, term) {\n    this.tags.push(newAmount(amount, currency, term));\n  }\n  /**\n   * Sets a relay where content related to this tier can be found\n   * @param relayUrl URL of the relay\n   */\n  set relayUrl(relayUrl) {\n    this.tags.push([\"r\", relayUrl]);\n  }\n  /**\n   * Returns the relay URLs for this tier\n   */\n  get relayUrls() {\n    return this.getMatchingTags(\"r\").map((tag) => tag[1]).filter((relay) => relay !== void 0);\n  }\n  /**\n   * Gets the verifier pubkey for this tier. This is the pubkey that will generate\n   * subscription payment receipts\n   */\n  get verifierPubkey() {\n    return this.tagValue(\"p\");\n  }\n  /**\n   * Sets the verifier pubkey for this tier.\n   */\n  set verifierPubkey(pubkey) {\n    this.removeTag(\"p\");\n    if (pubkey) this.tags.push([\"p\", pubkey]);\n  }\n  /**\n   * Checks if this tier is valid\n   */\n  get isValid() {\n    return this.title !== void 0 && // Must have a title\n    this.amounts.length > 0;\n  }\n};\n\n// src/events/kinds/video.ts\nvar NDKVideo = class _NDKVideo extends NDKEvent {\n  static kind = 21 /* Video */;\n  static kinds = [34235 /* HorizontalVideo */, 34236 /* VerticalVideo */, 22 /* ShortVideo */, 21 /* Video */];\n  _imetas;\n  /**\n   * Creates a NDKArticle from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKArticle from.\n   * @returns NDKArticle\n   */\n  static from(event) {\n    return new _NDKVideo(event.ndk, event.rawEvent());\n  }\n  /**\n   * Getter for the article title.\n   *\n   * @returns {string | undefined} - The article title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the article title.\n   *\n   * @param {string | undefined} title - The title to set for the article.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the article thumbnail.\n   *\n   * @returns {string | undefined} - The article thumbnail if available, otherwise undefined.\n   */\n  get thumbnail() {\n    let thumbnail;\n    if (this.imetas && this.imetas.length > 0) {\n      thumbnail = this.imetas[0].image?.[0];\n    }\n    return thumbnail ?? this.tagValue(\"thumb\");\n  }\n  get imetas() {\n    if (this._imetas) return this._imetas;\n    this._imetas = this.tags.filter((tag) => tag[0] === \"imeta\").map(mapImetaTag);\n    return this._imetas;\n  }\n  set imetas(tags) {\n    this._imetas = tags;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\");\n    this.tags.push(...tags.map(imetaTagToTag));\n  }\n  get url() {\n    if (this.imetas && this.imetas.length > 0) {\n      return this.imetas[0].url;\n    }\n    return this.tagValue(\"url\");\n  }\n  /**\n   * Getter for the article's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      return Number.parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Generates content tags for the article.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.kind) {\n      if (this.imetas?.[0]?.dim) {\n        const [width, height] = this.imetas[0].dim.split(\"x\");\n        const isPortrait = width && height && Number.parseInt(width) < Number.parseInt(height);\n        const isShort = this.duration && this.duration < 120;\n        if (isShort && isPortrait) this.kind = 22 /* ShortVideo */;\n        else this.kind = 21 /* Video */;\n      }\n    }\n    return super.generateTags();\n  }\n  get duration() {\n    const tag = this.tagValue(\"duration\");\n    if (tag) {\n      return Number.parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the video's duration\n   *\n   * @param {number | undefined} duration - The duration to set for the video (in seconds)\n   */\n  set duration(dur) {\n    this.removeTag(\"duration\");\n    if (dur !== void 0) {\n      this.tags.push([\"duration\", Math.floor(dur).toString()]);\n    }\n  }\n};\n\n// src/events/kinds/wiki.ts\nvar NDKWiki = class extends NDKArticle {\n  static kind = 30818 /* Wiki */;\n  static kinds = [30818 /* Wiki */];\n};\n\n// src/events/wrap.ts\nfunction wrapEvent(event) {\n  const eventWrappingMap = /* @__PURE__ */ new Map();\n  for (const klass2 of [\n    NDKImage,\n    NDKVideo,\n    NDKCashuMintList,\n    NDKArticle,\n    NDKHighlight,\n    NDKWiki,\n    NDKNutzap,\n    NDKSimpleGroupMemberList,\n    NDKSimpleGroupMetadata,\n    NDKSubscriptionTier,\n    NDKCashuToken,\n    NDKList,\n    NDKStory\n  ]) {\n    for (const kind of klass2.kinds) {\n      eventWrappingMap.set(kind, klass2);\n    }\n  }\n  const klass = eventWrappingMap.get(event.kind);\n  if (klass) return klass.from(event);\n  return event;\n}\n\n// src/subscription/utils.ts\n\nvar MAX_SUBID_LENGTH = 20;\nfunction queryFullyFilled(subscription) {\n  if (filterIncludesIds(subscription.filter)) {\n    if (resultHasAllRequestedIds(subscription)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction compareFilter(filter1, filter2) {\n  if (Object.keys(filter1).length !== Object.keys(filter2).length) return false;\n  for (const [key, value] of Object.entries(filter1)) {\n    const valuesInFilter2 = filter2[key];\n    if (!valuesInFilter2) return false;\n    if (Array.isArray(value) && Array.isArray(valuesInFilter2)) {\n      const v = value;\n      for (const valueInFilter2 of valuesInFilter2) {\n        const val = valueInFilter2;\n        if (!v.includes(val)) {\n          return false;\n        }\n      }\n    } else {\n      if (valuesInFilter2 !== value) return false;\n    }\n  }\n  return true;\n}\nfunction filterIncludesIds(filter) {\n  return !!filter.ids;\n}\nfunction resultHasAllRequestedIds(subscription) {\n  const ids = subscription.filter.ids;\n  return !!ids && ids.length === subscription.eventFirstSeen.size;\n}\nfunction generateSubId(subscriptions, filters) {\n  const subIds = subscriptions.map((sub) => sub.subId).filter(Boolean);\n  const subIdParts = [];\n  const filterNonKindKeys = /* @__PURE__ */ new Set();\n  const filterKinds = /* @__PURE__ */ new Set();\n  if (subIds.length > 0) {\n    subIdParts.push(Array.from(new Set(subIds)).join(\",\"));\n  } else {\n    for (const filter of filters) {\n      for (const key of Object.keys(filter)) {\n        if (key === \"kinds\") {\n          filter.kinds?.forEach((k) => filterKinds.add(k));\n        } else {\n          filterNonKindKeys.add(key);\n        }\n      }\n    }\n    if (filterKinds.size > 0) {\n      subIdParts.push(`kinds:${Array.from(filterKinds).join(\",\")}`);\n    }\n    if (filterNonKindKeys.size > 0) {\n      subIdParts.push(Array.from(filterNonKindKeys).join(\",\"));\n    }\n  }\n  let subId = subIdParts.join(\"-\");\n  if (subId.length > MAX_SUBID_LENGTH) subId = subId.substring(0, MAX_SUBID_LENGTH);\n  subId += `-${Math.floor(Math.random() * 999).toString()}`;\n  return subId;\n}\nfunction filterForEventsTaggingId(id) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(id);\n    switch (decoded.type) {\n      case \"naddr\":\n        return {\n          \"#a\": [`${decoded.data.kind}:${decoded.data.pubkey}:${decoded.data.identifier}`]\n        };\n      case \"nevent\":\n        return { \"#e\": [decoded.data.id] };\n      case \"note\":\n        return { \"#e\": [decoded.data] };\n      case \"nprofile\":\n        return { \"#p\": [decoded.data.pubkey] };\n      case \"npub\":\n        return { \"#p\": [decoded.data] };\n    }\n  } catch {\n  }\n}\nfunction filterAndRelaySetFromBech32(beche2, ndk) {\n  const filter = filterFromId(beche2);\n  const relays = relaysFromBech32(beche2, ndk);\n  if (relays.length === 0) return { filter };\n  return {\n    filter,\n    relaySet: new NDKRelaySet(new Set(relays), ndk)\n  };\n}\nfunction filterFromId(id) {\n  let decoded;\n  if (id.match(NIP33_A_REGEX)) {\n    const [kind, pubkey, identifier] = id.split(\":\");\n    const filter = {\n      authors: [pubkey],\n      kinds: [Number.parseInt(kind)]\n    };\n    if (identifier) {\n      filter[\"#d\"] = [identifier];\n    }\n    return filter;\n  }\n  if (id.match(BECH32_REGEX)) {\n    try {\n      decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(id);\n      switch (decoded.type) {\n        case \"nevent\": {\n          const filter = { ids: [decoded.data.id] };\n          if (decoded.data.author) filter.authors = [decoded.data.author];\n          if (decoded.data.kind) filter.kinds = [decoded.data.kind];\n          return filter;\n        }\n        case \"note\":\n          return { ids: [decoded.data] };\n        case \"naddr\": {\n          const filter = {\n            authors: [decoded.data.pubkey],\n            kinds: [decoded.data.kind]\n          };\n          if (decoded.data.identifier) filter[\"#d\"] = [decoded.data.identifier];\n          return filter;\n        }\n      }\n    } catch (e) {\n      console.error(\"Error decoding\", id, e);\n    }\n  }\n  return { ids: [id] };\n}\nfunction isNip33AValue(value) {\n  return value.match(NIP33_A_REGEX) !== null;\n}\nvar NIP33_A_REGEX = /^(\\d+):([0-9A-Fa-f]+)(?::(.*))?$/;\nvar BECH32_REGEX = /^n(event|ote|profile|pub|addr)1[\\d\\w]+$/;\nfunction relaysFromBech32(bech322, ndk) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(bech322);\n    if ([\"naddr\", \"nevent\"].includes(decoded?.type)) {\n      const data = decoded.data;\n      if (data?.relays) {\n        return data.relays.map((r) => new NDKRelay(r, ndk.relayAuthDefaultPolicy, ndk));\n      }\n    }\n  } catch (_e) {\n  }\n  return [];\n}\n\n// src/subscription/index.ts\nvar NDKSubscriptionCacheUsage = /* @__PURE__ */ ((NDKSubscriptionCacheUsage2) => {\n  NDKSubscriptionCacheUsage2[\"ONLY_CACHE\"] = \"ONLY_CACHE\";\n  NDKSubscriptionCacheUsage2[\"CACHE_FIRST\"] = \"CACHE_FIRST\";\n  NDKSubscriptionCacheUsage2[\"PARALLEL\"] = \"PARALLEL\";\n  NDKSubscriptionCacheUsage2[\"ONLY_RELAY\"] = \"ONLY_RELAY\";\n  return NDKSubscriptionCacheUsage2;\n})(NDKSubscriptionCacheUsage || {});\nvar defaultOpts = {\n  closeOnEose: false,\n  cacheUsage: \"CACHE_FIRST\" /* CACHE_FIRST */,\n  dontSaveToCache: false,\n  groupable: true,\n  groupableDelay: 100,\n  groupableDelayType: \"at-most\",\n  cacheUnconstrainFilter: [\"limit\", \"since\", \"until\"]\n};\nvar NDKSubscription = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  subId;\n  filters;\n  opts;\n  pool;\n  skipVerification = false;\n  skipValidation = false;\n  /**\n   * Tracks the filters as they are executed on each relay\n   */\n  relayFilters;\n  relaySet;\n  ndk;\n  debug;\n  /**\n   * Events that have been seen by the subscription, with the time they were first seen.\n   */\n  eventFirstSeen = /* @__PURE__ */ new Map();\n  /**\n   * Relays that have sent an EOSE.\n   */\n  eosesSeen = /* @__PURE__ */ new Set();\n  /**\n   * The time the last event was received by the subscription.\n   * This is used to calculate when EOSE should be emitted.\n   */\n  lastEventReceivedAt;\n  /**\n   * The most recent event timestamp from cache results.\n   * This is used for addSinceFromCache functionality.\n   */\n  mostRecentCacheEventTimestamp;\n  internalId;\n  /**\n   * Whether the subscription should close when all relays have reached the end of the event stream.\n   */\n  closeOnEose;\n  /**\n   * Pool monitor callback\n   */\n  poolMonitor;\n  skipOptimisticPublishEvent = false;\n  /**\n   * Filters to remove when querying the cache.\n   */\n  cacheUnconstrainFilter;\n  constructor(ndk, filters, opts, subId) {\n    super();\n    this.ndk = ndk;\n    this.opts = { ...defaultOpts, ...opts || {} };\n    this.pool = this.opts.pool || ndk.pool;\n    this.filters = Array.isArray(filters) ? filters : [filters];\n    this.subId = subId || this.opts.subId;\n    this.internalId = Math.random().toString(36).substring(7);\n    this.debug = ndk.debug.extend(`subscription[${this.opts.subId ?? this.internalId}]`);\n    if (this.opts.relaySet) {\n      this.relaySet = this.opts.relaySet;\n    } else if (this.opts.relayUrls) {\n      this.relaySet = NDKRelaySet.fromRelayUrls(this.opts.relayUrls, this.ndk);\n    }\n    this.skipVerification = this.opts.skipVerification || false;\n    this.skipValidation = this.opts.skipValidation || false;\n    this.closeOnEose = this.opts.closeOnEose || false;\n    this.skipOptimisticPublishEvent = this.opts.skipOptimisticPublishEvent || false;\n    this.cacheUnconstrainFilter = this.opts.cacheUnconstrainFilter;\n  }\n  /**\n   * Returns the relays that have not yet sent an EOSE.\n   */\n  relaysMissingEose() {\n    if (!this.relayFilters) return [];\n    const relaysMissingEose = Array.from(this.relayFilters?.keys()).filter(\n      (url) => !this.eosesSeen.has(this.pool.getRelay(url, false, false))\n    );\n    return relaysMissingEose;\n  }\n  /**\n   * Provides access to the first filter of the subscription for\n   * backwards compatibility.\n   */\n  get filter() {\n    return this.filters[0];\n  }\n  get groupableDelay() {\n    if (!this.isGroupable()) return void 0;\n    return this.opts?.groupableDelay;\n  }\n  get groupableDelayType() {\n    return this.opts?.groupableDelayType || \"at-most\";\n  }\n  isGroupable() {\n    return this.opts?.groupable || false;\n  }\n  shouldQueryCache() {\n    if (this.opts.addSinceFromCache) return true;\n    if (this.opts?.cacheUsage === \"ONLY_RELAY\" /* ONLY_RELAY */) return false;\n    const hasNonEphemeralKind = this.filters.some((f) => f.kinds?.some((k) => kindIsEphemeral(k)));\n    if (hasNonEphemeralKind) return true;\n    return true;\n  }\n  shouldQueryRelays() {\n    return this.opts?.cacheUsage !== \"ONLY_CACHE\" /* ONLY_CACHE */;\n  }\n  shouldWaitForCache() {\n    if (this.opts.addSinceFromCache) return true;\n    return (\n      // Must want to close on EOSE; subscriptions\n      // that want to receive further updates must\n      // always hit the relay\n      this.opts.closeOnEose && // Cache adapter must claim to be fast\n      !!this.ndk.cacheAdapter?.locking && // If explicitly told to run in parallel, then\n      // we should not wait for the cache\n      this.opts.cacheUsage !== \"PARALLEL\" /* PARALLEL */\n    );\n  }\n  /**\n   * Start the subscription. This is the main method that should be called\n   * after creating a subscription.\n   *\n   * @param emitCachedEvents - Whether to emit events coming from a synchronous cache\n   *\n   * When using a synchronous cache, the events will be returned immediately\n   * by this function. If you will use those returned events, you should\n   * set emitCachedEvents to false to prevent seeing them as duplicate events.\n   */\n  start(emitCachedEvents = true) {\n    let cacheResult;\n    const updateStateFromCacheResults = (events) => {\n      if (emitCachedEvents) {\n        for (const event of events) {\n          if (!this.mostRecentCacheEventTimestamp || event.created_at > this.mostRecentCacheEventTimestamp) {\n            this.mostRecentCacheEventTimestamp = event.created_at;\n          }\n          this.eventReceived(event, void 0, true, false);\n        }\n      } else {\n        cacheResult = [];\n        for (const event of events) {\n          if (!this.mostRecentCacheEventTimestamp || event.created_at > this.mostRecentCacheEventTimestamp) {\n            this.mostRecentCacheEventTimestamp = event.created_at;\n          }\n          event.ndk = this.ndk;\n          const e = this.opts.wrap ? wrapEvent(event) : event;\n          if (!e) break;\n          if (e instanceof Promise) {\n            e.then((wrappedEvent) => {\n              this.emitEvent(false, wrappedEvent, void 0, true, false);\n            });\n            break;\n          }\n          this.eventFirstSeen.set(e.id, Date.now());\n          cacheResult.push(e);\n        }\n      }\n    };\n    const loadFromRelays = () => {\n      if (this.shouldQueryRelays()) {\n        this.startWithRelays();\n        this.startPoolMonitor();\n      } else {\n        this.emit(\"eose\", this);\n      }\n    };\n    if (this.shouldQueryCache()) {\n      cacheResult = this.startWithCache();\n      if (cacheResult instanceof Promise) {\n        if (this.shouldWaitForCache()) {\n          cacheResult.then((events) => {\n            updateStateFromCacheResults(events);\n            if (queryFullyFilled(this)) {\n              this.emit(\"eose\", this);\n              return;\n            }\n            loadFromRelays();\n          });\n          return null;\n        }\n        cacheResult.then((events) => {\n          updateStateFromCacheResults(events);\n        });\n        loadFromRelays();\n        return null;\n      }\n      updateStateFromCacheResults(cacheResult);\n      if (queryFullyFilled(this)) {\n        this.emit(\"eose\", this);\n      } else {\n        loadFromRelays();\n      }\n      return cacheResult;\n    }\n    loadFromRelays();\n    return null;\n  }\n  /**\n   * We want to monitor for new relays that are coming online, in case\n   * they should be part of this subscription.\n   */\n  startPoolMonitor() {\n    const _d = this.debug.extend(\"pool-monitor\");\n    this.poolMonitor = (relay) => {\n      if (this.relayFilters?.has(relay.url)) return;\n      const calc = calculateRelaySetsFromFilters(this.ndk, this.filters, this.pool);\n      if (calc.get(relay.url)) {\n        this.relayFilters?.set(relay.url, this.filters);\n        relay.subscribe(this, this.filters);\n      }\n    };\n    this.pool.on(\"relay:connect\", this.poolMonitor);\n  }\n  onStopped;\n  stop() {\n    this.emit(\"close\", this);\n    this.poolMonitor && this.pool.off(\"relay:connect\", this.poolMonitor);\n    this.onStopped?.();\n  }\n  /**\n   * @returns Whether the subscription has an authors filter.\n   */\n  hasAuthorsFilter() {\n    return this.filters.some((f) => f.authors?.length);\n  }\n  startWithCache() {\n    if (this.ndk.cacheAdapter?.query) {\n      return this.ndk.cacheAdapter.query(this);\n    }\n    return [];\n  }\n  /**\n   * Find available relays that should be part of this subscription and execute in them.\n   *\n   * Note that this is executed in addition to using the pool monitor, so even if the relay set\n   * that is computed (i.e. we don't have any relays available), when relays come online, we will\n   * check if we need to execute in them.\n   */\n  startWithRelays() {\n    let filters = this.filters;\n    if (this.opts.addSinceFromCache && this.mostRecentCacheEventTimestamp) {\n      const sinceTimestamp = this.mostRecentCacheEventTimestamp + 1;\n      filters = filters.map((filter) => ({\n        ...filter,\n        since: Math.max(filter.since || 0, sinceTimestamp)\n      }));\n    }\n    if (!this.relaySet || this.relaySet.relays.size === 0) {\n      this.relayFilters = calculateRelaySetsFromFilters(this.ndk, filters, this.pool);\n    } else {\n      this.relayFilters = /* @__PURE__ */ new Map();\n      for (const relay of this.relaySet.relays) {\n        this.relayFilters.set(relay.url, filters);\n      }\n    }\n    for (const [relayUrl, filters2] of this.relayFilters) {\n      const relay = this.pool.getRelay(relayUrl, true, true, filters2);\n      relay.subscribe(this, filters2);\n    }\n  }\n  // EVENT handling\n  /**\n   * Called when an event is received from a relay or the cache\n   * @param event\n   * @param relay\n   * @param fromCache Whether the event was received from the cache\n   * @param optimisticPublish Whether this event is coming from an optimistic publish\n   */\n  eventReceived(event, relay, fromCache = false, optimisticPublish = false) {\n    const eventId = event.id;\n    const eventAlreadySeen = this.eventFirstSeen.has(eventId);\n    let ndkEvent;\n    if (event instanceof NDKEvent) ndkEvent = event;\n    if (!eventAlreadySeen) {\n      ndkEvent ??= new NDKEvent(this.ndk, event);\n      ndkEvent.ndk = this.ndk;\n      ndkEvent.relay = relay;\n      if (!fromCache && !optimisticPublish) {\n        if (!this.skipValidation) {\n          if (!ndkEvent.isValid) {\n            this.debug(\"Event failed validation %s from relay %s\", eventId, relay?.url);\n            return;\n          }\n        }\n        if (relay) {\n          if (relay?.shouldValidateEvent() !== false) {\n            if (!this.skipVerification) {\n              if (!ndkEvent.verifySignature(true) && !this.ndk.asyncSigVerification) {\n                this.debug(\"Event failed signature validation\", event);\n                return;\n              }\n              if (relay) {\n                relay.addValidatedEvent();\n              }\n            }\n          } else {\n            relay.addNonValidatedEvent();\n          }\n        }\n        if (this.ndk.cacheAdapter && !this.opts.dontSaveToCache) {\n          this.ndk.cacheAdapter.setEvent(ndkEvent, this.filters, relay);\n        }\n      }\n      if (!optimisticPublish || this.skipOptimisticPublishEvent !== true) {\n        this.emitEvent(this.opts?.wrap ?? false, ndkEvent, relay, fromCache, optimisticPublish);\n        this.eventFirstSeen.set(eventId, Date.now());\n      }\n    } else {\n      const timeSinceFirstSeen = Date.now() - (this.eventFirstSeen.get(eventId) || 0);\n      this.emit(\"event:dup\", event, relay, timeSinceFirstSeen, this, fromCache, optimisticPublish);\n      if (relay) {\n        const signature = verifiedSignatures.get(eventId);\n        if (signature && typeof signature === \"string\") {\n          if (event.sig === signature) {\n            relay.addValidatedEvent();\n          }\n        }\n      }\n    }\n    this.lastEventReceivedAt = Date.now();\n  }\n  /**\n   * Optionally wraps, sync or async, and emits the event (if one comes back from the wrapper)\n   */\n  emitEvent(wrap, evt, relay, fromCache, optimisticPublish) {\n    const wrapped = wrap ? wrapEvent(evt) : evt;\n    if (wrapped instanceof Promise) {\n      wrapped.then((e) => this.emitEvent(false, e, relay, fromCache, optimisticPublish));\n    } else if (wrapped) {\n      this.emit(\"event\", wrapped, relay, this, fromCache, optimisticPublish);\n    }\n  }\n  closedReceived(relay, reason) {\n    this.emit(\"closed\", relay, reason);\n  }\n  // EOSE handling\n  eoseTimeout;\n  eosed = false;\n  eoseReceived(relay) {\n    this.debug(\"EOSE received from %s\", relay.url);\n    this.eosesSeen.add(relay);\n    let lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;\n    const hasSeenAllEoses = this.eosesSeen.size === this.relayFilters?.size;\n    const queryFilled = queryFullyFilled(this);\n    const performEose = (reason) => {\n      this.debug(\"Performing EOSE: %s %d\", reason, this.eosed);\n      if (this.eosed) return;\n      if (this.eoseTimeout) clearTimeout(this.eoseTimeout);\n      this.emit(\"eose\", this);\n      this.eosed = true;\n      if (this.opts?.closeOnEose) this.stop();\n    };\n    if (queryFilled || hasSeenAllEoses) {\n      performEose(\"query filled or seen all\");\n    } else if (this.relayFilters) {\n      let timeToWaitForNextEose = 1e3;\n      const connectedRelays = new Set(this.pool.connectedRelays().map((r) => r.url));\n      const connectedRelaysWithFilters = Array.from(this.relayFilters.keys()).filter(\n        (url) => connectedRelays.has(url)\n      );\n      if (connectedRelaysWithFilters.length === 0) {\n        this.debug(\n          \"No connected relays, waiting for all relays to connect\",\n          Array.from(this.relayFilters.keys()).join(\", \")\n        );\n        return;\n      }\n      const percentageOfRelaysThatHaveSentEose = this.eosesSeen.size / connectedRelaysWithFilters.length;\n      this.debug(\"Percentage of relays that have sent EOSE\", {\n        subId: this.subId,\n        percentageOfRelaysThatHaveSentEose,\n        seen: this.eosesSeen.size,\n        total: connectedRelaysWithFilters.length\n      });\n      if (this.eosesSeen.size >= 2 && percentageOfRelaysThatHaveSentEose >= 0.5) {\n        timeToWaitForNextEose = timeToWaitForNextEose * (1 - percentageOfRelaysThatHaveSentEose);\n        if (timeToWaitForNextEose === 0) {\n          performEose(\"time to wait was 0\");\n          return;\n        }\n        if (this.eoseTimeout) clearTimeout(this.eoseTimeout);\n        const sendEoseTimeout = () => {\n          lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;\n          if (lastEventSeen !== void 0 && lastEventSeen < 20) {\n            this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);\n          } else {\n            performEose(`send eose timeout: ${timeToWaitForNextEose}`);\n          }\n        };\n        this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);\n      }\n    }\n  }\n};\nvar kindIsEphemeral = (kind) => kind >= 2e4 && kind < 3e4;\n\n// src/user/follows.ts\nasync function follows(opts, outbox, kind = 3 /* Contacts */) {\n  if (!this.ndk) throw new Error(\"NDK not set\");\n  const contactListEvent = await this.ndk.fetchEvent(\n    { kinds: [kind], authors: [this.pubkey] },\n    opts || { groupable: false }\n  );\n  if (contactListEvent) {\n    const pubkeys = /* @__PURE__ */ new Set();\n    contactListEvent.tags.forEach((tag) => {\n      if (tag[0] === \"p\") pubkeys.add(tag[1]);\n    });\n    if (outbox) {\n      this.ndk?.outboxTracker?.trackUsers(Array.from(pubkeys));\n    }\n    return [...pubkeys].reduce((acc, pubkey) => {\n      const user = new NDKUser({ pubkey });\n      user.ndk = this.ndk;\n      acc.add(user);\n      return acc;\n    }, /* @__PURE__ */ new Set());\n  }\n  return /* @__PURE__ */ new Set();\n}\n\n// src/user/nip05.ts\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w.-]+)$/;\nasync function getNip05For(ndk, fullname, _fetch = fetch, fetchOpts = {}) {\n  return await ndk.queuesNip05.add({\n    id: fullname,\n    func: async () => {\n      if (ndk.cacheAdapter?.loadNip05) {\n        const profile = await ndk.cacheAdapter.loadNip05(fullname);\n        if (profile !== \"missing\") {\n          if (profile) {\n            const user = new NDKUser({\n              pubkey: profile.pubkey,\n              relayUrls: profile.relays,\n              nip46Urls: profile.nip46\n            });\n            user.ndk = ndk;\n            return user;\n          }\n          if (fetchOpts.cache !== \"no-cache\") {\n            return null;\n          }\n        }\n      }\n      const match = fullname.match(NIP05_REGEX);\n      if (!match) return null;\n      const [_, name = \"_\", domain] = match;\n      try {\n        const res = await _fetch(`https://${domain}/.well-known/nostr.json?name=${name}`, fetchOpts);\n        const { names, relays, nip46 } = parseNIP05Result(await res.json());\n        const pubkey = names[name.toLowerCase()];\n        let profile = null;\n        if (pubkey) {\n          profile = { pubkey, relays: relays?.[pubkey], nip46: nip46?.[pubkey] };\n        }\n        if (ndk?.cacheAdapter?.saveNip05) {\n          ndk.cacheAdapter.saveNip05(fullname, profile);\n        }\n        return profile;\n      } catch (_e) {\n        if (ndk?.cacheAdapter?.saveNip05) {\n          ndk?.cacheAdapter.saveNip05(fullname, null);\n        }\n        console.error(\"Failed to fetch NIP05 for\", fullname, _e);\n        return null;\n      }\n    }\n  });\n}\nfunction parseNIP05Result(json) {\n  const result = {\n    names: {}\n  };\n  for (const [name, pubkey] of Object.entries(json.names)) {\n    if (typeof name === \"string\" && typeof pubkey === \"string\") {\n      result.names[name.toLowerCase()] = pubkey;\n    }\n  }\n  if (json.relays) {\n    result.relays = {};\n    for (const [pubkey, relays] of Object.entries(json.relays)) {\n      if (typeof pubkey === \"string\" && Array.isArray(relays)) {\n        result.relays[pubkey] = relays.filter((relay) => typeof relay === \"string\");\n      }\n    }\n  }\n  if (json.nip46) {\n    result.nip46 = {};\n    for (const [pubkey, nip46] of Object.entries(json.nip46)) {\n      if (typeof pubkey === \"string\" && Array.isArray(nip46)) {\n        result.nip46[pubkey] = nip46.filter((relay) => typeof relay === \"string\");\n      }\n    }\n  }\n  return result;\n}\n\n// src/user/profile.ts\nfunction profileFromEvent(event) {\n  const profile = {};\n  let payload;\n  try {\n    payload = JSON.parse(event.content);\n  } catch (error) {\n    throw new Error(`Failed to parse profile event: ${error}`);\n  }\n  profile.created_at = event.created_at;\n  profile.profileEvent = JSON.stringify(event.rawEvent());\n  for (const key of Object.keys(payload)) {\n    switch (key) {\n      case \"name\":\n        profile.name = payload.name;\n        break;\n      case \"display_name\":\n        profile.displayName = payload.display_name;\n        break;\n      case \"image\":\n      case \"picture\":\n        profile.picture = payload.picture || payload.image;\n        profile.image = profile.picture;\n        break;\n      case \"banner\":\n        profile.banner = payload.banner;\n        break;\n      case \"bio\":\n        profile.bio = payload.bio;\n        break;\n      case \"nip05\":\n        profile.nip05 = payload.nip05;\n        break;\n      case \"lud06\":\n        profile.lud06 = payload.lud06;\n        break;\n      case \"lud16\":\n        profile.lud16 = payload.lud16;\n        break;\n      case \"about\":\n        profile.about = payload.about;\n        break;\n      case \"website\":\n        profile.website = payload.website;\n        break;\n      default:\n        profile[key] = payload[key];\n        break;\n    }\n  }\n  return profile;\n}\nfunction serializeProfile(profile) {\n  const payload = {};\n  for (const [key, val] of Object.entries(profile)) {\n    switch (key) {\n      case \"username\":\n      case \"name\":\n        payload.name = val;\n        break;\n      case \"displayName\":\n        payload.display_name = val;\n        break;\n      case \"image\":\n      case \"picture\":\n        payload.picture = val;\n        break;\n      case \"bio\":\n      case \"about\":\n        payload.about = val;\n        break;\n      default:\n        payload[key] = val;\n        break;\n    }\n  }\n  return JSON.stringify(payload);\n}\n\n// src/user/index.ts\nvar NDKUser = class _NDKUser {\n  ndk;\n  profile;\n  profileEvent;\n  _npub;\n  _pubkey;\n  relayUrls = [];\n  nip46Urls = [];\n  constructor(opts) {\n    if (opts.npub) this._npub = opts.npub;\n    if (opts.hexpubkey) this._pubkey = opts.hexpubkey;\n    if (opts.pubkey) this._pubkey = opts.pubkey;\n    if (opts.relayUrls) this.relayUrls = opts.relayUrls;\n    if (opts.nip46Urls) this.nip46Urls = opts.nip46Urls;\n    if (opts.nprofile) {\n      try {\n        const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(opts.nprofile);\n        if (decoded.type === \"nprofile\") {\n          this._pubkey = decoded.data.pubkey;\n          if (decoded.data.relays && decoded.data.relays.length > 0) {\n            this.relayUrls.push(...decoded.data.relays);\n          }\n        }\n      } catch (e) {\n        console.error(\"Failed to decode nprofile\", e);\n      }\n    }\n  }\n  get npub() {\n    if (!this._npub) {\n      if (!this._pubkey) throw new Error(\"pubkey not set\");\n      this._npub = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.npubEncode(this.pubkey);\n    }\n    return this._npub;\n  }\n  get nprofile() {\n    const relays = this.profileEvent?.onRelays?.map((r) => r.url);\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.nprofileEncode({\n      pubkey: this.pubkey,\n      relays\n    });\n  }\n  set npub(npub2) {\n    this._npub = npub2;\n  }\n  /**\n   * Get the user's pubkey\n   * @returns {string} The user's pubkey\n   */\n  get pubkey() {\n    if (!this._pubkey) {\n      if (!this._npub) throw new Error(\"npub not set\");\n      this._pubkey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(this.npub).data;\n    }\n    return this._pubkey;\n  }\n  /**\n   * Set the user's pubkey\n   * @param pubkey {string} The user's pubkey\n   */\n  set pubkey(pubkey) {\n    this._pubkey = pubkey;\n  }\n  /**\n   * Equivalent to NDKEvent.filters().\n   * @returns {NDKFilter}\n   */\n  filter() {\n    return { \"#p\": [this.pubkey] };\n  }\n  /**\n   * Gets NIP-57 and NIP-61 information that this user has signaled\n   *\n   * @param getAll {boolean} Whether to get all zap info or just the first one\n   */\n  async getZapInfo(timeoutMs) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const promiseWithTimeout = async (promise) => {\n      if (!timeoutMs) return promise;\n      let timeoutId;\n      const timeoutPromise = new Promise((_, reject) => {\n        timeoutId = setTimeout(() => reject(new Error(\"Timeout\")), timeoutMs);\n      });\n      try {\n        const result = await Promise.race([promise, timeoutPromise]);\n        if (timeoutId) clearTimeout(timeoutId);\n        return result;\n      } catch (e) {\n        if (e instanceof Error && e.message === \"Timeout\") {\n          try {\n            const result = await promise;\n            return result;\n          } catch (_originalError) {\n            return void 0;\n          }\n        }\n        return void 0;\n      }\n    };\n    const [userProfile, mintListEvent] = await Promise.all([\n      promiseWithTimeout(this.fetchProfile()),\n      promiseWithTimeout(this.ndk.fetchEvent({ kinds: [10019 /* CashuMintList */], authors: [this.pubkey] }))\n    ]);\n    const res = /* @__PURE__ */ new Map();\n    if (mintListEvent) {\n      const mintList = NDKCashuMintList.from(mintListEvent);\n      if (mintList.mints.length > 0) {\n        res.set(\"nip61\", {\n          mints: mintList.mints,\n          relays: mintList.relays,\n          p2pk: mintList.p2pk\n        });\n      }\n    }\n    if (userProfile) {\n      const { lud06, lud16 } = userProfile;\n      res.set(\"nip57\", { lud06, lud16 });\n    }\n    return res;\n  }\n  /**\n   * Instantiate an NDKUser from a NIP-05 string\n   * @param nip05Id {string} The user's NIP-05\n   * @param ndk {NDK} An NDK instance\n   * @param skipCache {boolean} Whether to skip the cache or not\n   * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.\n   */\n  static async fromNip05(nip05Id, ndk, skipCache = false) {\n    if (!ndk) throw new Error(\"No NDK instance found\");\n    const opts = {};\n    if (skipCache) opts.cache = \"no-cache\";\n    const profile = await getNip05For(ndk, nip05Id, ndk?.httpFetch, opts);\n    if (profile) {\n      const user = new _NDKUser({\n        pubkey: profile.pubkey,\n        relayUrls: profile.relays,\n        nip46Urls: profile.nip46\n      });\n      user.ndk = ndk;\n      return user;\n    }\n  }\n  /**\n   * Fetch a user's profile\n   * @param opts {NDKSubscriptionOptions} A set of NDKSubscriptionOptions\n   * @param storeProfileEvent {boolean} Whether to store the profile event or not\n   * @returns User Profile\n   */\n  async fetchProfile(opts, storeProfileEvent = false) {\n    if (!this.ndk) throw new Error(\"NDK not set\");\n    let setMetadataEvent = null;\n    if (this.ndk.cacheAdapter && (this.ndk.cacheAdapter.fetchProfile || this.ndk.cacheAdapter.fetchProfileSync) && opts?.cacheUsage !== \"ONLY_RELAY\" /* ONLY_RELAY */) {\n      let profile = null;\n      if (this.ndk.cacheAdapter.fetchProfileSync) {\n        profile = this.ndk.cacheAdapter.fetchProfileSync(this.pubkey);\n      } else if (this.ndk.cacheAdapter.fetchProfile) {\n        profile = await this.ndk.cacheAdapter.fetchProfile(this.pubkey);\n      }\n      if (profile) {\n        this.profile = profile;\n        return profile;\n      }\n    }\n    opts ??= {};\n    opts.cacheUsage ??= \"ONLY_RELAY\" /* ONLY_RELAY */;\n    opts.closeOnEose ??= true;\n    opts.groupable ??= true;\n    opts.groupableDelay ??= 250;\n    if (!setMetadataEvent) {\n      setMetadataEvent = await this.ndk.fetchEvent({ kinds: [0], authors: [this.pubkey] }, opts);\n    }\n    if (!setMetadataEvent) return null;\n    this.profile = profileFromEvent(setMetadataEvent);\n    if (storeProfileEvent && this.profile && this.ndk.cacheAdapter && this.ndk.cacheAdapter.saveProfile) {\n      this.ndk.cacheAdapter.saveProfile(this.pubkey, this.profile);\n    }\n    return this.profile;\n  }\n  /**\n   * Returns a set of users that this user follows.\n   *\n   * @deprecated Use followSet instead\n   */\n  follows = follows.bind(this);\n  /**\n   * Returns a set of pubkeys that this user follows.\n   *\n   * @param opts - NDKSubscriptionOptions\n   * @param outbox - boolean\n   * @param kind - number\n   */\n  async followSet(opts, outbox, kind = 3 /* Contacts */) {\n    const follows2 = await this.follows(opts, outbox, kind);\n    return new Set(Array.from(follows2).map((f) => f.pubkey));\n  }\n  /** @deprecated Use referenceTags instead. */\n  /**\n   * Get the tag that can be used to reference this user in an event\n   * @returns {NDKTag} an NDKTag\n   */\n  tagReference() {\n    return [\"p\", this.pubkey];\n  }\n  /**\n   * Get the tags that can be used to reference this user in an event\n   * @returns {NDKTag[]} an array of NDKTag\n   */\n  referenceTags(marker) {\n    const tag = [[\"p\", this.pubkey]];\n    if (!marker) return tag;\n    tag[0].push(\"\", marker);\n    return tag;\n  }\n  /**\n   * Publishes the current profile.\n   */\n  async publish() {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    if (!this.profile) throw new Error(\"No profile available\");\n    this.ndk.assertSigner();\n    const event = new NDKEvent(this.ndk, {\n      kind: 0,\n      content: serializeProfile(this.profile)\n    });\n    await event.publish();\n  }\n  /**\n   * Add a follow to this user's contact list\n   *\n   * @param newFollow {NDKUser} The user to follow\n   * @param currentFollowList {Set<NDKUser>} The current follow list\n   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)\n   * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists\n   */\n  async follow(newFollow, currentFollowList, kind = 3 /* Contacts */) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    if (!currentFollowList) {\n      currentFollowList = await this.follows(void 0, void 0, kind);\n    }\n    if (currentFollowList.has(newFollow)) {\n      return false;\n    }\n    currentFollowList.add(newFollow);\n    const event = new NDKEvent(this.ndk, { kind });\n    for (const follow of currentFollowList) {\n      event.tag(follow);\n    }\n    await event.publish();\n    return true;\n  }\n  /**\n   * Remove a follow from this user's contact list\n   *\n   * @param user {NDKUser} The user to unfollow\n   * @param currentFollowList {Set<NDKUser>} The current follow list\n   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)\n   * @returns The relays were the follow list was published or false if the user wasn't found\n   */\n  async unfollow(user, currentFollowList, kind = 3 /* Contacts */) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    if (!currentFollowList) {\n      currentFollowList = await this.follows(void 0, void 0, kind);\n    }\n    const newUserFollowList = /* @__PURE__ */ new Set();\n    let foundUser = false;\n    for (const follow of currentFollowList) {\n      if (follow.pubkey !== user.pubkey) {\n        newUserFollowList.add(follow);\n      } else {\n        foundUser = true;\n      }\n    }\n    if (!foundUser) return false;\n    const event = new NDKEvent(this.ndk, { kind });\n    for (const follow of newUserFollowList) {\n      event.tag(follow);\n    }\n    return await event.publish();\n  }\n  /**\n   * Validate a user's NIP-05 identifier (usually fetched from their kind:0 profile data)\n   *\n   * @param nip05Id The NIP-05 string to validate\n   * @returns {Promise<boolean | null>} True if the NIP-05 is found and matches this user's pubkey,\n   * False if the NIP-05 is found but doesn't match this user's pubkey,\n   * null if the NIP-05 isn't found on the domain or we're unable to verify (because of network issues, etc.)\n   */\n  async validateNip05(nip05Id) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const profilePointer = await getNip05For(this.ndk, nip05Id);\n    if (profilePointer === null) return null;\n    return profilePointer.pubkey === this.pubkey;\n  }\n};\n\n// src/user/pin.ts\nasync function pinEvent(user, event, pinEvent2, publish) {\n  const kind = 10001 /* PinList */;\n  if (!user.ndk) throw new Error(\"No NDK instance found\");\n  user.ndk.assertSigner();\n  if (!pinEvent2) {\n    const events = await user.ndk.fetchEvents(\n      { kinds: [kind], authors: [user.pubkey] },\n      { cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */ }\n    );\n    if (events.size > 0) {\n      pinEvent2 = lists_default.from(Array.from(events)[0]);\n    } else {\n      pinEvent2 = new NDKEvent(user.ndk, {\n        kind\n      });\n    }\n  }\n  pinEvent2.tag(event);\n  if (publish) {\n    await pinEvent2.publish();\n  }\n  return pinEvent2;\n}\n\n// src/events/kinds/classified.ts\nvar NDKClassified = class _NDKClassified extends NDKEvent {\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30402 /* Classified */;\n  }\n  /**\n   * Creates a NDKClassified from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKClassified from.\n   * @returns NDKClassified\n   */\n  static from(event) {\n    return new _NDKClassified(event.ndk, event);\n  }\n  /**\n   * Getter for the classified title.\n   *\n   * @returns {string | undefined} - The classified title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the classified title.\n   *\n   * @param {string | undefined} title - The title to set for the classified.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the classified summary.\n   *\n   * @returns {string | undefined} - The classified summary if available, otherwise undefined.\n   */\n  get summary() {\n    return this.tagValue(\"summary\");\n  }\n  /**\n   * Setter for the classified summary.\n   *\n   * @param {string | undefined} summary - The summary to set for the classified.\n   */\n  set summary(summary) {\n    this.removeTag(\"summary\");\n    if (summary) this.tags.push([\"summary\", summary]);\n  }\n  /**\n   * Getter for the classified's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the classified was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      return Number.parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the classified's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the classified's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Getter for the classified location.\n   *\n   * @returns {string | undefined} - The classified location if available, otherwise undefined.\n   */\n  get location() {\n    return this.tagValue(\"location\");\n  }\n  /**\n   * Setter for the classified location.\n   *\n   * @param {string | undefined} location - The location to set for the classified.\n   */\n  set location(location) {\n    this.removeTag(\"location\");\n    if (location) this.tags.push([\"location\", location]);\n  }\n  /**\n   * Getter for the classified price.\n   *\n   * @returns {NDKClassifiedPriceTag | undefined} - The classified price if available, otherwise undefined.\n   */\n  get price() {\n    const priceTag = this.tags.find((tag) => tag[0] === \"price\");\n    if (priceTag) {\n      return {\n        amount: Number.parseFloat(priceTag[1]),\n        currency: priceTag[2],\n        frequency: priceTag[3]\n      };\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the classified price.\n   *\n   * @param price - The price to set for the classified.\n   */\n  set price(priceTag) {\n    if (typeof priceTag === \"string\") {\n      priceTag = {\n        amount: Number.parseFloat(priceTag)\n      };\n    }\n    if (priceTag?.amount) {\n      const tag = [\"price\", priceTag.amount.toString()];\n      if (priceTag.currency) tag.push(priceTag.currency);\n      if (priceTag.frequency) tag.push(priceTag.frequency);\n      this.tags.push(tag);\n    } else {\n      this.removeTag(\"price\");\n    }\n  }\n  /**\n   * Generates content tags for the classified.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n};\n\n// src/events/kinds/drafts.ts\nvar NDKDraft = class _NDKDraft extends NDKEvent {\n  _event;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 31234 /* Draft */;\n  }\n  static from(event) {\n    return new _NDKDraft(event.ndk, event);\n  }\n  /**\n   * Sets an identifier (i.e. d-tag)\n   */\n  set identifier(id) {\n    this.removeTag(\"d\");\n    this.tags.push([\"d\", id]);\n  }\n  get identifier() {\n    return this.dTag;\n  }\n  /**\n   * Event that is to be saved.\n   */\n  set event(e) {\n    if (e instanceof NDKEvent) this._event = e.rawEvent();\n    else this._event = e;\n    this.prepareEvent();\n  }\n  /**\n   * Gets the event.\n   * @param param0\n   * @returns NDKEvent of the draft event or null if the draft event has been deleted (emptied).\n   */\n  async getEvent(signer) {\n    if (this._event) return new NDKEvent(this.ndk, this._event);\n    signer ??= this.ndk?.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    if (this.content && this.content.length > 0) {\n      try {\n        await this.decrypt(user, signer);\n        const payload = JSON.parse(this.content);\n        this._event = payload;\n        return new NDKEvent(this.ndk, payload);\n      } catch (e) {\n        console.error(e);\n        return void 0;\n      }\n    } else {\n      return null;\n    }\n  }\n  prepareEvent() {\n    if (!this._event) throw new Error(\"No event has been provided\");\n    this.removeTag(\"k\");\n    if (this._event.kind) this.tags.push([\"k\", this._event.kind.toString()]);\n    this.content = JSON.stringify(this._event);\n  }\n  /**\n   * Generates draft event.\n   *\n   * @param signer: Optional signer to encrypt with\n   * @param publish: Whether to publish, optionally specifying relaySet to publish to\n   */\n  async save({ signer, publish, relaySet }) {\n    signer ??= this.ndk?.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    await this.encrypt(user, signer);\n    if (publish === false) return;\n    return this.publish(relaySet);\n  }\n};\n\n// src/events/kinds/dvm/feedback.ts\nvar NDKDvmJobFeedbackStatus = /* @__PURE__ */ ((NDKDvmJobFeedbackStatus2) => {\n  NDKDvmJobFeedbackStatus2[\"Processing\"] = \"processing\";\n  NDKDvmJobFeedbackStatus2[\"Success\"] = \"success\";\n  NDKDvmJobFeedbackStatus2[\"Scheduled\"] = \"scheduled\";\n  NDKDvmJobFeedbackStatus2[\"PayReq\"] = \"payment_required\";\n  return NDKDvmJobFeedbackStatus2;\n})(NDKDvmJobFeedbackStatus || {});\nvar NDKDVMJobFeedback = class _NDKDVMJobFeedback extends NDKEvent {\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7e3 /* DVMJobFeedback */;\n  }\n  static async from(event) {\n    const e = new _NDKDVMJobFeedback(event.ndk, event.rawEvent());\n    if (e.encrypted) await e.dvmDecrypt();\n    return e;\n  }\n  get status() {\n    return this.tagValue(\"status\");\n  }\n  set status(status) {\n    this.removeTag(\"status\");\n    if (status !== void 0) {\n      this.tags.push([\"status\", status]);\n    }\n  }\n  get encrypted() {\n    return !!this.getMatchingTags(\"encrypted\")[0];\n  }\n  async dvmDecrypt() {\n    await this.decrypt();\n    const decryptedContent = JSON.parse(this.content);\n    this.tags.push(...decryptedContent);\n  }\n};\n\n// src/events/kinds/dvm/request.ts\nvar NDKDVMRequest = class _NDKDVMRequest extends NDKEvent {\n  static from(event) {\n    return new _NDKDVMRequest(event.ndk, event.rawEvent());\n  }\n  set bid(msatAmount) {\n    if (msatAmount === void 0) {\n      this.removeTag(\"bid\");\n    } else {\n      this.tags.push([\"bid\", msatAmount.toString()]);\n    }\n  }\n  get bid() {\n    const v = this.tagValue(\"bid\");\n    if (v === void 0) return void 0;\n    return Number.parseInt(v);\n  }\n  /**\n   * Adds a new input to the job\n   * @param args The arguments to the input\n   */\n  addInput(...args) {\n    this.tags.push([\"i\", ...args]);\n  }\n  /**\n   * Adds a new parameter to the job\n   */\n  addParam(...args) {\n    this.tags.push([\"param\", ...args]);\n  }\n  set output(output) {\n    if (output === void 0) {\n      this.removeTag(\"output\");\n    } else {\n      if (typeof output === \"string\") output = [output];\n      this.tags.push([\"output\", ...output]);\n    }\n  }\n  get output() {\n    const outputTag = this.getMatchingTags(\"output\")[0];\n    return outputTag ? outputTag.slice(1) : void 0;\n  }\n  get params() {\n    const paramTags = this.getMatchingTags(\"param\");\n    return paramTags.map((t) => t.slice(1));\n  }\n  getParam(name) {\n    const paramTag = this.getMatchingTags(\"param\").find((t) => t[1] === name);\n    return paramTag ? paramTag[2] : void 0;\n  }\n  createFeedback(status) {\n    const feedback = new NDKDVMJobFeedback(this.ndk);\n    feedback.tag(this, \"job\");\n    feedback.status = status;\n    return feedback;\n  }\n  /**\n   * Enables job encryption for this event\n   * @param dvm DVM that will receive the event\n   * @param signer Signer to use for encryption\n   */\n  async encryption(dvm, signer) {\n    const dvmTags = [\"i\", \"param\", \"output\", \"relays\", \"bid\"];\n    const tags = this.tags.filter((t) => dvmTags.includes(t[0]));\n    this.tags = this.tags.filter((t) => !dvmTags.includes(t[0]));\n    this.content = JSON.stringify(tags);\n    this.tag(dvm);\n    this.tags.push([\"encrypted\"]);\n    await this.encrypt(dvm, signer);\n  }\n  /**\n   * Sets the DVM that will receive the event\n   */\n  set dvm(dvm) {\n    this.removeTag(\"p\");\n    if (dvm) this.tag(dvm);\n  }\n};\n\n// src/events/kinds/dvm/NDKTranscriptionDVM.ts\nvar NDKTranscriptionDVM = class _NDKTranscriptionDVM extends NDKDVMRequest {\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind = 5e3 /* DVMReqTextExtraction */;\n  }\n  static from(event) {\n    return new _NDKTranscriptionDVM(event.ndk, event.rawEvent());\n  }\n  /**\n   * Returns the original source of the transcription\n   */\n  get url() {\n    const inputTags = this.getMatchingTags(\"i\");\n    if (inputTags.length !== 1) {\n      return void 0;\n    }\n    return inputTags[0][1];\n  }\n  /**\n   * Getter for the title tag\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the title tag\n   */\n  set title(value) {\n    this.removeTag(\"title\");\n    if (value) {\n      this.tags.push([\"title\", value]);\n    }\n  }\n  /**\n   * Getter for the image tag\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Setter for the image tag\n   */\n  set image(value) {\n    this.removeTag(\"image\");\n    if (value) {\n      this.tags.push([\"image\", value]);\n    }\n  }\n};\n\n// src/events/kinds/dvm/result.ts\nvar NDKDVMJobResult = class _NDKDVMJobResult extends NDKEvent {\n  static from(event) {\n    return new _NDKDVMJobResult(event.ndk, event.rawEvent());\n  }\n  setAmount(msat, invoice) {\n    this.removeTag(\"amount\");\n    const tag = [\"amount\", msat.toString()];\n    if (invoice) tag.push(invoice);\n    this.tags.push(tag);\n  }\n  set result(result) {\n    if (result === void 0) {\n      this.content = \"\";\n    } else {\n      this.content = result;\n    }\n  }\n  get result() {\n    if (this.content === \"\") {\n      return void 0;\n    }\n    return this.content;\n  }\n  set status(status) {\n    this.removeTag(\"status\");\n    if (status !== void 0) {\n      this.tags.push([\"status\", status]);\n    }\n  }\n  get status() {\n    return this.tagValue(\"status\");\n  }\n  get jobRequestId() {\n    for (const eTag of this.getMatchingTags(\"e\")) {\n      if (eTag[2] === \"job\") return eTag[1];\n    }\n    if (this.jobRequest) return this.jobRequest.id;\n    return this.tagValue(\"e\");\n  }\n  set jobRequest(event) {\n    this.removeTag(\"request\");\n    if (event) {\n      this.kind = event.kind + 1e3;\n      this.tags.push([\"request\", JSON.stringify(event.rawEvent())]);\n      this.tag(event);\n    }\n  }\n  get jobRequest() {\n    const tag = this.tagValue(\"request\");\n    if (tag === void 0) {\n      return void 0;\n    }\n    return new NDKEvent(this.ndk, JSON.parse(tag));\n  }\n};\n\n// src/events/kinds/cashu/tx.ts\nvar MARKERS = {\n  REDEEMED: \"redeemed\",\n  CREATED: \"created\",\n  DESTROYED: \"destroyed\",\n  RESERVED: \"reserved\"\n};\nvar NDKCashuWalletTx = class _NDKCashuWalletTx extends NDKEvent {\n  static MARKERS = MARKERS;\n  static kind = 7376 /* CashuWalletTx */;\n  static kinds = [7376 /* CashuWalletTx */];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7376 /* CashuWalletTx */;\n  }\n  static async from(event) {\n    const walletChange = new _NDKCashuWalletTx(event.ndk, event);\n    const prevContent = walletChange.content;\n    try {\n      await walletChange.decrypt();\n    } catch (_e) {\n      walletChange.content ??= prevContent;\n    }\n    try {\n      const contentTags = JSON.parse(walletChange.content);\n      walletChange.tags = [...contentTags, ...walletChange.tags];\n    } catch (_e) {\n      return;\n    }\n    return walletChange;\n  }\n  set direction(direction) {\n    this.removeTag(\"direction\");\n    if (direction) this.tags.push([\"direction\", direction]);\n  }\n  get direction() {\n    return this.tagValue(\"direction\");\n  }\n  set amount(amount) {\n    this.removeTag(\"amount\");\n    this.tags.push([\"amount\", amount.toString()]);\n  }\n  get amount() {\n    const val = this.tagValue(\"amount\");\n    if (val === void 0) return void 0;\n    return Number(val);\n  }\n  set fee(fee) {\n    this.removeTag(\"fee\");\n    this.tags.push([\"fee\", fee.toString()]);\n  }\n  get fee() {\n    const val = this.tagValue(\"fee\");\n    if (val === void 0) return void 0;\n    return Number(val);\n  }\n  set unit(unit) {\n    this.removeTag(\"unit\");\n    if (unit) this.tags.push([\"unit\", unit.toString()]);\n  }\n  get unit() {\n    return this.tagValue(\"unit\");\n  }\n  set description(description) {\n    this.removeTag(\"description\");\n    if (description) this.tags.push([\"description\", description.toString()]);\n  }\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  set mint(mint) {\n    this.removeTag(\"mint\");\n    if (mint) this.tags.push([\"mint\", mint.toString()]);\n  }\n  get mint() {\n    return this.tagValue(\"mint\");\n  }\n  /**\n   * Tags tokens that were created in this history event\n   */\n  set destroyedTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.DESTROYED));\n    }\n  }\n  set destroyedTokenIds(ids) {\n    for (const id of ids) {\n      this.tags.push([\"e\", id, \"\", MARKERS.DESTROYED]);\n    }\n  }\n  /**\n   * Tags tokens that were created in this history event\n   */\n  set createdTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.CREATED));\n    }\n  }\n  set reservedTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.RESERVED));\n    }\n  }\n  addRedeemedNutzap(event) {\n    this.tag(event, MARKERS.REDEEMED);\n  }\n  async toNostrEvent(pubkey) {\n    const encryptedTags = [];\n    const unencryptedTags = [];\n    for (const tag of this.tags) {\n      if (!this.shouldEncryptTag(tag)) {\n        unencryptedTags.push(tag);\n      } else {\n        encryptedTags.push(tag);\n      }\n    }\n    this.tags = unencryptedTags.filter((t) => t[0] !== \"client\");\n    this.content = JSON.stringify(encryptedTags);\n    const user = await this.ndk?.signer?.user();\n    await this.encrypt(user, void 0, \"nip44\");\n    return super.toNostrEvent(pubkey);\n  }\n  /**\n   * Whether this entry includes a redemption of a Nutzap\n   */\n  get hasNutzapRedemption() {\n    return this.getMatchingTags(\"e\", MARKERS.REDEEMED).length > 0;\n  }\n  shouldEncryptTag(tag) {\n    const unencryptedTagNames = [\"client\"];\n    if (unencryptedTagNames.includes(tag[0])) {\n      return false;\n    }\n    if (tag[0] === \"e\" && tag[3] === MARKERS.REDEEMED) {\n      return false;\n    }\n    if (tag[0] === \"p\") return false;\n    return true;\n  }\n};\n\n// src/events/kinds/NDKRelayList.ts\nvar READ_MARKER = \"read\";\nvar WRITE_MARKER = \"write\";\nvar NDKRelayList = class _NDKRelayList extends NDKEvent {\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 10002 /* RelayList */;\n  }\n  static from(ndkEvent) {\n    return new _NDKRelayList(ndkEvent.ndk, ndkEvent.rawEvent());\n  }\n  get readRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2] || tag[2] && tag[2] === READ_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);\n  }\n  set readRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay, READ_MARKER]);\n    }\n  }\n  get writeRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2] || tag[2] && tag[2] === WRITE_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);\n  }\n  set writeRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay, WRITE_MARKER]);\n    }\n  }\n  get bothRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2]).map((tag) => tag[1]);\n  }\n  set bothRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay]);\n    }\n  }\n  get relays() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").map((tag) => tag[1]);\n  }\n  /**\n   * Provides a relaySet for the relays in this list.\n   */\n  get relaySet() {\n    if (!this.ndk) throw new Error(\"NDKRelayList has no NDK instance\");\n    return new NDKRelaySet(\n      new Set(this.relays.map((u) => this.ndk?.pool.getRelay(u)).filter((r) => !!r)),\n      this.ndk\n    );\n  }\n};\nfunction relayListFromKind3(ndk, contactList) {\n  try {\n    const content = JSON.parse(contactList.content);\n    const relayList = new NDKRelayList(ndk);\n    const readRelays = /* @__PURE__ */ new Set();\n    const writeRelays = /* @__PURE__ */ new Set();\n    for (let [key, config] of Object.entries(content)) {\n      try {\n        key = normalizeRelayUrl(key);\n      } catch {\n        continue;\n      }\n      if (!config) {\n        readRelays.add(key);\n        writeRelays.add(key);\n      } else {\n        const relayConfig = config;\n        if (relayConfig.write) writeRelays.add(key);\n        if (relayConfig.read) readRelays.add(key);\n      }\n    }\n    relayList.readRelayUrls = Array.from(readRelays);\n    relayList.writeRelayUrls = Array.from(writeRelays);\n    return relayList;\n  } catch {\n  }\n  return void 0;\n}\n\n// src/events/kinds/nip89/app-handler.ts\nvar NDKAppHandlerEvent = class _NDKAppHandlerEvent extends NDKEvent {\n  profile;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 31990 /* AppHandler */;\n  }\n  static from(ndkEvent) {\n    const event = new _NDKAppHandlerEvent(ndkEvent.ndk, ndkEvent.rawEvent());\n    if (event.isValid) {\n      return event;\n    }\n    return null;\n  }\n  get isValid() {\n    const combinations = /* @__PURE__ */ new Map();\n    const combinationFromTag = (tag) => [tag[0], tag[2]].join(\":\").toLowerCase();\n    const tagsToInspect = [\"web\", \"android\", \"ios\"];\n    for (const tag of this.tags) {\n      if (tagsToInspect.includes(tag[0])) {\n        const combination = combinationFromTag(tag);\n        if (combinations.has(combination)) {\n          if (combinations.get(combination) !== tag[1].toLowerCase()) {\n            return false;\n          }\n        }\n        combinations.set(combination, tag[1].toLowerCase());\n      }\n    }\n    return true;\n  }\n  /**\n   * Fetches app handler information\n   * If no app information is available on the kind:31990,\n   * we fetch the event's author's profile and return that instead.\n   */\n  async fetchProfile() {\n    if (this.profile === void 0 && this.content.length > 0) {\n      try {\n        const profile = JSON.parse(this.content);\n        if (profile?.name) {\n          return profile;\n        }\n        this.profile = null;\n      } catch (_e) {\n        this.profile = null;\n      }\n    }\n    return new Promise((resolve, reject) => {\n      const author = this.author;\n      author.fetchProfile().then(() => {\n        resolve(author.profile);\n      }).catch(reject);\n    });\n  }\n};\n\n// src/events/kinds/repost.ts\nvar NDKRepost = class _NDKRepost extends NDKEvent {\n  _repostedEvents;\n  static from(event) {\n    return new _NDKRepost(event.ndk, event.rawEvent());\n  }\n  /**\n   * Returns all reposted events by the current event.\n   *\n   * @param klass Optional class to convert the events to.\n   * @returns\n   */\n  async repostedEvents(klass, opts) {\n    const items = [];\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (this._repostedEvents !== void 0) return this._repostedEvents;\n    for (const eventId of this.repostedEventIds()) {\n      const filter = filterForId(eventId);\n      const event = await this.ndk.fetchEvent(filter, opts);\n      if (event) {\n        items.push(klass ? klass.from(event) : event);\n      }\n    }\n    return items;\n  }\n  /**\n   * Returns the reposted event IDs.\n   */\n  repostedEventIds() {\n    return this.tags.filter((t) => t[0] === \"e\" || t[0] === \"a\").map((t) => t[1]);\n  }\n};\nfunction filterForId(id) {\n  if (id.match(/:/)) {\n    const [kind, pubkey, identifier] = id.split(\":\");\n    return {\n      kinds: [Number.parseInt(kind)],\n      authors: [pubkey],\n      \"#d\": [identifier]\n    };\n  }\n  return { ids: [id] };\n}\n\n// src/events/kinds/subscriptions/receipt.ts\n\nvar NDKSubscriptionReceipt = class _NDKSubscriptionReceipt extends NDKEvent {\n  debug;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 7003 /* SubscriptionReceipt */;\n    this.debug = ndk?.debug.extend(\"subscription-start\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:subscription-start\");\n  }\n  static from(event) {\n    return new _NDKSubscriptionReceipt(event.ndk, event.rawEvent());\n  }\n  /**\n   * This is the person being subscribed to\n   */\n  get recipient() {\n    const pTag = this.getMatchingTags(\"p\")?.[0];\n    if (!pTag) return void 0;\n    const user = new NDKUser({ pubkey: pTag[1] });\n    return user;\n  }\n  set recipient(user) {\n    this.removeTag(\"p\");\n    if (!user) return;\n    this.tags.push([\"p\", user.pubkey]);\n  }\n  /**\n   * This is the person subscribing\n   */\n  get subscriber() {\n    const PTag = this.getMatchingTags(\"P\")?.[0];\n    if (!PTag) return void 0;\n    const user = new NDKUser({ pubkey: PTag[1] });\n    return user;\n  }\n  set subscriber(user) {\n    this.removeTag(\"P\");\n    if (!user) return;\n    this.tags.push([\"P\", user.pubkey]);\n  }\n  set subscriptionStart(event) {\n    this.debug(`before setting subscription start: ${this.rawEvent}`);\n    this.removeTag(\"e\");\n    this.tag(event, \"subscription\", true);\n    this.debug(`after setting subscription start: ${this.rawEvent}`);\n  }\n  get tierName() {\n    const tag = this.getMatchingTags(\"tier\")?.[0];\n    return tag?.[1];\n  }\n  get isValid() {\n    const period = this.validPeriod;\n    if (!period) {\n      return false;\n    }\n    if (period.start > period.end) {\n      return false;\n    }\n    const pTags = this.getMatchingTags(\"p\");\n    const PTags = this.getMatchingTags(\"P\");\n    if (pTags.length !== 1 || PTags.length !== 1) {\n      return false;\n    }\n    return true;\n  }\n  get validPeriod() {\n    const tag = this.getMatchingTags(\"valid\")?.[0];\n    if (!tag) return void 0;\n    try {\n      return {\n        start: new Date(Number.parseInt(tag[1]) * 1e3),\n        end: new Date(Number.parseInt(tag[2]) * 1e3)\n      };\n    } catch {\n      return void 0;\n    }\n  }\n  set validPeriod(period) {\n    this.removeTag(\"valid\");\n    if (!period) return;\n    this.tags.push([\n      \"valid\",\n      Math.floor(period.start.getTime() / 1e3).toString(),\n      Math.floor(period.end.getTime() / 1e3).toString()\n    ]);\n  }\n  get startPeriod() {\n    return this.validPeriod?.start;\n  }\n  get endPeriod() {\n    return this.validPeriod?.end;\n  }\n  /**\n   * Whether the subscription is currently active\n   */\n  isActive(time) {\n    time ??= /* @__PURE__ */ new Date();\n    const period = this.validPeriod;\n    if (!period) return false;\n    if (time < period.start) return false;\n    if (time > period.end) return false;\n    return true;\n  }\n};\n\n// src/events/kinds/subscriptions/subscription-start.ts\n\nvar NDKSubscriptionStart = class _NDKSubscriptionStart extends NDKEvent {\n  debug;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 7001 /* Subscribe */;\n    this.debug = ndk?.debug.extend(\"subscription-start\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:subscription-start\");\n  }\n  static from(event) {\n    return new _NDKSubscriptionStart(event.ndk, event.rawEvent());\n  }\n  /**\n   * Recipient of the subscription. I.e. The author of this event subscribes to this user.\n   */\n  get recipient() {\n    const pTag = this.getMatchingTags(\"p\")?.[0];\n    if (!pTag) return void 0;\n    const user = new NDKUser({ pubkey: pTag[1] });\n    return user;\n  }\n  set recipient(user) {\n    this.removeTag(\"p\");\n    if (!user) return;\n    this.tags.push([\"p\", user.pubkey]);\n  }\n  /**\n   * The amount of the subscription.\n   */\n  get amount() {\n    const amountTag = this.getMatchingTags(\"amount\")?.[0];\n    if (!amountTag) return void 0;\n    return parseTagToSubscriptionAmount(amountTag);\n  }\n  set amount(amount) {\n    this.removeTag(\"amount\");\n    if (!amount) return;\n    this.tags.push(newAmount(amount.amount, amount.currency, amount.term));\n  }\n  /**\n   * The event id or NIP-33 tag id of the tier that the user is subscribing to.\n   */\n  get tierId() {\n    const eTag = this.getMatchingTags(\"e\")?.[0];\n    const aTag = this.getMatchingTags(\"a\")?.[0];\n    if (!eTag || !aTag) return void 0;\n    return eTag[1] ?? aTag[1];\n  }\n  set tier(tier) {\n    this.removeTag(\"e\");\n    this.removeTag(\"a\");\n    this.removeTag(\"event\");\n    if (!tier) return;\n    this.tag(tier);\n    this.removeTag(\"p\");\n    this.tags.push([\"p\", tier.pubkey]);\n    this.tags.push([\"event\", JSON.stringify(tier.rawEvent())]);\n  }\n  /**\n   * Fetches the tier that the user is subscribing to.\n   */\n  async fetchTier() {\n    const eventTag = this.tagValue(\"event\");\n    if (eventTag) {\n      try {\n        const parsedEvent = JSON.parse(eventTag);\n        return new NDKSubscriptionTier(this.ndk, parsedEvent);\n      } catch {\n        this.debug(\"Failed to parse event tag\");\n      }\n    }\n    const tierId = this.tierId;\n    if (!tierId) return void 0;\n    const e = await this.ndk?.fetchEvent(tierId);\n    if (!e) return void 0;\n    return NDKSubscriptionTier.from(e);\n  }\n  get isValid() {\n    if (this.getMatchingTags(\"amount\").length !== 1) {\n      this.debug(\"Invalid # of amount tag\");\n      return false;\n    }\n    if (!this.amount) {\n      this.debug(\"Invalid amount tag\");\n      return false;\n    }\n    if (this.getMatchingTags(\"p\").length !== 1) {\n      this.debug(\"Invalid # of p tag\");\n      return false;\n    }\n    if (!this.recipient) {\n      this.debug(\"Invalid p tag\");\n      return false;\n    }\n    return true;\n  }\n};\n\n// src/events/gift-wrapping.ts\n\n\n// src/signers/private-key/index.ts\n\n\n\nvar NDKPrivateKeySigner = class _NDKPrivateKeySigner {\n  _user;\n  _privateKey;\n  _pubkey;\n  /**\n   * Create a new signer from a private key.\n   * @param privateKey - The private key to use in hex form or nsec.\n   * @param ndk - The NDK instance to use.\n   */\n  constructor(privateKeyOrNsec, ndk) {\n    if (typeof privateKeyOrNsec === \"string\") {\n      if (privateKeyOrNsec.startsWith(\"nsec1\")) {\n        const { type, data } = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(privateKeyOrNsec);\n        if (type === \"nsec\") this._privateKey = data;\n        else throw new Error(\"Invalid private key provided.\");\n      } else if (privateKeyOrNsec.length === 64) {\n        this._privateKey = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(privateKeyOrNsec);\n      } else {\n        throw new Error(\"Invalid private key provided.\");\n      }\n    } else {\n      this._privateKey = privateKeyOrNsec;\n    }\n    this._pubkey = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.getPublicKey)(this._privateKey);\n    if (ndk) this._user = ndk.getUser({ pubkey: this._pubkey });\n    this._user ??= new NDKUser({ pubkey: this._pubkey });\n  }\n  /**\n   * Get the private key in hex form.\n   */\n  get privateKey() {\n    if (!this._privateKey) throw new Error(\"Not ready\");\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(this._privateKey);\n  }\n  /**\n   * Get the public key in hex form.\n   */\n  get pubkey() {\n    if (!this._pubkey) throw new Error(\"Not ready\");\n    return this._pubkey;\n  }\n  /**\n   * Get the private key in nsec form.\n   */\n  get nsec() {\n    if (!this._privateKey) throw new Error(\"Not ready\");\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.nsecEncode(this._privateKey);\n  }\n  /**\n   * Get the public key in npub form.\n   */\n  get npub() {\n    if (!this._pubkey) throw new Error(\"Not ready\");\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.npubEncode(this._pubkey);\n  }\n  /**\n   * Generate a new private key.\n   */\n  static generate() {\n    const privateKey = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.generateSecretKey)();\n    return new _NDKPrivateKeySigner(privateKey);\n  }\n  /**\n   * Noop in NDKPrivateKeySigner.\n   */\n  async blockUntilReady() {\n    return this._user;\n  }\n  /**\n   * Get the user.\n   */\n  async user() {\n    return this._user;\n  }\n  /**\n   * Get the user.\n   */\n  get userSync() {\n    return this._user;\n  }\n  async sign(event) {\n    if (!this._privateKey) {\n      throw Error(\"Attempted to sign without a private key\");\n    }\n    return (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(event, this._privateKey).sig;\n  }\n  async encryptionEnabled(scheme) {\n    const enabled = [];\n    if (!scheme || scheme === \"nip04\") enabled.push(\"nip04\");\n    if (!scheme || scheme === \"nip44\") enabled.push(\"nip44\");\n    return enabled;\n  }\n  async encrypt(recipient, value, scheme) {\n    if (!this._privateKey || !this.privateKey) {\n      throw Error(\"Attempted to encrypt without a private key\");\n    }\n    const recipientHexPubKey = recipient.pubkey;\n    if (scheme === \"nip44\") {\n      const conversationKey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.utils.getConversationKey(this._privateKey, recipientHexPubKey);\n      return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.encrypt(value, conversationKey);\n    }\n    return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip04.encrypt(this._privateKey, recipientHexPubKey, value);\n  }\n  async decrypt(sender, value, scheme) {\n    if (!this._privateKey || !this.privateKey) {\n      throw Error(\"Attempted to decrypt without a private key\");\n    }\n    const senderHexPubKey = sender.pubkey;\n    if (scheme === \"nip44\") {\n      const conversationKey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.utils.getConversationKey(this._privateKey, senderHexPubKey);\n      return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.decrypt(value, conversationKey);\n    }\n    return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip04.decrypt(this._privateKey, senderHexPubKey, value);\n  }\n  /**\n   * Serializes the signer's private key into a storable format.\n   * @returns A JSON string containing the type and the hex private key.\n   */\n  toPayload() {\n    if (!this._privateKey) throw new Error(\"Private key not available\");\n    const payload = {\n      type: \"private-key\",\n      payload: this.privateKey\n      // Use the hex private key\n    };\n    return JSON.stringify(payload);\n  }\n  /**\n   * Deserializes the signer from a payload string.\n   * @param payloadString The JSON string obtained from toPayload().\n   * @param ndk Optional NDK instance.\n   * @returns An instance of NDKPrivateKeySigner.\n   */\n  static async fromPayload(payloadString, ndk) {\n    const payload = JSON.parse(payloadString);\n    if (payload.type !== \"private-key\") {\n      throw new Error(`Invalid payload type: expected 'private-key', got ${payload.type}`);\n    }\n    if (!payload.payload || typeof payload.payload !== \"string\") {\n      throw new Error(\"Invalid payload content for private-key signer\");\n    }\n    return new _NDKPrivateKeySigner(payload.payload, ndk);\n  }\n};\n\n// src/events/gift-wrapping.ts\nasync function giftWrap(event, recipient, signer, params = {}) {\n  let _signer = signer;\n  params.scheme ??= \"nip44\";\n  if (!_signer) {\n    if (!event.ndk) throw new Error(\"no signer available for giftWrap\");\n    _signer = event.ndk.signer;\n  }\n  if (!_signer) throw new Error(\"no signer\");\n  if (!_signer.encryptionEnabled || !_signer.encryptionEnabled(params.scheme))\n    throw new Error(\"signer is not able to giftWrap\");\n  const rumor = getRumorEvent(event, params?.rumorKind);\n  const seal = await getSealEvent(rumor, recipient, _signer, params.scheme);\n  const wrap = await getWrapEvent(seal, recipient, params);\n  return new NDKEvent(event.ndk, wrap);\n}\nasync function giftUnwrap(event, sender, signer, scheme = \"nip44\") {\n  const _sender = sender || new NDKUser({ pubkey: event.pubkey });\n  let _signer = signer;\n  if (!_signer) {\n    if (!event.ndk) throw new Error(\"no signer available for giftUnwrap\");\n    _signer = event.ndk.signer;\n  }\n  if (!signer) throw new Error(\"no signer\");\n  try {\n    const seal = JSON.parse(await signer.decrypt(_sender, event.content, scheme));\n    if (!seal) throw new Error(\"Failed to decrypt wrapper\");\n    if (!new NDKEvent(void 0, seal).verifySignature(false))\n      throw new Error(\"GiftSeal signature verification failed!\");\n    const rumorSender = new NDKUser({ pubkey: seal.pubkey });\n    const rumor = JSON.parse(await signer.decrypt(rumorSender, seal.content, scheme));\n    if (!rumor) throw new Error(\"Failed to decrypt seal\");\n    if (rumor.pubkey !== _sender.pubkey) throw new Error(\"Invalid GiftWrap, sender validation failed!\");\n    return new NDKEvent(event.ndk, rumor);\n  } catch (_e) {\n    return Promise.reject(\"Got error unwrapping event! See console log.\");\n  }\n}\nfunction getRumorEvent(event, kind) {\n  const rumor = event.rawEvent();\n  rumor.kind = kind || rumor.kind || 14 /* PrivateDirectMessage */;\n  rumor.sig = void 0;\n  rumor.id = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.getEventHash)(rumor);\n  return new NDKEvent(event.ndk, rumor);\n}\nasync function getSealEvent(rumor, recipient, signer, scheme = \"nip44\") {\n  const seal = new NDKEvent(rumor.ndk);\n  seal.kind = 13 /* GiftWrapSeal */;\n  seal.created_at = approximateNow(5);\n  seal.content = JSON.stringify(rumor.rawEvent());\n  await seal.encrypt(recipient, signer, scheme);\n  await seal.sign(signer);\n  return seal;\n}\nasync function getWrapEvent(sealed, recipient, params, scheme = \"nip44\") {\n  const signer = NDKPrivateKeySigner.generate();\n  const wrap = new NDKEvent(sealed.ndk);\n  wrap.kind = 1059 /* GiftWrap */;\n  wrap.created_at = approximateNow(5);\n  if (params?.wrapTags) wrap.tags = params.wrapTags;\n  wrap.tag(recipient);\n  wrap.content = JSON.stringify(sealed.rawEvent());\n  await wrap.encrypt(recipient, signer, scheme);\n  await wrap.sign(signer);\n  return wrap;\n}\nfunction approximateNow(drift = 0) {\n  return Math.round(Date.now() / 1e3 - Math.random() * 10 ** drift);\n}\n\n// src/events/kinds/simple-group/index.ts\nvar NDKSimpleGroup = class _NDKSimpleGroup {\n  ndk;\n  groupId;\n  relaySet;\n  fetchingMetadata;\n  metadata;\n  memberList;\n  adminList;\n  constructor(ndk, relaySet, groupId) {\n    this.ndk = ndk;\n    this.groupId = groupId ?? randomId(24);\n    this.relaySet = relaySet;\n  }\n  get id() {\n    return this.groupId;\n  }\n  relayUrls() {\n    return this.relaySet?.relayUrls;\n  }\n  get name() {\n    return this.metadata?.name;\n  }\n  get about() {\n    return this.metadata?.about;\n  }\n  get picture() {\n    return this.metadata?.picture;\n  }\n  get members() {\n    return this.memberList?.members ?? [];\n  }\n  get admins() {\n    return this.adminList?.members ?? [];\n  }\n  async getMetadata() {\n    await this.ensureMetadataEvent();\n    return this.metadata;\n  }\n  /**\n   * Creates the group by publishing a kind:9007 event.\n   * @param signer\n   * @returns\n   */\n  async createGroup(signer) {\n    signer ??= this.ndk.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    if (!user) throw new Error(\"No user available\");\n    const event = new NDKEvent(this.ndk);\n    event.kind = 9007 /* GroupAdminCreateGroup */;\n    event.tags.push([\"h\", this.groupId]);\n    await event.sign(signer);\n    return event.publish(this.relaySet);\n  }\n  async setMetadata({ name, about, picture }) {\n    const event = new NDKEvent(this.ndk);\n    event.kind = 9002 /* GroupAdminEditMetadata */;\n    event.tags.push([\"h\", this.groupId]);\n    if (name) event.tags.push([\"name\", name]);\n    if (about) event.tags.push([\"about\", about]);\n    if (picture) event.tags.push([\"picture\", picture]);\n    await event.sign();\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Adds a user to the group using a kind:9000 event\n   * @param user user to add\n   * @param opts options\n   */\n  async addUser(user) {\n    const addUserEvent = _NDKSimpleGroup.generateAddUserEvent(user.pubkey, this.groupId);\n    addUserEvent.ndk = this.ndk;\n    return addUserEvent;\n  }\n  async getMemberListEvent() {\n    const memberList = await this.ndk.fetchEvent(\n      {\n        kinds: [39002 /* GroupMembers */],\n        \"#d\": [this.groupId]\n      },\n      void 0,\n      this.relaySet\n    );\n    if (!memberList) return null;\n    return NDKSimpleGroupMemberList.from(memberList);\n  }\n  /**\n   * Gets a list of users that belong to this group\n   */\n  async getMembers() {\n    const members = [];\n    const memberPubkeys = /* @__PURE__ */ new Set();\n    const memberListEvent = await this.getMemberListEvent();\n    if (!memberListEvent) return [];\n    for (const pTag of memberListEvent.getMatchingTags(\"p\")) {\n      const pubkey = pTag[1];\n      if (memberPubkeys.has(pubkey)) continue;\n      memberPubkeys.add(pubkey);\n      try {\n        members.push(this.ndk.getUser({ pubkey }));\n      } catch {\n      }\n    }\n    return members;\n  }\n  /**\n   * Generates an event that lists the members of a group.\n   * @param groupId\n   * @returns\n   */\n  static generateUserListEvent(groupId) {\n    const event = new NDKEvent(void 0, {\n      kind: 39002 /* GroupMembers */,\n      tags: [\n        [\"h\", groupId],\n        [\"alt\", \"Group Member List\"]\n      ]\n    });\n    return event;\n  }\n  /**\n   * Generates an event that adds a user to a group.\n   * @param userPubkey pubkey of the user to add\n   * @param groupId group to add the user to\n   * @returns\n   */\n  static generateAddUserEvent(userPubkey, groupId) {\n    const event = new NDKEvent(void 0, {\n      kind: 9e3 /* GroupAdminAddUser */,\n      tags: [[\"h\", groupId]]\n    });\n    event.tags.push([\"p\", userPubkey]);\n    return event;\n  }\n  async requestToJoin(_pubkey, content) {\n    const event = new NDKEvent(this.ndk, {\n      kind: 9021 /* GroupAdminRequestJoin */,\n      content: content ?? \"\",\n      tags: [[\"h\", this.groupId]]\n    });\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Makes sure that a metadata event exists locally\n   */\n  async ensureMetadataEvent() {\n    if (this.metadata) return;\n    if (this.fetchingMetadata) return this.fetchingMetadata;\n    this.fetchingMetadata = this.ndk.fetchEvent(\n      {\n        kinds: [39e3 /* GroupMetadata */],\n        \"#d\": [this.groupId]\n      },\n      void 0,\n      this.relaySet\n    ).then((event) => {\n      if (event) {\n        this.metadata = NDKSimpleGroupMetadata.from(event);\n      } else {\n        this.metadata = new NDKSimpleGroupMetadata(this.ndk);\n        this.metadata.dTag = this.groupId;\n      }\n    }).finally(() => {\n      this.fetchingMetadata = void 0;\n    }).catch(() => {\n      throw new Error(`Failed to fetch metadata for group ${this.groupId}`);\n    });\n    return this.fetchingMetadata;\n  }\n};\nfunction randomId(length) {\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const charsLength = chars.length;\n  let result = \"\";\n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * charsLength));\n  }\n  return result;\n}\n\n// src/app-settings/index.ts\nvar NDKAppSettings = class _NDKAppSettings extends NDKEvent {\n  appName;\n  settings = {};\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30078 /* AppSpecificData */;\n    this.dTag ??= this.appName;\n    if (this.content.length > 0) {\n      try {\n        this.settings = JSON.parse(this.content);\n      } catch (error) {\n        console.error(\"Error parsing app settings\", error);\n      }\n    }\n  }\n  static from(event) {\n    return new _NDKAppSettings(event.ndk, event);\n  }\n  /**\n   * Set a value for a given key.\n   *\n   * @param key\n   * @param value\n   */\n  set(key, value) {\n    this.settings[key] = value;\n  }\n  /**\n   * Get a value for a given key.\n   *\n   * @param key\n   * @returns\n   */\n  get(key) {\n    return this.settings[key];\n  }\n  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {\n    this.content = JSON.stringify(this.settings);\n    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/relay/auth-policies.ts\n\nfunction disconnect(pool, debug8) {\n  debug8 ??= debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:relay:auth-policies:disconnect\");\n  return async (relay) => {\n    debug8?.(`Relay ${relay.url} requested authentication, disconnecting`);\n    pool.removeRelay(relay.url);\n  };\n}\nasync function signAndAuth(event, relay, signer, debug8, resolve, reject) {\n  try {\n    await event.sign(signer);\n    resolve(event);\n  } catch (e) {\n    debug8?.(`Failed to publish auth event to relay ${relay.url}`, e);\n    reject(event);\n  }\n}\nfunction signIn({ ndk, signer, debug: debug8 } = {}) {\n  debug8 ??= debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:auth-policies:signIn\");\n  return async (relay, challenge) => {\n    debug8?.(`Relay ${relay.url} requested authentication, signing in`);\n    const event = new NDKEvent(ndk);\n    event.kind = 22242 /* ClientAuth */;\n    event.tags = [\n      [\"relay\", relay.url],\n      [\"challenge\", challenge]\n    ];\n    signer ??= ndk?.signer;\n    return new Promise(async (resolve, reject) => {\n      if (signer) {\n        await signAndAuth(event, relay, signer, debug8, resolve, reject);\n      } else {\n        ndk?.once(\"signer:ready\", async (signer2) => {\n          await signAndAuth(event, relay, signer2, debug8, resolve, reject);\n        });\n      }\n    });\n  };\n}\nvar NDKRelayAuthPolicies = {\n  disconnect,\n  signIn\n};\n\n// src/signers/nip07/index.ts\n\nvar NDKNip07Signer = class _NDKNip07Signer {\n  _userPromise;\n  encryptionQueue = [];\n  encryptionProcessing = false;\n  debug;\n  waitTimeout;\n  _pubkey;\n  ndk;\n  _user;\n  /**\n   * @param waitTimeout - The timeout in milliseconds to wait for the NIP-07 to become available\n   */\n  constructor(waitTimeout = 1e3, ndk) {\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:nip07\");\n    this.waitTimeout = waitTimeout;\n    this.ndk = ndk;\n  }\n  get pubkey() {\n    if (!this._pubkey) throw new Error(\"Not ready\");\n    return this._pubkey;\n  }\n  async blockUntilReady() {\n    await this.waitForExtension();\n    const pubkey = await window.nostr?.getPublicKey();\n    if (!pubkey) {\n      throw new Error(\"User rejected access\");\n    }\n    this._pubkey = pubkey;\n    let user;\n    if (this.ndk) user = this.ndk.getUser({ pubkey });\n    else user = new NDKUser({ pubkey });\n    this._user = user;\n    return user;\n  }\n  /**\n   * Getter for the user property.\n   * @returns The NDKUser instance.\n   */\n  async user() {\n    if (!this._userPromise) {\n      this._userPromise = this.blockUntilReady();\n    }\n    return this._userPromise;\n  }\n  get userSync() {\n    if (!this._user) throw new Error(\"User not ready\");\n    return this._user;\n  }\n  /**\n   * Signs the given Nostr event.\n   * @param event - The Nostr event to be signed.\n   * @returns The signature of the signed event.\n   * @throws Error if the NIP-07 is not available on the window object.\n   */\n  async sign(event) {\n    await this.waitForExtension();\n    const signedEvent = await window.nostr?.signEvent(event);\n    if (!signedEvent) throw new Error(\"Failed to sign event\");\n    return signedEvent.sig;\n  }\n  async relays(ndk) {\n    await this.waitForExtension();\n    const relays = await window.nostr?.getRelays?.() || {};\n    const activeRelays = [];\n    for (const url of Object.keys(relays)) {\n      if (relays[url].read && relays[url].write) {\n        activeRelays.push(url);\n      }\n    }\n    return activeRelays.map((url) => new NDKRelay(url, ndk?.relayAuthDefaultPolicy, ndk));\n  }\n  async encryptionEnabled(nip) {\n    const enabled = [];\n    if ((!nip || nip === \"nip04\") && Boolean(window.nostr?.nip04)) enabled.push(\"nip04\");\n    if ((!nip || nip === \"nip44\") && Boolean(window.nostr?.nip44)) enabled.push(\"nip44\");\n    return enabled;\n  }\n  async encrypt(recipient, value, nip = \"nip04\") {\n    if (!await this.encryptionEnabled(nip))\n      throw new Error(`${nip}encryption is not available from your browser extension`);\n    await this.waitForExtension();\n    const recipientHexPubKey = recipient.pubkey;\n    return this.queueEncryption(nip, \"encrypt\", recipientHexPubKey, value);\n  }\n  async decrypt(sender, value, nip = \"nip04\") {\n    if (!await this.encryptionEnabled(nip))\n      throw new Error(`${nip}encryption is not available from your browser extension`);\n    await this.waitForExtension();\n    const senderHexPubKey = sender.pubkey;\n    return this.queueEncryption(nip, \"decrypt\", senderHexPubKey, value);\n  }\n  async queueEncryption(scheme, method, counterpartyHexpubkey, value) {\n    return new Promise((resolve, reject) => {\n      this.encryptionQueue.push({\n        scheme,\n        method,\n        counterpartyHexpubkey,\n        value,\n        resolve,\n        reject\n      });\n      if (!this.encryptionProcessing) {\n        this.processEncryptionQueue();\n      }\n    });\n  }\n  async processEncryptionQueue(item, retries = 0) {\n    if (!item && this.encryptionQueue.length === 0) {\n      this.encryptionProcessing = false;\n      return;\n    }\n    this.encryptionProcessing = true;\n    const currentItem = item || this.encryptionQueue.shift();\n    if (!currentItem) {\n      this.encryptionProcessing = false;\n      return;\n    }\n    const { scheme, method, counterpartyHexpubkey, value, resolve, reject } = currentItem;\n    this.debug(\"Processing encryption queue item\", {\n      method,\n      counterpartyHexpubkey,\n      value\n    });\n    try {\n      const result = await window.nostr?.[scheme]?.[method](counterpartyHexpubkey, value);\n      if (!result) throw new Error(\"Failed to encrypt/decrypt\");\n      resolve(result);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      if (errorMessage.includes(\"call already executing\") && retries < 5) {\n        this.debug(\"Retrying encryption queue item\", {\n          method,\n          counterpartyHexpubkey,\n          value,\n          retries\n        });\n        setTimeout(() => {\n          this.processEncryptionQueue(currentItem, retries + 1);\n        }, 50 * retries);\n        return;\n      }\n      reject(error instanceof Error ? error : new Error(errorMessage));\n    }\n    this.processEncryptionQueue();\n  }\n  waitForExtension() {\n    return new Promise((resolve, reject) => {\n      if (window.nostr) {\n        resolve();\n        return;\n      }\n      let timerId;\n      const intervalId = setInterval(() => {\n        if (window.nostr) {\n          clearTimeout(timerId);\n          clearInterval(intervalId);\n          resolve();\n        }\n      }, 100);\n      timerId = setTimeout(() => {\n        clearInterval(intervalId);\n        reject(new Error(\"NIP-07 extension not available\"));\n      }, this.waitTimeout);\n    });\n  }\n  /**\n   * Serializes the signer type into a storable format.\n   * NIP-07 signers don't have persistent state to serialize beyond their type.\n   * @returns A JSON string containing the type.\n   */\n  toPayload() {\n    const payload = {\n      type: \"nip07\",\n      payload: \"\"\n      // No specific payload needed for NIP-07\n    };\n    return JSON.stringify(payload);\n  }\n  /**\n   * Deserializes the signer from a payload string.\n   * Creates a new NDKNip07Signer instance.\n   * @param payloadString The JSON string obtained from toPayload().\n   * @param ndk Optional NDK instance.\n   * @returns An instance of NDKNip07Signer.\n   */\n  static async fromPayload(payloadString, ndk) {\n    const payload = JSON.parse(payloadString);\n    if (payload.type !== \"nip07\") {\n      throw new Error(`Invalid payload type: expected 'nip07', got ${payload.type}`);\n    }\n    return new _NDKNip07Signer(void 0, ndk);\n  }\n};\n\n// src/signers/nip46/backend/index.ts\n\n\n// src/signers/nip46/rpc.ts\n\nvar NDKNostrRpc = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  signer;\n  relaySet;\n  debug;\n  encryptionType = \"nip04\";\n  pool;\n  constructor(ndk, signer, debug8, relayUrls) {\n    super();\n    this.ndk = ndk;\n    this.signer = signer;\n    if (relayUrls) {\n      this.pool = new NDKPool(relayUrls, [], ndk, {\n        debug: debug8.extend(\"rpc-pool\"),\n        name: \"Nostr RPC\"\n      });\n      this.relaySet = new NDKRelaySet(/* @__PURE__ */ new Set(), ndk, this.pool);\n      for (const url of relayUrls) {\n        const relay = this.pool.getRelay(url, false, false);\n        relay.authPolicy = NDKRelayAuthPolicies.signIn({ ndk, signer, debug: debug8 });\n        this.relaySet.addRelay(relay);\n        relay.connect();\n      }\n    }\n    this.debug = debug8.extend(\"rpc\");\n  }\n  /**\n   * Subscribe to a filter. This function will resolve once the subscription is ready.\n   */\n  subscribe(filter) {\n    const sub = this.ndk.subscribe(\n      filter,\n      {\n        closeOnEose: false,\n        groupable: false,\n        cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */,\n        pool: this.pool,\n        relaySet: this.relaySet\n      },\n      false\n    );\n    sub.on(\"event\", async (event) => {\n      try {\n        const parsedEvent = await this.parseEvent(event);\n        if (parsedEvent.method) {\n          this.emit(\"request\", parsedEvent);\n        } else {\n          this.emit(`response-${parsedEvent.id}`, parsedEvent);\n        }\n      } catch (e) {\n        this.debug(\"error parsing event\", e, event.rawEvent());\n      }\n    });\n    return new Promise((resolve) => {\n      sub.on(\"eose\", () => {\n        this.debug(\"eosed\");\n        resolve(sub);\n      });\n      sub.start();\n    });\n  }\n  async parseEvent(event) {\n    if (this.encryptionType === \"nip44\" && event.content.includes(\"?iv=\")) {\n      this.encryptionType = \"nip04\";\n    } else if (this.encryptionType === \"nip04\" && !event.content.includes(\"?iv=\")) {\n      this.encryptionType = \"nip44\";\n    }\n    const remoteUser = this.ndk.getUser({ pubkey: event.pubkey });\n    remoteUser.ndk = this.ndk;\n    let decryptedContent;\n    try {\n      decryptedContent = await this.signer.decrypt(remoteUser, event.content, this.encryptionType);\n    } catch (_e) {\n      const otherEncryptionType = this.encryptionType === \"nip04\" ? \"nip44\" : \"nip04\";\n      decryptedContent = await this.signer.decrypt(remoteUser, event.content, otherEncryptionType);\n      this.encryptionType = otherEncryptionType;\n    }\n    const parsedContent = JSON.parse(decryptedContent);\n    const { id, method, params, result, error } = parsedContent;\n    if (method) {\n      return { id, pubkey: event.pubkey, method, params, event };\n    }\n    return { id, result, error, event };\n  }\n  async sendResponse(id, remotePubkey, result, kind = 24133 /* NostrConnect */, error) {\n    const res = { id, result };\n    if (error) {\n      res.error = error;\n    }\n    const localUser = await this.signer.user();\n    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });\n    const event = new NDKEvent(this.ndk, {\n      kind,\n      content: JSON.stringify(res),\n      tags: [[\"p\", remotePubkey]],\n      pubkey: localUser.pubkey\n    });\n    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);\n    await event.sign(this.signer);\n    await event.publish(this.relaySet);\n  }\n  /**\n   * Sends a request.\n   * @param remotePubkey\n   * @param method\n   * @param params\n   * @param kind\n   * @param id\n   */\n  async sendRequest(remotePubkey, method, params = [], kind = 24133, cb) {\n    const id = Math.random().toString(36).substring(7);\n    const localUser = await this.signer.user();\n    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });\n    const request = { id, method, params };\n    const promise = new Promise(() => {\n      const responseHandler = (response) => {\n        if (response.result === \"auth_url\") {\n          this.once(`response-${id}`, responseHandler);\n          this.emit(\"authUrl\", response.error);\n        } else if (cb) {\n          cb(response);\n        }\n      };\n      this.once(`response-${id}`, responseHandler);\n    });\n    const event = new NDKEvent(this.ndk, {\n      kind,\n      content: JSON.stringify(request),\n      tags: [[\"p\", remotePubkey]],\n      pubkey: localUser.pubkey\n    });\n    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);\n    await event.sign(this.signer);\n    await event.publish(this.relaySet);\n    return promise;\n  }\n};\n\n// src/signers/nip46/backend/connect.ts\nvar ConnectEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [_, token] = params;\n    const debug8 = backend.debug.extend(\"connect\");\n    debug8(`connection request from ${remotePubkey}`);\n    if (token && backend.applyToken) {\n      debug8(\"applying token\");\n      await backend.applyToken(remotePubkey, token);\n    }\n    if (await backend.pubkeyAllowed({\n      id,\n      pubkey: remotePubkey,\n      method: \"connect\",\n      params: token\n    })) {\n      debug8(`connection request from ${remotePubkey} allowed`);\n      return \"ack\";\n    }\n    debug8(`connection request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n};\n\n// src/signers/nip46/backend/get-public-key.ts\nvar GetPublicKeyHandlingStrategy = class {\n  async handle(backend, _id, _remotePubkey, _params) {\n    return backend.localUser?.pubkey;\n  }\n};\n\n// src/signers/nip46/backend/nip04-decrypt.ts\nvar Nip04DecryptHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [senderPubkey, payload] = params;\n    const senderUser = new NDKUser({ pubkey: senderPubkey });\n    const decryptedPayload = await decrypt2(backend, id, remotePubkey, senderUser, payload);\n    return decryptedPayload;\n  }\n};\nasync function decrypt2(backend, id, remotePubkey, senderUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip04_decrypt\",\n    params: payload\n  })) {\n    backend.debug(`decrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.decrypt(senderUser, payload, \"nip04\");\n}\n\n// src/signers/nip46/backend/nip04-encrypt.ts\nvar Nip04EncryptHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [recipientPubkey, payload] = params;\n    const recipientUser = new NDKUser({ pubkey: recipientPubkey });\n    const encryptedPayload = await encrypt2(backend, id, remotePubkey, recipientUser, payload);\n    return encryptedPayload;\n  }\n};\nasync function encrypt2(backend, id, remotePubkey, recipientUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip04_encrypt\",\n    params: payload\n  })) {\n    backend.debug(`encrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.encrypt(recipientUser, payload, \"nip04\");\n}\n\n// src/signers/nip46/backend/nip44-decrypt.ts\nvar Nip04DecryptHandlingStrategy2 = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [senderPubkey, payload] = params;\n    const senderUser = new NDKUser({ pubkey: senderPubkey });\n    const decryptedPayload = await decrypt3(backend, id, remotePubkey, senderUser, payload);\n    return decryptedPayload;\n  }\n};\nasync function decrypt3(backend, id, remotePubkey, senderUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip44_decrypt\",\n    params: payload\n  })) {\n    backend.debug(`decrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.decrypt(senderUser, payload, \"nip44\");\n}\n\n// src/signers/nip46/backend/nip44-encrypt.ts\nvar Nip04EncryptHandlingStrategy2 = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [recipientPubkey, payload] = params;\n    const recipientUser = new NDKUser({ pubkey: recipientPubkey });\n    const encryptedPayload = await encrypt3(backend, id, remotePubkey, recipientUser, payload);\n    return encryptedPayload;\n  }\n};\nasync function encrypt3(backend, id, remotePubkey, recipientUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip44_encrypt\",\n    params: payload\n  })) {\n    backend.debug(`encrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.encrypt(recipientUser, payload, \"nip44\");\n}\n\n// src/signers/nip46/backend/ping.ts\nvar PingEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, _params) {\n    const debug8 = backend.debug.extend(\"ping\");\n    debug8(`ping request from ${remotePubkey}`);\n    if (await backend.pubkeyAllowed({ id, pubkey: remotePubkey, method: \"ping\" })) {\n      debug8(`connection request from ${remotePubkey} allowed`);\n      return \"pong\";\n    }\n    debug8(`connection request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n};\n\n// src/signers/nip46/backend/sign-event.ts\nvar SignEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const event = await signEvent(backend, id, remotePubkey, params);\n    if (!event) return void 0;\n    return JSON.stringify(await event.toNostrEvent());\n  }\n};\nasync function signEvent(backend, id, remotePubkey, params) {\n  const [eventString] = params;\n  backend.debug(`sign event request from ${remotePubkey}`);\n  const event = new NDKEvent(backend.ndk, JSON.parse(eventString));\n  backend.debug(\"event to sign\", event.rawEvent());\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"sign_event\",\n    params: event\n  })) {\n    backend.debug(`sign event request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  backend.debug(`sign event request from ${remotePubkey} allowed`);\n  await event.sign(backend.signer);\n  return event;\n}\n\n// src/signers/nip46/backend/index.ts\nvar NDKNip46Backend = class {\n  ndk;\n  signer;\n  localUser;\n  debug;\n  rpc;\n  permitCallback;\n  relayUrls;\n  /**\n   * @param ndk The NDK instance to use\n   * @param privateKeyOrSigner The private key or signer of the npub that wants to be published as\n   * @param permitCallback Callback executed when permission is requested\n   */\n  constructor(ndk, privateKeyOrSigner, permitCallback, relayUrls) {\n    this.ndk = ndk;\n    if (privateKeyOrSigner instanceof Uint8Array) {\n      this.signer = new NDKPrivateKeySigner(privateKeyOrSigner);\n    } else if (privateKeyOrSigner instanceof String) {\n      this.signer = new NDKPrivateKeySigner((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(privateKeyOrSigner));\n    } else if (privateKeyOrSigner instanceof NDKPrivateKeySigner) {\n      this.signer = privateKeyOrSigner;\n    } else {\n      throw new Error(\"Invalid signer\");\n    }\n    this.debug = ndk.debug.extend(\"nip46:backend\");\n    this.relayUrls = relayUrls ?? Array.from(ndk.pool.relays.keys());\n    this.rpc = new NDKNostrRpc(ndk, this.signer, this.debug, this.relayUrls);\n    this.permitCallback = permitCallback;\n  }\n  /**\n   * This method starts the backend, which will start listening for incoming\n   * requests.\n   */\n  async start() {\n    this.localUser = await this.signer.user();\n    const sub = this.ndk.subscribe(\n      {\n        kinds: [24133],\n        \"#p\": [this.localUser.pubkey]\n      },\n      { closeOnEose: false }\n    );\n    sub.on(\"event\", (e) => this.handleIncomingEvent(e));\n  }\n  handlers = {\n    connect: new ConnectEventHandlingStrategy(),\n    sign_event: new SignEventHandlingStrategy(),\n    nip04_encrypt: new Nip04EncryptHandlingStrategy(),\n    nip04_decrypt: new Nip04DecryptHandlingStrategy(),\n    nip44_encrypt: new Nip04EncryptHandlingStrategy2(),\n    nip44_decrypt: new Nip04DecryptHandlingStrategy2(),\n    get_public_key: new GetPublicKeyHandlingStrategy(),\n    ping: new PingEventHandlingStrategy()\n  };\n  /**\n   * Enables the user to set a custom strategy for handling incoming events.\n   * @param method - The method to set the strategy for\n   * @param strategy - The strategy to set\n   */\n  setStrategy(method, strategy) {\n    this.handlers[method] = strategy;\n  }\n  /**\n   * Overload this method to apply tokens, which can\n   * wrap permission sets to be applied to a pubkey.\n   * @param pubkey public key to apply token to\n   * @param token token to apply\n   */\n  async applyToken(_pubkey, _token) {\n    throw new Error(\"connection token not supported\");\n  }\n  async handleIncomingEvent(event) {\n    const { id, method, params } = await this.rpc.parseEvent(event);\n    const remotePubkey = event.pubkey;\n    let response;\n    this.debug(\"incoming event\", { id, method, params });\n    if (!event.verifySignature(false)) {\n      this.debug(\"invalid signature\", event.rawEvent());\n      return;\n    }\n    const strategy = this.handlers[method];\n    if (strategy) {\n      try {\n        response = await strategy.handle(this, id, remotePubkey, params);\n      } catch (e) {\n        this.debug(\"error handling event\", e, { id, method, params });\n        this.rpc.sendResponse(id, remotePubkey, \"error\", void 0, e.message);\n      }\n    } else {\n      this.debug(\"unsupported method\", { method, params });\n    }\n    if (response) {\n      this.debug(`sending response to ${remotePubkey}`, response);\n      this.rpc.sendResponse(id, remotePubkey, response);\n    } else {\n      this.rpc.sendResponse(id, remotePubkey, \"error\", void 0, \"Not authorized\");\n    }\n  }\n  /**\n   * This method should be overriden by the user to allow or reject incoming\n   * connections.\n   */\n  async pubkeyAllowed(params) {\n    return this.permitCallback(params);\n  }\n};\n\n// src/signers/nip46/index.ts\n\n\n// src/signers/deserialization.ts\nvar signerRegistry = /* @__PURE__ */ new Map();\nsignerRegistry.set(\"private-key\", NDKPrivateKeySigner);\nsignerRegistry.set(\"nip07\", NDKNip07Signer);\nsignerRegistry.set(\"nip46\", NDKNip46Signer);\nasync function ndkSignerFromPayload(payloadString, ndk) {\n  let parsed;\n  try {\n    parsed = JSON.parse(payloadString);\n  } catch (e) {\n    throw new Error(`Failed to parse signer payload: ${e instanceof Error ? e.message : String(e)}`);\n  }\n  const SignerClass = signerRegistry.get(parsed.type);\n  if (!SignerClass) {\n    throw new Error(`Unknown signer type: ${parsed.type}`);\n  }\n  try {\n    return await SignerClass.fromPayload(payloadString, ndk);\n  } catch (e) {\n    const errorMsg = e instanceof Error ? e.message : String(e);\n    throw new Error(`Failed to deserialize signer type ${parsed.type}: ${errorMsg}`);\n  }\n}\n\n// src/signers/nip46/index.ts\nvar NDKNip46Signer = class _NDKNip46Signer extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  _user;\n  /**\n   * The pubkey of the bunker that will be providing signatures\n   */\n  bunkerPubkey;\n  /**\n   * The pubkey of the user that events will be published as\n   */\n  userPubkey;\n  get pubkey() {\n    if (!this.userPubkey) throw new Error(\"Not ready\");\n    return this.userPubkey;\n  }\n  /**\n   * An optional secret value provided to connect to the bunker\n   */\n  secret;\n  localSigner;\n  nip05;\n  rpc;\n  debug;\n  relayUrls;\n  subscription;\n  /**\n   * @param ndk - The NDK instance to use\n   * @param userOrConnectionToken - The public key, or a connection token, of the npub that wants to be published as\n   * @param localSigner - The signer that will be used to request events to be signed\n   */\n  constructor(ndk, userOrConnectionToken, localSigner) {\n    super();\n    this.ndk = ndk;\n    this.debug = ndk.debug.extend(\"nip46:signer\");\n    if (userOrConnectionToken.startsWith(\"bunker://\")) {\n      this.connectionTokenInit(userOrConnectionToken);\n    } else {\n      this.nip05Init(userOrConnectionToken);\n    }\n    if (!localSigner) {\n      this.localSigner = NDKPrivateKeySigner.generate();\n    } else {\n      this.localSigner = localSigner;\n    }\n    this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);\n  }\n  connectionTokenInit(connectionToken) {\n    const bunkerUrl = new URL(connectionToken);\n    const bunkerPubkey = bunkerUrl.hostname || bunkerUrl.pathname.replace(/^\\/\\//, \"\");\n    const userPubkey = bunkerUrl.searchParams.get(\"pubkey\");\n    const relayUrls = bunkerUrl.searchParams.getAll(\"relay\");\n    const secret = bunkerUrl.searchParams.get(\"secret\");\n    this.bunkerPubkey = bunkerPubkey;\n    this.userPubkey = userPubkey;\n    this.relayUrls = relayUrls;\n    this.secret = secret;\n  }\n  nip05Init(nip05) {\n    this.nip05 = nip05;\n  }\n  /**\n   * We start listening for events from the bunker\n   */\n  async startListening() {\n    if (this.subscription) return;\n    const localUser = await this.localSigner.user();\n    if (!localUser) throw new Error(\"Local signer not ready\");\n    this.subscription = await this.rpc.subscribe({\n      kinds: [24133 /* NostrConnect */],\n      \"#p\": [localUser.pubkey]\n    });\n  }\n  /**\n   * Get the user that is being published as\n   */\n  async user() {\n    if (this._user) return this._user;\n    return this.blockUntilReady();\n  }\n  get userSync() {\n    if (!this._user) throw new Error(\"Remote user not ready synchronously\");\n    return this._user;\n  }\n  async blockUntilReady() {\n    if (this.nip05 && !this.userPubkey) {\n      const user = await NDKUser.fromNip05(this.nip05, this.ndk);\n      if (user) {\n        this._user = user;\n        this.userPubkey = user.pubkey;\n        this.relayUrls = user.nip46Urls;\n        this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);\n      }\n    }\n    if (!this.bunkerPubkey && this.userPubkey) {\n      this.bunkerPubkey = this.userPubkey;\n    } else if (!this.bunkerPubkey) {\n      throw new Error(\"Bunker pubkey not set\");\n    }\n    await this.startListening();\n    this.rpc.on(\"authUrl\", (...props) => {\n      this.emit(\"authUrl\", ...props);\n    });\n    return new Promise((resolve, reject) => {\n      const connectParams = [this.userPubkey ?? \"\"];\n      if (this.secret) connectParams.push(this.secret);\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(this.bunkerPubkey, \"connect\", connectParams, 24133, (response) => {\n        if (response.result === \"ack\") {\n          this.getPublicKey().then((pubkey) => {\n            this.userPubkey = pubkey;\n            this._user = this.ndk.getUser({ pubkey });\n            resolve(this._user);\n          });\n        } else {\n          reject(response.error);\n        }\n      });\n    });\n  }\n  async getPublicKey() {\n    if (this.userPubkey) return this.userPubkey;\n    return new Promise((resolve, _reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(this.bunkerPubkey, \"get_public_key\", [], 24133, (response) => {\n        resolve(response.result);\n      });\n    });\n  }\n  async encryptionEnabled(scheme) {\n    if (scheme) return [scheme];\n    return Promise.resolve([\"nip04\", \"nip44\"]);\n  }\n  async encrypt(recipient, value, scheme = \"nip04\") {\n    return this.encryption(recipient, value, scheme, \"encrypt\");\n  }\n  async decrypt(sender, value, scheme = \"nip04\") {\n    return this.encryption(sender, value, scheme, \"decrypt\");\n  }\n  async encryption(peer, value, scheme, method) {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        `${scheme}_${method}`,\n        [peer.pubkey, value],\n        24133,\n        (response) => {\n          if (!response.error) {\n            resolve(response.result);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n    return promise;\n  }\n  async sign(event) {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"sign_event\",\n        [JSON.stringify(event)],\n        24133,\n        (response) => {\n          if (!response.error) {\n            const json = JSON.parse(response.result);\n            resolve(json.sig);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n    return promise;\n  }\n  /**\n   * Allows creating a new account on the remote server.\n   * @param username Desired username for the NIP-05\n   * @param domain Desired domain for the NIP-05\n   * @param email Email address to associate with this account -- Remote servers may use this for recovery\n   * @returns The public key of the newly created account\n   */\n  async createAccount(username, domain, email) {\n    await this.startListening();\n    const req = [];\n    if (username) req.push(username);\n    if (domain) req.push(domain);\n    if (email) req.push(email);\n    return new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"create_account\",\n        req,\n        24133 /* NostrConnect */,\n        (response) => {\n          if (!response.error) {\n            const pubkey = response.result;\n            resolve(pubkey);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n  }\n  /**\n   * Serializes the signer's connection details and local signer state.\n   * @returns A JSON string containing the type, connection info, and local signer payload.\n   */\n  toPayload() {\n    if (!this.bunkerPubkey || !this.userPubkey) {\n      throw new Error(\"NIP-46 signer is not fully initialized for serialization\");\n    }\n    const payload = {\n      type: \"nip46\",\n      payload: {\n        bunkerPubkey: this.bunkerPubkey,\n        userPubkey: this.userPubkey,\n        relayUrls: this.relayUrls,\n        secret: this.secret,\n        localSignerPayload: this.localSigner.toPayload(),\n        // Store nip05 if it was used for initialization, otherwise null\n        nip05: this.nip05 || null\n      }\n    };\n    return JSON.stringify(payload);\n  }\n  /**\n   * Deserializes the signer from a payload string.\n   * @param payloadString The JSON string obtained from toPayload().\n   * @param ndk The NDK instance, required for NIP-46.\n   * @returns An instance of NDKNip46Signer.\n   */\n  static async fromPayload(payloadString, ndk) {\n    if (!ndk) {\n      throw new Error(\"NDK instance is required to deserialize NIP-46 signer\");\n    }\n    const parsed = JSON.parse(payloadString);\n    if (parsed.type !== \"nip46\") {\n      throw new Error(`Invalid payload type: expected 'nip46', got ${parsed.type}`);\n    }\n    const payload = parsed.payload;\n    if (!payload || typeof payload !== \"object\" || !payload.localSignerPayload) {\n      throw new Error(\"Invalid payload content for nip46 signer\");\n    }\n    const localSigner = await ndkSignerFromPayload(payload.localSignerPayload, ndk);\n    if (!localSigner) {\n      throw new Error(\"Failed to deserialize local signer for NIP-46\");\n    }\n    let signer;\n    if (payload.nip05) {\n      signer = new _NDKNip46Signer(ndk, payload.nip05, localSigner);\n      signer.userPubkey = payload.userPubkey;\n      signer.bunkerPubkey = payload.bunkerPubkey;\n      signer.relayUrls = payload.relayUrls;\n      signer.secret = payload.secret;\n    } else {\n      signer = new _NDKNip46Signer(ndk, payload.userPubkey, localSigner);\n      signer.bunkerPubkey = payload.bunkerPubkey;\n      signer.relayUrls = payload.relayUrls;\n      signer.secret = payload.secret;\n    }\n    return signer;\n  }\n};\n\n// src/dvm/schedule.ts\nfunction addRelays(event, relays) {\n  const tags = [];\n  if (!relays || relays.length === 0) {\n    const poolRelays = event.ndk?.pool.relays;\n    relays = poolRelays ? Object.keys(poolRelays) : void 0;\n  }\n  if (relays && relays.length > 0) tags.push([\"relays\", ...relays]);\n  return tags;\n}\nasync function dvmSchedule(events, dvm, relays, encrypted = true, waitForConfirmationForMs) {\n  if (!Array.isArray(events)) {\n    events = [events];\n  }\n  const ndk = events[0].ndk;\n  if (!ndk) throw new Error(\"NDK not set\");\n  for (const event of events) {\n    if (!event.sig) throw new Error(\"Event not signed\");\n    if (!event.created_at) throw new Error(\"Event has no date\");\n    if (!dvm) throw new Error(\"No DVM specified\");\n    if (event.created_at <= Date.now() / 1e3) throw new Error(\"Event needs to be in the future\");\n  }\n  const scheduleEvent = new NDKDVMRequest(ndk, {\n    kind: 5905 /* DVMEventSchedule */\n  });\n  for (const event of events) {\n    scheduleEvent.addInput(JSON.stringify(event.rawEvent()), \"text\");\n  }\n  scheduleEvent.tags.push(...addRelays(events[0], relays));\n  if (encrypted) {\n    await scheduleEvent.encryption(dvm);\n  } else {\n    scheduleEvent.dvm = dvm;\n  }\n  await scheduleEvent.sign();\n  let res;\n  if (waitForConfirmationForMs) {\n    res = ndk.subscribe(\n      {\n        kinds: [5905 /* DVMEventSchedule */ + 1e3, 7e3 /* DVMJobFeedback */],\n        ...scheduleEvent.filter()\n      },\n      { groupable: false, closeOnEose: false }\n    );\n  }\n  const timeoutPromise = new Promise((reject) => {\n    setTimeout(() => {\n      res?.stop();\n      reject(\"Timeout waiting for an answer from the DVM\");\n    }, waitForConfirmationForMs);\n  });\n  const schedulePromise = new Promise((resolve, reject) => {\n    if (waitForConfirmationForMs) {\n      res?.on(\"event\", async (e) => {\n        res?.stop();\n        if (e.kind === 7e3 /* DVMJobFeedback */) {\n          const feedback = await NDKDVMJobFeedback.from(e);\n          if (feedback.status === \"error\") {\n            const statusTag = feedback.getMatchingTags(\"status\");\n            reject(statusTag?.[2] ?? feedback);\n          } else {\n            resolve(feedback);\n          }\n        }\n        resolve(e);\n      });\n    }\n    scheduleEvent.publish().then(() => {\n      if (!waitForConfirmationForMs) resolve(void 0);\n    });\n  });\n  return new Promise((resolve, reject) => {\n    if (waitForConfirmationForMs) {\n      Promise.race([timeoutPromise, schedulePromise]).then((e) => {\n        resolve(e);\n      }).catch(reject);\n    } else {\n      schedulePromise.then(resolve);\n    }\n  });\n}\n\n// src/ndk/index.ts\n\n\n\n// src/events/dedup.ts\nfunction dedup(event1, event2) {\n  if (event1.created_at > event2.created_at) {\n    return event1;\n  }\n  return event2;\n}\n\n// src/outbox/tracker.ts\n\n\n\n// src/utils/get-users-relay-list.ts\nasync function getRelayListForUser(pubkey, ndk) {\n  const list = await getRelayListForUsers([pubkey], ndk);\n  return list.get(pubkey);\n}\nasync function getRelayListForUsers(pubkeys, ndk, skipCache = false, timeout = 1e3) {\n  const pool = ndk.outboxPool || ndk.pool;\n  const set = /* @__PURE__ */ new Set();\n  for (const relay of pool.relays.values()) set.add(relay);\n  const relayLists = /* @__PURE__ */ new Map();\n  const fromContactList = /* @__PURE__ */ new Map();\n  const relaySet = new NDKRelaySet(set, ndk);\n  if (ndk.cacheAdapter?.locking && !skipCache) {\n    const cachedList = await ndk.fetchEvents(\n      { kinds: [3, 10002], authors: Array.from(new Set(pubkeys)) },\n      { cacheUsage: \"ONLY_CACHE\" /* ONLY_CACHE */, subId: \"ndk-relay-list-fetch\" }\n    );\n    for (const relayList of cachedList) {\n      if (relayList.kind === 10002) relayLists.set(relayList.pubkey, NDKRelayList.from(relayList));\n    }\n    for (const relayList of cachedList) {\n      if (relayList.kind === 3) {\n        if (relayLists.has(relayList.pubkey)) continue;\n        const list = relayListFromKind3(ndk, relayList);\n        if (list) fromContactList.set(relayList.pubkey, list);\n      }\n    }\n    pubkeys = pubkeys.filter((pubkey) => !relayLists.has(pubkey) && !fromContactList.has(pubkey));\n  }\n  if (pubkeys.length === 0) return relayLists;\n  const relayListEvents = /* @__PURE__ */ new Map();\n  const contactListEvents = /* @__PURE__ */ new Map();\n  return new Promise((resolve) => {\n    const handleSubscription = async () => {\n      const subscribeOpts = {\n        closeOnEose: true,\n        pool,\n        groupable: true,\n        subId: \"ndk-relay-list-fetch\",\n        addSinceFromCache: true,\n        relaySet\n      };\n      if (relaySet) subscribeOpts.relaySet = relaySet;\n      ndk.subscribe({ kinds: [3, 10002], authors: pubkeys }, subscribeOpts, {\n        onEvent: (event) => {\n          if (event.kind === 10002 /* RelayList */) {\n            const existingEvent = relayListEvents.get(event.pubkey);\n            if (existingEvent && existingEvent.created_at > event.created_at) return;\n            relayListEvents.set(event.pubkey, event);\n          } else if (event.kind === 3 /* Contacts */) {\n            const existingEvent = contactListEvents.get(event.pubkey);\n            if (existingEvent && existingEvent.created_at > event.created_at) return;\n            contactListEvents.set(event.pubkey, event);\n          }\n        },\n        onEose: () => {\n          for (const event of relayListEvents.values()) {\n            relayLists.set(event.pubkey, NDKRelayList.from(event));\n          }\n          for (const pubkey of pubkeys) {\n            if (relayLists.has(pubkey)) continue;\n            const contactList = contactListEvents.get(pubkey);\n            if (!contactList) continue;\n            const list = relayListFromKind3(ndk, contactList);\n            if (list) relayLists.set(pubkey, list);\n          }\n          resolve(relayLists);\n        }\n      });\n      setTimeout(() => {\n        resolve(relayLists);\n      }, timeout);\n    };\n    handleSubscription();\n  });\n}\n\n// src/outbox/tracker.ts\nvar OutboxItem = class {\n  /**\n   * Type of item\n   */\n  type;\n  /**\n   * The relay URLs that are of interest to this item\n   */\n  relayUrlScores;\n  readRelays;\n  writeRelays;\n  constructor(type) {\n    this.type = type;\n    this.relayUrlScores = /* @__PURE__ */ new Map();\n    this.readRelays = /* @__PURE__ */ new Set();\n    this.writeRelays = /* @__PURE__ */ new Set();\n  }\n};\nvar OutboxTracker = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  data;\n  ndk;\n  debug;\n  constructor(ndk) {\n    super();\n    this.ndk = ndk;\n    this.debug = ndk.debug.extend(\"outbox-tracker\");\n    this.data = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n      maxSize: 1e5,\n      entryExpirationTimeInMS: 2 * 60 * 1e3\n    });\n  }\n  /**\n   * Adds a list of users to the tracker.\n   * @param items\n   * @param skipCache\n   */\n  async trackUsers(items, skipCache = false) {\n    const promises = [];\n    for (let i = 0; i < items.length; i += 400) {\n      const slice = items.slice(i, i + 400);\n      const pubkeys = slice.map((item) => getKeyFromItem(item)).filter((pubkey) => !this.data.has(pubkey));\n      if (pubkeys.length === 0) continue;\n      for (const pubkey of pubkeys) {\n        this.data.set(pubkey, new OutboxItem(\"user\"));\n      }\n      promises.push(\n        new Promise((resolve) => {\n          getRelayListForUsers(pubkeys, this.ndk, skipCache).then((relayLists) => {\n            for (const [pubkey, relayList] of relayLists) {\n              let outboxItem = this.data.get(pubkey);\n              outboxItem ??= new OutboxItem(\"user\");\n              if (relayList) {\n                outboxItem.readRelays = new Set(normalize(relayList.readRelayUrls));\n                outboxItem.writeRelays = new Set(normalize(relayList.writeRelayUrls));\n                for (const relayUrl of outboxItem.readRelays) {\n                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {\n                    outboxItem.readRelays.delete(relayUrl);\n                  }\n                }\n                for (const relayUrl of outboxItem.writeRelays) {\n                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {\n                    outboxItem.writeRelays.delete(relayUrl);\n                  }\n                }\n                this.data.set(pubkey, outboxItem);\n              }\n            }\n          }).finally(resolve);\n        })\n      );\n    }\n    return Promise.all(promises);\n  }\n  /**\n   *\n   * @param key\n   * @param score\n   */\n  track(item, type, _skipCache = true) {\n    const key = getKeyFromItem(item);\n    type ??= getTypeFromItem(item);\n    let outboxItem = this.data.get(key);\n    if (!outboxItem) {\n      outboxItem = new OutboxItem(type);\n      if (item instanceof NDKUser) {\n        this.trackUsers([item]);\n      }\n    }\n    return outboxItem;\n  }\n};\nfunction getKeyFromItem(item) {\n  if (item instanceof NDKUser) {\n    return item.pubkey;\n  }\n  return item;\n}\nfunction getTypeFromItem(item) {\n  if (item instanceof NDKUser) {\n    return \"user\";\n  }\n  return \"kind\";\n}\n\n// src/relay/sets/utils.ts\nfunction correctRelaySet(relaySet, pool) {\n  const connectedRelays = pool.connectedRelays();\n  const includesConnectedRelay = Array.from(relaySet.relays).some((relay) => {\n    return connectedRelays.map((r) => r.url).includes(relay.url);\n  });\n  if (!includesConnectedRelay) {\n    for (const relay of connectedRelays) {\n      relaySet.addRelay(relay);\n    }\n  }\n  if (connectedRelays.length === 0) {\n    for (const relay of pool.relays.values()) {\n      relaySet.addRelay(relay);\n    }\n  }\n  return relaySet;\n}\n\n// src/subscription/manager.ts\n\nvar NDKSubscriptionManager = class {\n  subscriptions;\n  seenEvents = /* @__PURE__ */ new Map();\n  constructor() {\n    this.subscriptions = /* @__PURE__ */ new Map();\n  }\n  add(sub) {\n    this.subscriptions.set(sub.internalId, sub);\n    if (sub.onStopped) {\n    }\n    sub.onStopped = () => {\n      this.subscriptions.delete(sub.internalId);\n    };\n    sub.on(\"close\", () => {\n      this.subscriptions.delete(sub.internalId);\n    });\n  }\n  seenEvent(eventId, relay) {\n    const current = this.seenEvents.get(eventId) || [];\n    current.push(relay);\n    this.seenEvents.set(eventId, current);\n  }\n  /**\n   * Whenever an event comes in, this function is called.\n   * This function matches the received event against all the\n   * known (i.e. active) NDKSubscriptions, and if it matches,\n   * it sends the event to the subscription.\n   *\n   * This is the single place in the codebase that matches\n   * incoming events with parties interested in the event.\n   *\n   * This is also what allows for reactivity in NDK apps, such that\n   * whenever an active subscription receives an event that some\n   * other active subscription would want to receive, both receive it.\n   *\n   * TODO This also allows for subscriptions that overlap in meaning\n   * to be collapsed into one.\n   *\n   * I.e. if a subscription with filter: kinds: [1], authors: [alice]\n   * is created and EOSEs, and then a subsequent subscription with\n   * kinds: [1], authors: [alice] is created, once the second subscription\n   * EOSEs we can safely close it, increment its refCount and close it,\n   * and when the first subscription receives a new event from Alice this\n   * code will make the second subscription receive the event even though\n   * it has no active subscription on a relay.\n   * @param event Raw event received from a relay\n   * @param relay Relay that sent the event\n   * @param optimisticPublish Whether the event is coming from an optimistic publish\n   */\n  dispatchEvent(event, relay, optimisticPublish = false) {\n    if (relay) this.seenEvent(event.id, relay);\n    const subscriptions = this.subscriptions.values();\n    const matchingSubs = [];\n    for (const sub of subscriptions) {\n      if ((0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.matchFilters)(sub.filters, event)) {\n        matchingSubs.push(sub);\n      }\n    }\n    for (const sub of matchingSubs) {\n      sub.eventReceived(event, relay, false, optimisticPublish);\n    }\n  }\n};\n\n// src/ndk/active-user.ts\n\nvar debug6 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:active-user\");\nasync function getUserRelayList(user) {\n  if (!this.autoConnectUserRelays) return;\n  const userRelays = await getRelayListForUser(user.pubkey, this);\n  if (!userRelays) return;\n  for (const url of userRelays.relays) {\n    let relay = this.pool.relays.get(url);\n    if (!relay) {\n      relay = new NDKRelay(url, this.relayAuthDefaultPolicy, this);\n      this.pool.addRelay(relay);\n    }\n  }\n  return userRelays;\n}\nasync function setActiveUser(user) {\n  const pool = this.outboxPool || this.pool;\n  if (pool.connectedRelays.length > 0) {\n    setActiveUserConnected.call(this, user);\n  } else {\n    pool.once(\"connect\", () => {\n      setActiveUserConnected.call(this, user);\n    });\n  }\n}\nasync function setActiveUserConnected(user) {\n  const userRelays = await getUserRelayList.call(this, user);\n  const filters = [\n    {\n      kinds: [10006 /* BlockRelayList */],\n      authors: [user.pubkey]\n    }\n  ];\n  if (this.autoFetchUserMutelist) {\n    filters[0].kinds?.push(1e4 /* MuteList */);\n  }\n  const events = /* @__PURE__ */ new Map();\n  const relaySet = userRelays ? userRelays.relaySet : void 0;\n  this.subscribe(\n    filters,\n    { subId: \"active-user-settings\", closeOnEose: true, relaySet },\n    {\n      onEvent: (event) => {\n        const prevEvent = events.get(event.kind);\n        if (prevEvent && prevEvent.created_at >= event.created_at) return;\n        events.set(event.kind, event);\n      },\n      onEose: () => {\n        for (const event of events.values()) {\n          processEvent.call(this, event);\n        }\n      }\n    }\n  );\n}\nasync function processEvent(event) {\n  if (event.kind === 10006 /* BlockRelayList */) {\n    processBlockRelayList.call(this, event);\n  } else if (event.kind === 1e4 /* MuteList */) {\n    processMuteList.call(this, event);\n  }\n}\nfunction processBlockRelayList(event) {\n  const list = lists_default.from(event);\n  for (const item of list.items) {\n    this.pool.blacklistRelayUrls.add(item[0]);\n  }\n  debug6(\"Added %d relays to relay blacklist\", list.items.length);\n}\nfunction processMuteList(muteList) {\n  const list = lists_default.from(muteList);\n  for (const item of list.items) {\n    this.mutedIds.set(item[1], item[0]);\n  }\n  debug6(\"Added %d users to mute list\", list.items.length);\n}\n\n// src/ndk/entity.ts\n\nfunction getEntity(entity) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(entity);\n    if (decoded.type === \"npub\") return npub(this, decoded.data);\n    if (decoded.type === \"nprofile\") return nprofile(this, decoded.data);\n    return decoded;\n  } catch (_e) {\n    return null;\n  }\n}\nfunction npub(ndk, pubkey) {\n  return ndk.getUser({ pubkey });\n}\nfunction nprofile(ndk, profile) {\n  const user = ndk.getUser({ pubkey: profile.pubkey });\n  if (profile.relays) user.relayUrls = profile.relays;\n  return user;\n}\n\n// src/ndk/fetch-event-from-tag.ts\nfunction isValidHint(hint) {\n  if (!hint || hint === \"\") return false;\n  try {\n    new URL(hint);\n    return true;\n  } catch (_e) {\n    return false;\n  }\n}\nasync function fetchEventFromTag(tag, originalEvent, subOpts, fallback = {\n  type: \"timeout\"\n}) {\n  const d4 = this.debug.extend(\"fetch-event-from-tag\");\n  const [_, id, hint] = tag;\n  subOpts = {};\n  d4(\"fetching event from tag\", tag, subOpts, fallback);\n  const authorRelays = getRelaysForSync(this, originalEvent.pubkey);\n  if (authorRelays && authorRelays.size > 0) {\n    d4(\"fetching event from author relays %o\", Array.from(authorRelays));\n    const relaySet2 = NDKRelaySet.fromRelayUrls(Array.from(authorRelays), this);\n    const event2 = await this.fetchEvent(id, subOpts, relaySet2);\n    if (event2) return event2;\n  } else {\n    d4(\"no author relays found for %s\", originalEvent.pubkey, originalEvent);\n  }\n  const relaySet = calculateRelaySetsFromFilters(this, [{ ids: [id] }], this.pool);\n  d4(\"fetching event without relay hint\", relaySet);\n  const event = await this.fetchEvent(id, subOpts);\n  if (event) return event;\n  if (hint && hint !== \"\") {\n    const event2 = await this.fetchEvent(id, subOpts, this.pool.getRelay(hint, true, true, [{ ids: [id] }]));\n    if (event2) return event2;\n  }\n  let result = void 0;\n  const relay = isValidHint(hint) ? this.pool.getRelay(hint, false, true, [{ ids: [id] }]) : void 0;\n  const fetchMaybeWithRelayHint = new Promise((resolve) => {\n    this.fetchEvent(id, subOpts, relay).then(resolve);\n  });\n  if (!isValidHint(hint) || fallback.type === \"none\") {\n    return fetchMaybeWithRelayHint;\n  }\n  const fallbackFetchPromise = new Promise(async (resolve) => {\n    const fallbackRelaySet = fallback.relaySet;\n    const timeout = fallback.timeout ?? 1500;\n    const timeoutPromise = new Promise((resolve2) => setTimeout(resolve2, timeout));\n    if (fallback.type === \"timeout\") await timeoutPromise;\n    if (result) {\n      resolve(result);\n    } else {\n      d4(\"fallback fetch triggered\");\n      const fallbackEvent = await this.fetchEvent(id, subOpts, fallbackRelaySet);\n      resolve(fallbackEvent);\n    }\n  });\n  switch (fallback.type) {\n    case \"timeout\":\n      return Promise.race([fetchMaybeWithRelayHint, fallbackFetchPromise]);\n    case \"eose\":\n      result = await fetchMaybeWithRelayHint;\n      if (result) return result;\n      return fallbackFetchPromise;\n  }\n}\n\n// src/ndk/queue/index.ts\nvar Queue = class {\n  queue = [];\n  maxConcurrency;\n  processing = /* @__PURE__ */ new Set();\n  promises = /* @__PURE__ */ new Map();\n  constructor(_name, maxConcurrency) {\n    this.maxConcurrency = maxConcurrency;\n  }\n  add(item) {\n    if (this.promises.has(item.id)) {\n      return this.promises.get(item.id);\n    }\n    const promise = new Promise((resolve, reject) => {\n      this.queue.push({\n        ...item,\n        func: () => item.func().then(\n          (result) => {\n            resolve(result);\n            return result;\n          },\n          (error) => {\n            reject(error);\n            throw error;\n          }\n        )\n      });\n      this.process();\n    });\n    this.promises.set(item.id, promise);\n    promise.finally(() => {\n      this.promises.delete(item.id);\n      this.processing.delete(item.id);\n      this.process();\n    });\n    return promise;\n  }\n  process() {\n    if (this.processing.size >= this.maxConcurrency || this.queue.length === 0) {\n      return;\n    }\n    const item = this.queue.shift();\n    if (!item || this.processing.has(item.id)) {\n      return;\n    }\n    this.processing.add(item.id);\n    item.func();\n  }\n  clear() {\n    this.queue = [];\n  }\n  clearProcessing() {\n    this.processing.clear();\n  }\n  clearAll() {\n    this.clear();\n    this.clearProcessing();\n  }\n  length() {\n    return this.queue.length;\n  }\n};\n\n// src/ndk/index.ts\nvar DEFAULT_OUTBOX_RELAYS = [\"wss://purplepag.es/\", \"wss://nos.lol/\"];\nvar DEFAULT_BLACKLISTED_RELAYS = [\n  \"wss://brb.io/\",\n  // BRB\n  \"wss://nostr.mutinywallet.com/\"\n  // Don't try to read from this relay since it's a write-only relay\n  // \"wss://purplepag.es/\", // This is a hack, since this is a mostly read-only relay, but not fully. Once we have relay routing this can be removed so it only receives the supported kinds\n];\nvar NDK = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  _explicitRelayUrls;\n  blacklistRelayUrls;\n  pool;\n  outboxPool;\n  _signer;\n  _activeUser;\n  cacheAdapter;\n  debug;\n  devWriteRelaySet;\n  outboxTracker;\n  mutedIds;\n  clientName;\n  clientNip89;\n  queuesZapConfig;\n  queuesNip05;\n  asyncSigVerification = false;\n  initialValidationRatio = 1;\n  lowestValidationRatio = 1;\n  validationRatioFn;\n  subManager;\n  publishingFailureHandled = false;\n  pools = [];\n  /**\n   * Default relay-auth policy that will be used when a relay requests authentication,\n   * if no other policy is specified for that relay.\n   *\n   * @example Disconnect from relays that request authentication:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.disconnect(ndk.pool);\n   * ```\n   *\n   * @example Sign in to relays that request authentication:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.signIn({ndk})\n   * ```\n   *\n   * @example Sign in to relays that request authentication, asking the user for confirmation:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = (relay: NDKRelay) => {\n   *     const signIn = NDKAuthPolicies.signIn({ndk});\n   *     if (confirm(`Relay ${relay.url} is requesting authentication, do you want to sign in?`)) {\n   *        signIn(relay);\n   *     }\n   * }\n   * ```\n   */\n  relayAuthDefaultPolicy;\n  /**\n   * Fetch function to use for HTTP requests.\n   *\n   * @example\n   * ```typescript\n   * import fetch from \"node-fetch\";\n   *\n   * ndk.httpFetch = fetch;\n   * ```\n   */\n  httpFetch;\n  /**\n   * Provide a caller function to receive all networking traffic from relays\n   */\n  netDebug;\n  autoConnectUserRelays = true;\n  autoFetchUserMutelist = true;\n  walletConfig;\n  constructor(opts = {}) {\n    super();\n    this.debug = opts.debug || debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk\");\n    this.netDebug = opts.netDebug;\n    this._explicitRelayUrls = opts.explicitRelayUrls || [];\n    this.blacklistRelayUrls = opts.blacklistRelayUrls || DEFAULT_BLACKLISTED_RELAYS;\n    this.subManager = new NDKSubscriptionManager();\n    this.pool = new NDKPool(opts.explicitRelayUrls || [], [], this);\n    this.pool.name = \"Main\";\n    this.pool.on(\"relay:auth\", async (relay, challenge) => {\n      if (this.relayAuthDefaultPolicy) {\n        await this.relayAuthDefaultPolicy(relay, challenge);\n      }\n    });\n    this.autoConnectUserRelays = opts.autoConnectUserRelays ?? true;\n    this.autoFetchUserMutelist = opts.autoFetchUserMutelist ?? true;\n    this.clientName = opts.clientName;\n    this.clientNip89 = opts.clientNip89;\n    this.relayAuthDefaultPolicy = opts.relayAuthDefaultPolicy;\n    if (opts.enableOutboxModel) {\n      this.outboxPool = new NDKPool(opts.outboxRelayUrls || DEFAULT_OUTBOX_RELAYS, [], this, {\n        debug: this.debug.extend(\"outbox-pool\"),\n        name: \"Outbox Pool\"\n      });\n      this.outboxTracker = new OutboxTracker(this);\n    }\n    this.signer = opts.signer;\n    this.cacheAdapter = opts.cacheAdapter;\n    this.mutedIds = opts.mutedIds || /* @__PURE__ */ new Map();\n    if (opts.devWriteRelayUrls) {\n      this.devWriteRelaySet = NDKRelaySet.fromRelayUrls(opts.devWriteRelayUrls, this);\n    }\n    this.queuesZapConfig = new Queue(\"zaps\", 3);\n    this.queuesNip05 = new Queue(\"nip05\", 10);\n    this.signatureVerificationWorker = opts.signatureVerificationWorker;\n    this.initialValidationRatio = opts.initialValidationRatio || 1;\n    this.lowestValidationRatio = opts.lowestValidationRatio || 1;\n    try {\n      this.httpFetch = fetch;\n    } catch {\n    }\n  }\n  set explicitRelayUrls(urls) {\n    this._explicitRelayUrls = urls.map(normalizeRelayUrl);\n    this.pool.relayUrls = urls;\n  }\n  get explicitRelayUrls() {\n    return this._explicitRelayUrls || [];\n  }\n  set signatureVerificationWorker(worker2) {\n    this.asyncSigVerification = !!worker2;\n    if (worker2) {\n      signatureVerificationInit(worker2);\n    }\n  }\n  /**\n   * Adds an explicit relay to the pool.\n   * @param url\n   * @param relayAuthPolicy Authentication policy to use if different from the default\n   * @param connect Whether to connect to the relay automatically\n   * @returns\n   */\n  addExplicitRelay(urlOrRelay, relayAuthPolicy, connect = true) {\n    let relay;\n    if (typeof urlOrRelay === \"string\") {\n      relay = new NDKRelay(urlOrRelay, relayAuthPolicy, this);\n    } else {\n      relay = urlOrRelay;\n    }\n    this.pool.addRelay(relay, connect);\n    this.explicitRelayUrls?.push(relay.url);\n    return relay;\n  }\n  toJSON() {\n    return { relayCount: this.pool.relays.size }.toString();\n  }\n  get activeUser() {\n    return this._activeUser;\n  }\n  /**\n   * Sets the active user for this NDK instance, typically this will be\n   * called when assigning a signer to the NDK instance.\n   *\n   * This function will automatically connect to the user's relays if\n   * `autoConnectUserRelays` is set to true.\n   *\n   * It will also fetch the user's mutelist if `autoFetchUserMutelist` is set to true.\n   */\n  set activeUser(user) {\n    const differentUser = this._activeUser?.pubkey !== user?.pubkey;\n    this._activeUser = user;\n    if (user && differentUser) {\n      setActiveUser.call(this, user);\n    } else if (!user) {\n      this.mutedIds = /* @__PURE__ */ new Map();\n    }\n  }\n  get signer() {\n    return this._signer;\n  }\n  set signer(newSigner) {\n    this._signer = newSigner;\n    if (newSigner) this.emit(\"signer:ready\", newSigner);\n    newSigner?.user().then((user) => {\n      user.ndk = this;\n      this.activeUser = user;\n    });\n  }\n  /**\n   * Connect to relays with optional timeout.\n   * If the timeout is reached, the connection will be continued to be established in the background.\n   */\n  async connect(timeoutMs) {\n    if (this._signer && this.autoConnectUserRelays) {\n      this.debug(\n        \"Attempting to connect to user relays specified by signer %o\",\n        await this._signer.relays?.(this)\n      );\n      if (this._signer.relays) {\n        const relays = await this._signer.relays(this);\n        relays.forEach((relay) => this.pool.addRelay(relay));\n      }\n    }\n    const connections = [this.pool.connect(timeoutMs)];\n    if (this.outboxPool) {\n      connections.push(this.outboxPool.connect(timeoutMs));\n    }\n    this.debug(\"Connecting to relays %o\", { timeoutMs });\n    return Promise.allSettled(connections).then(() => {\n    });\n  }\n  /**\n   * Get a NDKUser object\n   *\n   * @param opts\n   * @returns\n   */\n  getUser(opts) {\n    const user = new NDKUser(opts);\n    user.ndk = this;\n    return user;\n  }\n  /**\n   * Get a NDKUser from a NIP05\n   * @param nip05 NIP-05 ID\n   * @param skipCache Skip cache\n   * @returns\n   */\n  async getUserFromNip05(nip05, skipCache = false) {\n    return NDKUser.fromNip05(nip05, this, skipCache);\n  }\n  /**\n   * Creates and starts a new subscription.\n   *\n   * Subscriptions automatically start unless `autoStart` is set to `false`.\n   * You can control automatic closing on EOSE via `opts.closeOnEose`.\n   *\n   * @param filters - A single NDKFilter object or an array of filters.\n   * @param opts - Optional NDKSubscriptionOptions to customize behavior (e.g., caching, grouping).\n   * @param relaySet - Optional explicit NDKRelaySet to use for this subscription. If not provided, NDK calculates the optimal set.\n   * @param autoStart - Controls automatic starting and allows providing event handlers.\n   *   - `true` (default): Starts the subscription immediately.\n   *   - `false`: Creates the subscription but does not start it (call `subscription.start()` manually).\n   *   - `NDKSubscriptionEventHandlers` object: Starts the subscription immediately and attaches the provided handlers (`onEvent`, `onEvents`, `onEose`).\n   *     - Using `onEvents` changes behavior: it receives initial cached events in bulk, and `onEvent` is skipped for that initial batch. See {@link NDKSubscriptionEventHandlers}.\n   * @returns The created NDKSubscription instance.\n   *\n   * @example Basic subscription\n   * ```typescript\n   * const sub = ndk.subscribe({ kinds: [1], authors: [pubkey] });\n   * sub.on(\"event\", (event) => console.log(\"Kind 1 event:\", event.content));\n   * ```\n   *\n   * @example Subscription with options and direct handlers\n   * ```typescript\n   * const sub = ndk.subscribe(\n   *   { kinds: [0], authors: [pubkey] },\n   *   { closeOnEose: true, cacheUsage: NDKSubscriptionCacheUsage.PARALLEL },\n   *   undefined, // Use default relay set calculation\n   *   {\n   *     onEvents: (events) => { // Renamed parameter\n   *       if (events.length > 0) {\n   *         console.log(`Got ${events.length} profile events from cache:`, events[0].content);\n   *       }\n   *     },\n   *     onEvent: (event) => { // Renamed parameter\n   *       console.log(\"Got profile update from relay:\", event.content); // Clarified source\n   *     },\n   *     onEose: () => console.log(\"Profile subscription finished.\")\n   *   }\n   * );\n   * ```\n   *\n   * @since 2.13.0 `relaySet` parameter removed; pass `relaySet` or `relayUrls` via `opts`.\n   */\n  subscribe(filters, opts, autoStart = true) {\n    const subscription = new NDKSubscription(this, filters, opts);\n    this.subManager.add(subscription);\n    const pool = subscription.pool;\n    if (subscription.relaySet) {\n      for (const relay of subscription.relaySet.relays) {\n        pool.useTemporaryRelay(relay, void 0, subscription.filters);\n      }\n    }\n    if (this.outboxPool && subscription.hasAuthorsFilter()) {\n      const authors = subscription.filters.filter((filter) => filter.authors && filter.authors?.length > 0).flatMap((filter) => filter.authors);\n      this.outboxTracker?.trackUsers(authors);\n    }\n    if (autoStart) {\n      let eventsHandler;\n      if (typeof autoStart === \"object\") {\n        if (autoStart.onEvent) subscription.on(\"event\", autoStart.onEvent);\n        if (autoStart.onEose) subscription.on(\"eose\", autoStart.onEose);\n        if (autoStart.onEvents) eventsHandler = autoStart.onEvents;\n      }\n      setTimeout(() => {\n        const cachedEvents = subscription.start(!eventsHandler);\n        if (cachedEvents && cachedEvents.length > 0 && !!eventsHandler) eventsHandler(cachedEvents);\n      }, 0);\n    }\n    return subscription;\n  }\n  /**\n   * Publish an event to a relay\n   * @param event event to publish\n   * @param relaySet explicit relay set to use\n   * @param timeoutMs timeout in milliseconds to wait for the event to be published\n   * @returns The relays the event was published to\n   *\n   * @deprecated Use `event.publish()` instead\n   */\n  async publish(event, relaySet, timeoutMs) {\n    this.debug(\"Deprecated: Use `event.publish()` instead\");\n    return event.publish(relaySet, timeoutMs);\n  }\n  /**\n   * Attempts to fetch an event from a tag, following relay hints and\n   * other best practices.\n   * @param tag Tag to fetch the event from\n   * @param originalEvent Event where the tag came from\n   * @param subOpts Subscription options to use when fetching the event\n   * @param fallback Fallback options to use when the hint relay doesn't respond\n   * @returns\n   */\n  fetchEventFromTag = fetchEventFromTag.bind(this);\n  /**\n   * Fetch an event from the cache synchronously.\n   * @param idOrFilter event id in bech32 format or filter\n   * @returns events from the cache or null if the cache is empty\n   */\n  fetchEventSync(idOrFilter) {\n    if (!this.cacheAdapter) throw new Error(\"Cache adapter not set\");\n    let filters;\n    if (typeof idOrFilter === \"string\") filters = [filterFromId(idOrFilter)];\n    else filters = idOrFilter;\n    const sub = new NDKSubscription(this, filters);\n    const events = this.cacheAdapter.query(sub);\n    if (events instanceof Promise) throw new Error(\"Cache adapter is async\");\n    return events.map((e) => {\n      e.ndk = this;\n      return e;\n    });\n  }\n  /**\n   * Fetch a single event.\n   *\n   * @param idOrFilter event id in bech32 format or filter\n   * @param opts subscription options\n   * @param relaySetOrRelay explicit relay set to use\n   */\n  async fetchEvent(idOrFilter, opts, relaySetOrRelay) {\n    let filters;\n    let relaySet;\n    if (relaySetOrRelay instanceof NDKRelay) {\n      relaySet = new NDKRelaySet(/* @__PURE__ */ new Set([relaySetOrRelay]), this);\n    } else if (relaySetOrRelay instanceof NDKRelaySet) {\n      relaySet = relaySetOrRelay;\n    }\n    if (!relaySetOrRelay && typeof idOrFilter === \"string\") {\n      if (!isNip33AValue(idOrFilter)) {\n        const relays = relaysFromBech32(idOrFilter, this);\n        if (relays.length > 0) {\n          relaySet = new NDKRelaySet(new Set(relays), this);\n          relaySet = correctRelaySet(relaySet, this.pool);\n        }\n      }\n    }\n    if (typeof idOrFilter === \"string\") {\n      filters = [filterFromId(idOrFilter)];\n    } else if (Array.isArray(idOrFilter)) {\n      filters = idOrFilter;\n    } else {\n      filters = [idOrFilter];\n    }\n    if (filters.length === 0) {\n      throw new Error(`Invalid filter: ${JSON.stringify(idOrFilter)}`);\n    }\n    return new Promise((resolve) => {\n      let fetchedEvent = null;\n      const subscribeOpts = {\n        ...opts || {},\n        closeOnEose: true\n      };\n      if (relaySet) subscribeOpts.relaySet = relaySet;\n      const s = this.subscribe(\n        filters,\n        subscribeOpts,\n        // relaySet, // Removed: Passed via opts\n        false\n        // autoStart = false\n      );\n      const t2 = setTimeout(() => {\n        s.stop();\n        resolve(fetchedEvent);\n      }, 1e4);\n      s.on(\"event\", (event) => {\n        event.ndk = this;\n        if (!event.isReplaceable()) {\n          clearTimeout(t2);\n          resolve(event);\n        } else if (!fetchedEvent || fetchedEvent.created_at < event.created_at) {\n          fetchedEvent = event;\n        }\n      });\n      s.on(\"eose\", () => {\n        clearTimeout(t2);\n        resolve(fetchedEvent);\n      });\n      s.start();\n    });\n  }\n  /**\n   * Fetch events\n   */\n  async fetchEvents(filters, opts, relaySet) {\n    return new Promise((resolve) => {\n      const events = /* @__PURE__ */ new Map();\n      const subscribeOpts = {\n        ...opts || {},\n        closeOnEose: true\n      };\n      if (relaySet) subscribeOpts.relaySet = relaySet;\n      const relaySetSubscription = this.subscribe(\n        filters,\n        subscribeOpts,\n        // relaySet, // Removed: Passed via opts\n        false\n        // autoStart = false\n      );\n      const onEvent = (event) => {\n        let _event;\n        if (!(event instanceof NDKEvent)) _event = new NDKEvent(void 0, event);\n        else _event = event;\n        const dedupKey = _event.deduplicationKey();\n        const existingEvent = events.get(dedupKey);\n        if (existingEvent) {\n          _event = dedup(existingEvent, _event);\n        }\n        _event.ndk = this;\n        events.set(dedupKey, _event);\n      };\n      relaySetSubscription.on(\"event\", onEvent);\n      relaySetSubscription.on(\"eose\", () => {\n        resolve(new Set(events.values()));\n      });\n      relaySetSubscription.start();\n    });\n  }\n  /**\n   * Ensures that a signer is available to sign an event.\n   */\n  assertSigner() {\n    if (!this.signer) {\n      this.emit(\"signer:required\");\n      throw new Error(\"Signer required\");\n    }\n  }\n  getEntity = getEntity.bind(this);\n  set wallet(wallet) {\n    if (!wallet) {\n      this.walletConfig = void 0;\n      return;\n    }\n    this.walletConfig ??= {};\n    this.walletConfig.lnPay = wallet?.lnPay?.bind(wallet);\n    this.walletConfig.cashuPay = wallet?.cashuPay?.bind(wallet);\n  }\n};\n\n// src/zap/invoice.ts\n\nfunction zapInvoiceFromEvent(event) {\n  const description = event.getMatchingTags(\"description\")[0];\n  const bolt11 = event.getMatchingTags(\"bolt11\")[0];\n  let decodedInvoice;\n  let zapRequest;\n  if (!description || !bolt11 || !bolt11[1]) {\n    return null;\n  }\n  try {\n    let zapRequestPayload = description[1];\n    if (zapRequestPayload.startsWith(\"%\")) {\n      zapRequestPayload = decodeURIComponent(zapRequestPayload);\n    }\n    if (zapRequestPayload === \"\") {\n      return null;\n    }\n    zapRequest = JSON.parse(zapRequestPayload);\n    decodedInvoice = (0,light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_7__.decode)(bolt11[1]);\n  } catch (_e) {\n    return null;\n  }\n  const amountSection = decodedInvoice.sections.find((s) => s.name === \"amount\");\n  if (!amountSection) {\n    return null;\n  }\n  const amount = Number.parseInt(amountSection.value);\n  if (!amount) {\n    return null;\n  }\n  const content = zapRequest.content;\n  const sender = zapRequest.pubkey;\n  const recipientTag = event.getMatchingTags(\"p\")[0];\n  const recipient = recipientTag[1];\n  let zappedEvent = event.getMatchingTags(\"e\")[0];\n  if (!zappedEvent) {\n    zappedEvent = event.getMatchingTags(\"a\")[0];\n  }\n  const zappedEventId = zappedEvent ? zappedEvent[1] : void 0;\n  const zapInvoice = {\n    id: event.id,\n    zapper: event.pubkey,\n    zappee: sender,\n    zapped: recipient,\n    zappedEvent: zappedEventId,\n    amount,\n    comment: content\n  };\n  return zapInvoice;\n}\n\n// src/zapper/index.ts\n\n\n\n// src/zapper/ln.ts\n\n\nvar d2 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:zapper:ln\");\nasync function getNip57ZapSpecFromLud({ lud06, lud16 }, ndk) {\n  let zapEndpoint;\n  if (lud16 && !lud16.startsWith(\"LNURL\")) {\n    const [name, domain] = lud16.split(\"@\");\n    zapEndpoint = `https://${domain}/.well-known/lnurlp/${name}`;\n  } else if (lud06) {\n    const { words } = _scure_base__WEBPACK_IMPORTED_MODULE_8__.bech32.decode(lud06, 1e3);\n    const data = _scure_base__WEBPACK_IMPORTED_MODULE_8__.bech32.fromWords(words);\n    const utf8Decoder = new TextDecoder(\"utf-8\");\n    zapEndpoint = utf8Decoder.decode(data);\n  }\n  if (!zapEndpoint) {\n    d2(\"No zap endpoint found %o\", { lud06, lud16 });\n    throw new Error(\"No zap endpoint found\");\n  }\n  try {\n    const _fetch = ndk.httpFetch || fetch;\n    const response = await _fetch(zapEndpoint);\n    if (response.status !== 200) {\n      const text = await response.text();\n      throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${text}`);\n    }\n    return await response.json();\n  } catch (e) {\n    throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${e}`);\n  }\n}\n\n// src/zapper/nip57.ts\n\nasync function generateZapRequest(target, ndk, data, pubkey, amount, relays, comment, tags, signer) {\n  const zapEndpoint = data.callback;\n  const zapRequest = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip57.makeZapRequest({\n    profile: pubkey,\n    // set the event to null since nostr-tools doesn't support nip-33 zaps\n    event: null,\n    amount,\n    comment: comment || \"\",\n    relays: relays.slice(0, 4)\n  });\n  if (target instanceof NDKEvent) {\n    const tags2 = target.referenceTags();\n    const nonPTags = tags2.filter((tag) => tag[0] !== \"p\");\n    zapRequest.tags.push(...nonPTags);\n  }\n  zapRequest.tags.push([\"lnurl\", zapEndpoint]);\n  const event = new NDKEvent(ndk, zapRequest);\n  if (tags) {\n    event.tags = event.tags.concat(tags);\n  }\n  const eTaggedEvents = /* @__PURE__ */ new Set();\n  const aTaggedEvents = /* @__PURE__ */ new Set();\n  for (const tag of event.tags) {\n    if (tag[0] === \"e\") {\n      eTaggedEvents.add(tag[1]);\n    } else if (tag[0] === \"a\") {\n      aTaggedEvents.add(tag[1]);\n    }\n  }\n  if (eTaggedEvents.size > 1) throw new Error(\"Only one e-tag is allowed\");\n  if (aTaggedEvents.size > 1) throw new Error(\"Only one a-tag is allowed\");\n  event.tags = event.tags.filter((tag) => tag[0] !== \"p\");\n  event.tags.push([\"p\", pubkey]);\n  await event.sign(signer);\n  return event;\n}\n\n// src/zapper/index.ts\nvar d3 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:zapper\");\nvar NDKZapper = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  target;\n  ndk;\n  comment;\n  amount;\n  unit;\n  tags;\n  signer;\n  zapMethod;\n  nutzapAsFallback;\n  lnPay;\n  /**\n   * Called when a cashu payment is to be made.\n   * This function should swap/mint proofs for the required amount, in the required unit,\n   * in any of the provided mints and return the proofs and mint used.\n   */\n  cashuPay;\n  onComplete;\n  maxRelays = 3;\n  /**\n   *\n   * @param target The target of the zap\n   * @param amount The amount to send indicated in the unit\n   * @param unit The unit of the amount\n   * @param opts Options for the zap\n   */\n  constructor(target, amount, unit = \"msat\", opts = {}) {\n    super();\n    this.target = target;\n    this.ndk = opts.ndk || target.ndk;\n    if (!this.ndk) {\n      throw new Error(\"No NDK instance provided\");\n    }\n    this.amount = amount;\n    this.comment = opts.comment;\n    this.unit = unit;\n    this.tags = opts.tags;\n    this.signer = opts.signer;\n    this.nutzapAsFallback = opts.nutzapAsFallback ?? false;\n    this.lnPay = opts.lnPay || this.ndk.walletConfig?.lnPay;\n    this.cashuPay = opts.cashuPay || this.ndk.walletConfig?.cashuPay;\n    this.onComplete = opts.onComplete || this.ndk.walletConfig?.onPaymentComplete;\n  }\n  /**\n   * Initiate zapping process\n   *\n   * This function will calculate the splits for this zap and initiate each zap split.\n   */\n  async zap(methods) {\n    const splits = this.getZapSplits();\n    const results = /* @__PURE__ */ new Map();\n    await Promise.all(\n      splits.map(async (split) => {\n        let result;\n        try {\n          result = await this.zapSplit(split, methods);\n        } catch (e) {\n          result = new Error(e.message);\n        }\n        this.emit(\"split:complete\", split, result);\n        results.set(split, result);\n      })\n    );\n    this.emit(\"complete\", results);\n    if (this.onComplete) this.onComplete(results);\n    return results;\n  }\n  async zapNip57(split, data) {\n    if (!this.lnPay) throw new Error(\"No lnPay function available\");\n    const zapSpec = await getNip57ZapSpecFromLud(data, this.ndk);\n    if (!zapSpec) throw new Error(\"No zap spec available for recipient\");\n    const relays = await this.relays(split.pubkey);\n    const zapRequest = await generateZapRequest(\n      this.target,\n      this.ndk,\n      zapSpec,\n      split.pubkey,\n      split.amount,\n      relays,\n      this.comment,\n      this.tags,\n      this.signer\n    );\n    if (!zapRequest) {\n      d3(\"Unable to generate zap request\");\n      throw new Error(\"Unable to generate zap request\");\n    }\n    const pr = await this.getLnInvoice(zapRequest, split.amount, zapSpec);\n    if (!pr) {\n      d3(\"Unable to get payment request\");\n      throw new Error(\"Unable to get payment request\");\n    }\n    this.emit(\"ln_invoice\", {\n      amount: split.amount,\n      recipientPubkey: split.pubkey,\n      unit: this.unit,\n      nip57ZapRequest: zapRequest,\n      pr,\n      type: \"nip57\"\n    });\n    const res = await this.lnPay({\n      target: this.target,\n      recipientPubkey: split.pubkey,\n      paymentDescription: \"NIP-57 Zap\",\n      pr,\n      amount: split.amount,\n      unit: this.unit,\n      nip57ZapRequest: zapRequest\n    });\n    if (res?.preimage) {\n      this.emit(\"ln_payment\", {\n        preimage: res.preimage,\n        amount: split.amount,\n        recipientPubkey: split.pubkey,\n        pr,\n        unit: this.unit,\n        nip57ZapRequest: zapRequest,\n        type: \"nip57\"\n      });\n    }\n    return res;\n  }\n  /**\n   * Fetches information about a NIP-61 zap and asks the caller to create cashu proofs for the zap.\n   *\n   * (note that the cashuPay function can use any method to create the proofs, including using lightning\n   * to mint proofs in the specified mint, the responsibility of minting the proofs is delegated to the caller (e.g. ndk-wallet))\n   */\n  async zapNip61(split, data) {\n    if (!this.cashuPay) throw new Error(\"No cashuPay function available\");\n    let ret;\n    ret = await this.cashuPay(\n      {\n        target: this.target,\n        recipientPubkey: split.pubkey,\n        paymentDescription: \"NIP-61 Zap\",\n        amount: split.amount,\n        unit: this.unit,\n        ...data ?? {}\n      },\n      (pr) => {\n        this.emit(\"ln_invoice\", {\n          pr,\n          amount: split.amount,\n          recipientPubkey: split.pubkey,\n          unit: this.unit,\n          type: \"nip61\"\n        });\n      }\n    );\n    d3(\"NIP-61 Zap result: %o\", ret);\n    if (ret instanceof Error) {\n      return ret;\n    }\n    if (ret) {\n      const { proofs, mint } = ret;\n      if (!proofs || !mint) throw new Error(`Invalid zap confirmation: missing proofs or mint: ${ret}`);\n      const relays = await this.relays(split.pubkey);\n      const relaySet = NDKRelaySet.fromRelayUrls(relays, this.ndk);\n      const nutzap = new NDKNutzap(this.ndk);\n      nutzap.tags = [...nutzap.tags, ...this.tags || []];\n      nutzap.proofs = proofs;\n      nutzap.mint = mint;\n      nutzap.target = this.target;\n      nutzap.comment = this.comment;\n      nutzap.unit = \"sat\";\n      nutzap.recipientPubkey = split.pubkey;\n      await nutzap.sign(this.signer);\n      nutzap.publish(relaySet);\n      return nutzap;\n    }\n  }\n  /**\n   * Get the zap methods available for the recipient and initiates the zap\n   * in the desired method.\n   * @param split\n   * @param methods - The methods to try, if not provided, all methods will be tried.\n   * @returns\n   */\n  async zapSplit(split, methods) {\n    const recipient = this.ndk.getUser({ pubkey: split.pubkey });\n    const zapMethods = await recipient.getZapInfo(2500);\n    let retVal;\n    const canFallbackToNip61 = this.nutzapAsFallback && this.cashuPay;\n    if (zapMethods.size === 0 && !canFallbackToNip61)\n      throw new Error(\"No zap method available for recipient and NIP-61 fallback is disabled\");\n    const nip61Fallback = async () => {\n      if (!this.nutzapAsFallback) return;\n      const relayLists = await getRelayListForUsers([split.pubkey], this.ndk);\n      let relayUrls = relayLists.get(split.pubkey)?.readRelayUrls;\n      relayUrls = this.ndk.pool.connectedRelays().map((r) => r.url);\n      return await this.zapNip61(split, {\n        // use the user's relay list\n        relays: relayUrls,\n        // lock to the user's actual pubkey\n        p2pk: split.pubkey,\n        // allow intramint fallback\n        allowIntramintFallback: !!canFallbackToNip61\n      });\n    };\n    const canUseNip61 = !methods || methods.includes(\"nip61\");\n    const canUseNip57 = !methods || methods.includes(\"nip57\");\n    const nip61Method = zapMethods.get(\"nip61\");\n    if (nip61Method && canUseNip61) {\n      try {\n        retVal = await this.zapNip61(split, nip61Method);\n        if (retVal instanceof NDKNutzap) return retVal;\n      } catch (e) {\n        this.emit(\"notice\", `NIP-61 attempt failed: ${e.message}`);\n      }\n    }\n    const nip57Method = zapMethods.get(\"nip57\");\n    if (nip57Method && canUseNip57) {\n      try {\n        retVal = await this.zapNip57(split, nip57Method);\n        if (!(retVal instanceof Error)) return retVal;\n      } catch (e) {\n        this.emit(\"notice\", `NIP-57 attempt failed: ${e.message}`);\n      }\n    }\n    if (canFallbackToNip61) {\n      retVal = await nip61Fallback();\n      if (retVal instanceof Error) throw retVal;\n      return retVal;\n    }\n    this.emit(\"notice\", \"Zap methods exhausted and there was no fallback to NIP-61\");\n    if (retVal instanceof Error) throw retVal;\n    return retVal;\n  }\n  /**\n   * Gets a bolt11 for a nip57 zap\n   * @param event\n   * @param amount\n   * @param zapEndpoint\n   * @returns\n   */\n  async getLnInvoice(zapRequest, amount, data) {\n    const zapEndpoint = data.callback;\n    const eventPayload = JSON.stringify(zapRequest.rawEvent());\n    d3(\n      `Fetching invoice from ${zapEndpoint}?${new URLSearchParams({\n        amount: amount.toString(),\n        nostr: eventPayload\n      })}`\n    );\n    const url = new URL(zapEndpoint);\n    url.searchParams.append(\"amount\", amount.toString());\n    url.searchParams.append(\"nostr\", eventPayload);\n    d3(`Fetching invoice from ${url.toString()}`);\n    const response = await fetch(url.toString());\n    d3(`Got response from zap endpoint: ${zapEndpoint}`, { status: response.status });\n    if (response.status !== 200) {\n      d3(`Received non-200 status from zap endpoint: ${zapEndpoint}`, {\n        status: response.status,\n        amount,\n        nostr: eventPayload\n      });\n      const text = await response.text();\n      throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${text}`);\n    }\n    const body = await response.json();\n    return body.pr;\n  }\n  getZapSplits() {\n    if (this.target instanceof NDKUser) {\n      return [\n        {\n          pubkey: this.target.pubkey,\n          amount: this.amount\n        }\n      ];\n    }\n    const zapTags = this.target.getMatchingTags(\"zap\");\n    if (zapTags.length === 0) {\n      return [\n        {\n          pubkey: this.target.pubkey,\n          amount: this.amount\n        }\n      ];\n    }\n    const splits = [];\n    const total = zapTags.reduce((acc, tag) => acc + Number.parseInt(tag[2]), 0);\n    for (const tag of zapTags) {\n      const pubkey = tag[1];\n      const amount = Math.floor(Number.parseInt(tag[2]) / total * this.amount);\n      splits.push({ pubkey, amount });\n    }\n    return splits;\n  }\n  /**\n   * Gets the zap method that should be used to zap a pubbkey\n   * @param ndk\n   * @param pubkey\n   * @returns\n   */\n  async getZapMethods(ndk, recipient, timeout = 2500) {\n    const user = ndk.getUser({ pubkey: recipient });\n    return await user.getZapInfo(timeout);\n  }\n  /**\n   * @returns the relays to use for the zap request\n   */\n  async relays(pubkey) {\n    let r = [];\n    if (this.ndk?.activeUser) {\n      const relayLists = await getRelayListForUsers([this.ndk.activeUser.pubkey, pubkey], this.ndk);\n      const relayScores = /* @__PURE__ */ new Map();\n      for (const relayList of relayLists.values()) {\n        for (const url of relayList.readRelayUrls) {\n          const score = relayScores.get(url) || 0;\n          relayScores.set(url, score + 1);\n        }\n      }\n      r = Array.from(relayScores.entries()).sort((a, b) => b[1] - a[1]).map(([url]) => url).slice(0, this.maxRelays);\n    }\n    if (this.ndk?.pool?.permanentAndConnectedRelays().length) {\n      r = this.ndk.pool.permanentAndConnectedRelays().map((relay) => relay.url);\n    }\n    if (!r.length) {\n      r = [];\n    }\n    return r;\n  }\n};\n\n// src/utils/filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (const f in filter) {\n    if (f[0] === \"#\") {\n      const tagName = f.slice(1);\n      if (tagName === \"t\") {\n        const values = filter[`#${tagName}`]?.map((v) => v.toLowerCase());\n        if (values && !event.tags.find(([t, v]) => t === tagName && values?.indexOf(v.toLowerCase()) !== -1))\n          return false;\n      } else {\n        const values = filter[`#${tagName}`];\n        if (values && !event.tags.find(([t, v]) => t === tagName && values?.indexOf(v) !== -1)) return false;\n      }\n    }\n  }\n  if (filter.since && event.created_at < filter.since) return false;\n  if (filter.until && event.created_at > filter.until) return false;\n  return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxD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QUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSyxhQUFhLEtBQUs7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMwQjtBQUNXOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxLQUFLO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUNBQXlDLGtCQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsR0FBRztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtDQUErQyxrQkFBa0IsSUFBSSxjQUFjO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMERBQTBELG1CQUFtQixFQUFFLFVBQVU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx1QkFBdUIsMkNBQTJDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjtBQUN2Qix1Q0FBdUMsK0NBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0NBQUssY0FBYyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVLElBQUksSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsOENBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsU0FBUyw4Q0FBTTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0Msa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzhDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOENBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSyxFQUFFLEVBQUU7QUFDN0I7QUFDQSxNQUFNO0FBQ04sa0JBQWtCLEtBQUssRUFBRSxNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHVCQUF1QixLQUFLLEdBQUcsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa0NBQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtDQUFrQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkNBQTJDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0IsR0FBRyxvQkFBb0IsR0FBRyx3QkFBd0I7QUFDeEY7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQU07QUFDdEI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4Q0FBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQ0FBaUM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtDQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxtQ0FBbUM7QUFDckY7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLDhDQUE4QyxzQkFBc0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sdUNBQXVDO0FBQzdDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU8sK0JBQStCLEtBQUs7QUFDdkYsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osc0RBQXNELE1BQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4Q0FBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOENBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOENBQU07QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLCtCQUErQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlEQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNB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QUNyRDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3NEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdURBQXVELDJDQUEyQztBQUNsRztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx5REFBeUQsWUFBWSxJQUFJLFNBQVM7QUFDbEY7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCwrQ0FBYTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPLEdBQUcsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFlBQVk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSwrQkFBK0Isa0NBQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQ0FBbUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFdBQVc7QUFDdkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0EsK0JBQStCLFlBQVksR0FBRztBQUM5QztBQUNBO0FBQ0EsT0FBTyxFQUFFO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBLDBDQUEwQyxZQUFZLEtBQUsseUJBQXlCO0FBQ3BGO0FBQ0EsdURBQXVELFlBQVk7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esc0RBQXNELFlBQVksSUFBSSxLQUFLO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0EsUUFBUTtBQUNSLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFvSEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9naWdpL0RldmVsb3BtZW50L3ZpYmUvcHViY2FzdGVyL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3R5cGVzLnRzXG52YXIgTmRrTnV0emFwU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoTmRrTnV0emFwU3RhdHVzMikgPT4ge1xuICBOZGtOdXR6YXBTdGF0dXMyW1wiSU5JVElBTFwiXSA9IFwiaW5pdGlhbFwiO1xuICBOZGtOdXR6YXBTdGF0dXMyW1wiUFJPQ0VTU0lOR1wiXSA9IFwicHJvY2Vzc2luZ1wiO1xuICBOZGtOdXR6YXBTdGF0dXMyW1wiUkVERUVNRURcIl0gPSBcInJlZGVlbWVkXCI7XG4gIE5ka051dHphcFN0YXR1czJbXCJTUEVOVFwiXSA9IFwic3BlbnRcIjtcbiAgTmRrTnV0emFwU3RhdHVzMltcIk1JU1NJTkdfUFJJVktFWVwiXSA9IFwibWlzc2luZ19wcml2a2V5XCI7XG4gIE5ka051dHphcFN0YXR1czJbXCJURU1QT1JBUllfRVJST1JcIl0gPSBcInRlbXBvcmFyeV9lcnJvclwiO1xuICBOZGtOdXR6YXBTdGF0dXMyW1wiUEVSTUFORU5UX0VSUk9SXCJdID0gXCJwZXJtYW5lbnRfZXJyb3JcIjtcbiAgTmRrTnV0emFwU3RhdHVzMltcIklOVkFMSURfTlVUWkFQXCJdID0gXCJpbnZhbGlkX251dHphcFwiO1xuICByZXR1cm4gTmRrTnV0emFwU3RhdHVzMjtcbn0pKE5ka051dHphcFN0YXR1cyB8fCB7fSk7XG5cbi8vIHNyYy9ldmVudHMva2luZHMvaW5kZXgudHNcbnZhciBOREtLaW5kID0gLyogQF9fUFVSRV9fICovICgoTkRLS2luZDIpID0+IHtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNZXRhZGF0YVwiXSA9IDBdID0gXCJNZXRhZGF0YVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlRleHRcIl0gPSAxXSA9IFwiVGV4dFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlY29tbWVuZFJlbGF5XCJdID0gMl0gPSBcIlJlY29tbWVuZFJlbGF5XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ29udGFjdHNcIl0gPSAzXSA9IFwiQ29udGFjdHNcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJFbmNyeXB0ZWREaXJlY3RNZXNzYWdlXCJdID0gNF0gPSBcIkVuY3J5cHRlZERpcmVjdE1lc3NhZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJFdmVudERlbGV0aW9uXCJdID0gNV0gPSBcIkV2ZW50RGVsZXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJSZXBvc3RcIl0gPSA2XSA9IFwiUmVwb3N0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUmVhY3Rpb25cIl0gPSA3XSA9IFwiUmVhY3Rpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCYWRnZUF3YXJkXCJdID0gOF0gPSBcIkJhZGdlQXdhcmRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cENoYXRcIl0gPSA5XSA9IFwiR3JvdXBDaGF0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBOb3RlXCJdID0gMTFdID0gXCJHcm91cE5vdGVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cFJlcGx5XCJdID0gMTJdID0gXCJHcm91cFJlcGx5XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR2lmdFdyYXBTZWFsXCJdID0gMTNdID0gXCJHaWZ0V3JhcFNlYWxcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJQcml2YXRlRGlyZWN0TWVzc2FnZVwiXSA9IDE0XSA9IFwiUHJpdmF0ZURpcmVjdE1lc3NhZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJJbWFnZVwiXSA9IDIwXSA9IFwiSW1hZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJWaWRlb1wiXSA9IDIxXSA9IFwiVmlkZW9cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJTaG9ydFZpZGVvXCJdID0gMjJdID0gXCJTaG9ydFZpZGVvXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU3RvcnlcIl0gPSAyM10gPSBcIlN0b3J5XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVmFuaXNoXCJdID0gNjJdID0gXCJWYW5pc2hcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXNodVdhbGxldEJhY2t1cFwiXSA9IDM3NV0gPSBcIkNhc2h1V2FsbGV0QmFja3VwXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR2lmdFdyYXBcIl0gPSAxMDU5XSA9IFwiR2lmdFdyYXBcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHZW5lcmljUmVwb3N0XCJdID0gMTZdID0gXCJHZW5lcmljUmVwb3N0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2hhbm5lbENyZWF0aW9uXCJdID0gNDBdID0gXCJDaGFubmVsQ3JlYXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDaGFubmVsTWV0YWRhdGFcIl0gPSA0MV0gPSBcIkNoYW5uZWxNZXRhZGF0YVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNoYW5uZWxNZXNzYWdlXCJdID0gNDJdID0gXCJDaGFubmVsTWVzc2FnZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNoYW5uZWxIaWRlTWVzc2FnZVwiXSA9IDQzXSA9IFwiQ2hhbm5lbEhpZGVNZXNzYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2hhbm5lbE11dGVVc2VyXCJdID0gNDRdID0gXCJDaGFubmVsTXV0ZVVzZXJcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHZW5lcmljUmVwbHlcIl0gPSAxMTExXSA9IFwiR2VuZXJpY1JlcGx5XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTWVkaWFcIl0gPSAxMDYzXSA9IFwiTWVkaWFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJSZXBvcnRcIl0gPSAxOTg0XSA9IFwiUmVwb3J0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTGFiZWxcIl0gPSAxOTg1XSA9IFwiTGFiZWxcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUZXh0RXh0cmFjdGlvblwiXSA9IDVlM10gPSBcIkRWTVJlcVRleHRFeHRyYWN0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxVGV4dFN1bW1hcml6YXRpb25cIl0gPSA1MDAxXSA9IFwiRFZNUmVxVGV4dFN1bW1hcml6YXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUZXh0VHJhbnNsYXRpb25cIl0gPSA1MDAyXSA9IFwiRFZNUmVxVGV4dFRyYW5zbGF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxVGV4dEdlbmVyYXRpb25cIl0gPSA1MDUwXSA9IFwiRFZNUmVxVGV4dEdlbmVyYXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFJbWFnZUdlbmVyYXRpb25cIl0gPSA1MTAwXSA9IFwiRFZNUmVxSW1hZ2VHZW5lcmF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxVGV4dFRvU3BlZWNoXCJdID0gNTI1MF0gPSBcIkRWTVJlcVRleHRUb1NwZWVjaFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcURpc2NvdmVyeU5vc3RyQ29udGVudFwiXSA9IDUzMDBdID0gXCJEVk1SZXFEaXNjb3ZlcnlOb3N0ckNvbnRlbnRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFEaXNjb3ZlcnlOb3N0clBlb3BsZVwiXSA9IDUzMDFdID0gXCJEVk1SZXFEaXNjb3ZlcnlOb3N0clBlb3BsZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcVRpbWVzdGFtcGluZ1wiXSA9IDU5MDBdID0gXCJEVk1SZXFUaW1lc3RhbXBpbmdcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1FdmVudFNjaGVkdWxlXCJdID0gNTkwNV0gPSBcIkRWTUV2ZW50U2NoZWR1bGVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1Kb2JGZWVkYmFja1wiXSA9IDdlM10gPSBcIkRWTUpvYkZlZWRiYWNrXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU3Vic2NyaWJlXCJdID0gNzAwMV0gPSBcIlN1YnNjcmliZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlVuc3Vic2NyaWJlXCJdID0gNzAwMl0gPSBcIlVuc3Vic2NyaWJlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU3Vic2NyaXB0aW9uUmVjZWlwdFwiXSA9IDcwMDNdID0gXCJTdWJzY3JpcHRpb25SZWNlaXB0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVSZXNlcnZlXCJdID0gNzM3M10gPSBcIkNhc2h1UmVzZXJ2ZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhc2h1UXVvdGVcIl0gPSA3Mzc0XSA9IFwiQ2FzaHVRdW90ZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhc2h1VG9rZW5cIl0gPSA3Mzc1XSA9IFwiQ2FzaHVUb2tlblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhc2h1V2FsbGV0VHhcIl0gPSA3Mzc2XSA9IFwiQ2FzaHVXYWxsZXRUeFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5BZGRVc2VyXCJdID0gOWUzXSA9IFwiR3JvdXBBZG1pbkFkZFVzZXJcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluUmVtb3ZlVXNlclwiXSA9IDkwMDFdID0gXCJHcm91cEFkbWluUmVtb3ZlVXNlclwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5FZGl0TWV0YWRhdGFcIl0gPSA5MDAyXSA9IFwiR3JvdXBBZG1pbkVkaXRNZXRhZGF0YVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5FZGl0U3RhdHVzXCJdID0gOTAwNl0gPSBcIkdyb3VwQWRtaW5FZGl0U3RhdHVzXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pbkNyZWF0ZUdyb3VwXCJdID0gOTAwN10gPSBcIkdyb3VwQWRtaW5DcmVhdGVHcm91cFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5SZXF1ZXN0Sm9pblwiXSA9IDkwMjFdID0gXCJHcm91cEFkbWluUmVxdWVzdEpvaW5cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNdXRlTGlzdFwiXSA9IDFlNF0gPSBcIk11dGVMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUGluTGlzdFwiXSA9IDEwMDAxXSA9IFwiUGluTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlbGF5TGlzdFwiXSA9IDEwMDAyXSA9IFwiUmVsYXlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQm9va21hcmtMaXN0XCJdID0gMTAwMDNdID0gXCJCb29rbWFya0xpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDb21tdW5pdHlMaXN0XCJdID0gMTAwMDRdID0gXCJDb21tdW5pdHlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUHVibGljQ2hhdExpc3RcIl0gPSAxMDAwNV0gPSBcIlB1YmxpY0NoYXRMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmxvY2tSZWxheUxpc3RcIl0gPSAxMDAwNl0gPSBcIkJsb2NrUmVsYXlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU2VhcmNoUmVsYXlMaXN0XCJdID0gMTAwMDddID0gXCJTZWFyY2hSZWxheUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJTaW1wbGVHcm91cExpc3RcIl0gPSAxMDAwOV0gPSBcIlNpbXBsZUdyb3VwTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkludGVyZXN0TGlzdFwiXSA9IDEwMDE1XSA9IFwiSW50ZXJlc3RMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVNaW50TGlzdFwiXSA9IDEwMDE5XSA9IFwiQ2FzaHVNaW50TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkVtb2ppTGlzdFwiXSA9IDEwMDMwXSA9IFwiRW1vamlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRGlyZWN0TWVzc2FnZVJlY2VpdmVSZWxheUxpc3RcIl0gPSAxMDA1MF0gPSBcIkRpcmVjdE1lc3NhZ2VSZWNlaXZlUmVsYXlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmxvc3NvbUxpc3RcIl0gPSAxMDA2M10gPSBcIkJsb3Nzb21MaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTm9zdHJXYWxldENvbm5lY3RJbmZvXCJdID0gMTMxOTRdID0gXCJOb3N0cldhbGV0Q29ubmVjdEluZm9cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJUaWVyTGlzdFwiXSA9IDE3ZTNdID0gXCJUaWVyTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhc2h1V2FsbGV0XCJdID0gMTczNzVdID0gXCJDYXNodVdhbGxldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkZvbGxvd1NldFwiXSA9IDNlNF0gPSBcIkZvbGxvd1NldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhdGVnb3JpemVkUGVvcGxlTGlzdFwiXSA9IDNlNCAvKiBGb2xsb3dTZXQgKi9dID0gXCJDYXRlZ29yaXplZFBlb3BsZUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXRlZ29yaXplZEJvb2ttYXJrTGlzdFwiXSA9IDMwMDAxXSA9IFwiQ2F0ZWdvcml6ZWRCb29rbWFya0xpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJSZWxheVNldFwiXSA9IDMwMDAyXSA9IFwiUmVsYXlTZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXRlZ29yaXplZFJlbGF5TGlzdFwiXSA9IDMwMDAyIC8qIFJlbGF5U2V0ICovXSA9IFwiQ2F0ZWdvcml6ZWRSZWxheUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCb29rbWFya1NldFwiXSA9IDMwMDAzXSA9IFwiQm9va21hcmtTZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDdXJhdGlvblNldFwiXSA9IDMwMDA0XSA9IFwiQ3VyYXRpb25TZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJBcnRpY2xlQ3VyYXRpb25TZXRcIl0gPSAzMDAwNF0gPSBcIkFydGljbGVDdXJhdGlvblNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlZpZGVvQ3VyYXRpb25TZXRcIl0gPSAzMDAwNV0gPSBcIlZpZGVvQ3VyYXRpb25TZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJJbWFnZUN1cmF0aW9uU2V0XCJdID0gMzAwMDZdID0gXCJJbWFnZUN1cmF0aW9uU2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSW50ZXJlc3RTZXRcIl0gPSAzMDAxNV0gPSBcIkludGVyZXN0U2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSW50ZXJlc3RzTGlzdFwiXSA9IDMwMDE1IC8qIEludGVyZXN0U2V0ICovXSA9IFwiSW50ZXJlc3RzTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkVtb2ppU2V0XCJdID0gMzAwMzBdID0gXCJFbW9qaVNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk1vZHVsYXJBcnRpY2xlXCJdID0gMzAwNDBdID0gXCJNb2R1bGFyQXJ0aWNsZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk1vZHVsYXJBcnRpY2xlSXRlbVwiXSA9IDMwMDQxXSA9IFwiTW9kdWxhckFydGljbGVJdGVtXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiV2lraVwiXSA9IDMwODE4XSA9IFwiV2lraVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRyYWZ0XCJdID0gMzEyMzRdID0gXCJEcmFmdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlN1YnNjcmlwdGlvblRpZXJcIl0gPSAzNzAwMV0gPSBcIlN1YnNjcmlwdGlvblRpZXJcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJFY2FzaE1pbnRSZWNvbW1lbmRhdGlvblwiXSA9IDM4ZTNdID0gXCJFY2FzaE1pbnRSZWNvbW1lbmRhdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkhpZ2hsaWdodFNldFwiXSA9IDM5ODAyXSA9IFwiSGlnaGxpZ2h0U2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2F0ZWdvcml6ZWRIaWdobGlnaHRMaXN0XCJdID0gMzk4MDIgLyogSGlnaGxpZ2h0U2V0ICovXSA9IFwiQ2F0ZWdvcml6ZWRIaWdobGlnaHRMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTnV0emFwXCJdID0gOTMyMV0gPSBcIk51dHphcFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlphcFJlcXVlc3RcIl0gPSA5NzM0XSA9IFwiWmFwUmVxdWVzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlphcFwiXSA9IDk3MzVdID0gXCJaYXBcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJIaWdobGlnaHRcIl0gPSA5ODAyXSA9IFwiSGlnaGxpZ2h0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2xpZW50QXV0aFwiXSA9IDIyMjQyXSA9IFwiQ2xpZW50QXV0aFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk5vc3RyV2FsbGV0Q29ubmVjdFJlcVwiXSA9IDIzMTk0XSA9IFwiTm9zdHJXYWxsZXRDb25uZWN0UmVxXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTm9zdHJXYWxsZXRDb25uZWN0UmVzXCJdID0gMjMxOTVdID0gXCJOb3N0cldhbGxldENvbm5lY3RSZXNcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJOb3N0ckNvbm5lY3RcIl0gPSAyNDEzM10gPSBcIk5vc3RyQ29ubmVjdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkJsb3Nzb21VcGxvYWRcIl0gPSAyNDI0Ml0gPSBcIkJsb3Nzb21VcGxvYWRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJIdHRwQXV0aFwiXSA9IDI3MjM1XSA9IFwiSHR0cEF1dGhcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJQcm9maWxlQmFkZ2VcIl0gPSAzMDAwOF0gPSBcIlByb2ZpbGVCYWRnZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkJhZGdlRGVmaW5pdGlvblwiXSA9IDMwMDA5XSA9IFwiQmFkZ2VEZWZpbml0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTWFya2V0U3RhbGxcIl0gPSAzMDAxN10gPSBcIk1hcmtldFN0YWxsXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTWFya2V0UHJvZHVjdFwiXSA9IDMwMDE4XSA9IFwiTWFya2V0UHJvZHVjdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkFydGljbGVcIl0gPSAzMDAyM10gPSBcIkFydGljbGVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJBcHBTcGVjaWZpY0RhdGFcIl0gPSAzMDA3OF0gPSBcIkFwcFNwZWNpZmljRGF0YVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNsYXNzaWZpZWRcIl0gPSAzMDQwMl0gPSBcIkNsYXNzaWZpZWRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJIb3Jpem9udGFsVmlkZW9cIl0gPSAzNDIzNV0gPSBcIkhvcml6b250YWxWaWRlb1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlZlcnRpY2FsVmlkZW9cIl0gPSAzNDIzNl0gPSBcIlZlcnRpY2FsVmlkZW9cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJMZWdhY3lDYXNodVdhbGxldFwiXSA9IDM3Mzc1XSA9IFwiTGVnYWN5Q2FzaHVXYWxsZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cE1ldGFkYXRhXCJdID0gMzllM10gPSBcIkdyb3VwTWV0YWRhdGFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluc1wiXSA9IDM5MDAxXSA9IFwiR3JvdXBBZG1pbnNcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cE1lbWJlcnNcIl0gPSAzOTAwMl0gPSBcIkdyb3VwTWVtYmVyc1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkFwcFJlY29tbWVuZGF0aW9uXCJdID0gMzE5ODldID0gXCJBcHBSZWNvbW1lbmRhdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkFwcEhhbmRsZXJcIl0gPSAzMTk5MF0gPSBcIkFwcEhhbmRsZXJcIjtcbiAgcmV0dXJuIE5ES0tpbmQyO1xufSkoTkRLS2luZCB8fCB7fSk7XG52YXIgTkRLTGlzdEtpbmRzID0gW1xuICAxZTQgLyogTXV0ZUxpc3QgKi8sXG4gIDEwMDAxIC8qIFBpbkxpc3QgKi8sXG4gIDEwMDAyIC8qIFJlbGF5TGlzdCAqLyxcbiAgMTAwMDMgLyogQm9va21hcmtMaXN0ICovLFxuICAxMDAwNCAvKiBDb21tdW5pdHlMaXN0ICovLFxuICAxMDAwNSAvKiBQdWJsaWNDaGF0TGlzdCAqLyxcbiAgMTAwMDYgLyogQmxvY2tSZWxheUxpc3QgKi8sXG4gIDEwMDA3IC8qIFNlYXJjaFJlbGF5TGlzdCAqLyxcbiAgMTAwMTUgLyogSW50ZXJlc3RMaXN0ICovLFxuICAxMDAzMCAvKiBFbW9qaUxpc3QgKi8sXG4gIDEwMDUwIC8qIERpcmVjdE1lc3NhZ2VSZWNlaXZlUmVsYXlMaXN0ICovLFxuICAzZTQgLyogRm9sbG93U2V0ICovLFxuICAzMDAwMyAvKiBCb29rbWFya1NldCAqLyxcbiAgMzAwMDEgLyogQ2F0ZWdvcml6ZWRCb29rbWFya0xpc3QgKi8sXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIDMwMDAyIC8qIFJlbGF5U2V0ICovLFxuICAzMDAwNCAvKiBBcnRpY2xlQ3VyYXRpb25TZXQgKi8sXG4gIDMwMDA1IC8qIFZpZGVvQ3VyYXRpb25TZXQgKi8sXG4gIDMwMDE1IC8qIEludGVyZXN0U2V0ICovLFxuICAzMDAzMCAvKiBFbW9qaVNldCAqLyxcbiAgMzk4MDIgLyogSGlnaGxpZ2h0U2V0ICovXG5dO1xuXG4vLyBzcmMvZXZlbnRzL2luZGV4LnRzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyMiB9IGZyb20gXCJ0c2VlcFwiO1xuXG4vLyBzcmMvcmVsYXkvc2V0cy9jYWxjdWxhdGUudHNcbmltcG9ydCBjcmVhdGVEZWJ1ZyBmcm9tIFwiZGVidWdcIjtcblxuLy8gc3JjL291dGJveC93cml0ZS50c1xuZnVuY3Rpb24gZ2V0UmVsYXlzRm9yU3luYyhuZGssIGF1dGhvciwgdHlwZSA9IFwid3JpdGVcIikge1xuICBpZiAoIW5kay5vdXRib3hUcmFja2VyKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBpdGVtID0gbmRrLm91dGJveFRyYWNrZXIuZGF0YS5nZXQoYXV0aG9yKTtcbiAgaWYgKCFpdGVtKSByZXR1cm4gdm9pZCAwO1xuICBpZiAodHlwZSA9PT0gXCJ3cml0ZVwiKSB7XG4gICAgcmV0dXJuIGl0ZW0ud3JpdGVSZWxheXM7XG4gIH1cbiAgcmV0dXJuIGl0ZW0ucmVhZFJlbGF5cztcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFdyaXRlUmVsYXlzRm9yKG5kaywgYXV0aG9yLCB0eXBlID0gXCJ3cml0ZVwiKSB7XG4gIGlmICghbmRrLm91dGJveFRyYWNrZXIpIHJldHVybiB2b2lkIDA7XG4gIGlmICghbmRrLm91dGJveFRyYWNrZXIuZGF0YS5oYXMoYXV0aG9yKSkge1xuICAgIGF3YWl0IG5kay5vdXRib3hUcmFja2VyLnRyYWNrVXNlcnMoW2F1dGhvcl0pO1xuICB9XG4gIHJldHVybiBnZXRSZWxheXNGb3JTeW5jKG5kaywgYXV0aG9yLCB0eXBlKTtcbn1cblxuLy8gc3JjL291dGJveC9yZWxheS1yYW5raW5nLnRzXG5mdW5jdGlvbiBnZXRUb3BSZWxheXNGb3JBdXRob3JzKG5kaywgYXV0aG9ycykge1xuICBjb25zdCByZWxheXNXaXRoQ291bnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBhdXRob3JzLmZvckVhY2goKGF1dGhvcikgPT4ge1xuICAgIGNvbnN0IHdyaXRlUmVsYXlzID0gZ2V0UmVsYXlzRm9yU3luYyhuZGssIGF1dGhvcik7XG4gICAgaWYgKHdyaXRlUmVsYXlzKSB7XG4gICAgICB3cml0ZVJlbGF5cy5mb3JFYWNoKChyZWxheSkgPT4ge1xuICAgICAgICBjb25zdCBjb3VudCA9IHJlbGF5c1dpdGhDb3VudC5nZXQocmVsYXkpIHx8IDA7XG4gICAgICAgIHJlbGF5c1dpdGhDb3VudC5zZXQocmVsYXksIGNvdW50ICsgMSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzb3J0ZWRSZWxheXMgPSBBcnJheS5mcm9tKHJlbGF5c1dpdGhDb3VudC5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKTtcbiAgcmV0dXJuIHNvcnRlZFJlbGF5cy5tYXAoKGVudHJ5KSA9PiBlbnRyeVswXSk7XG59XG5cbi8vIHNyYy9vdXRib3gvaW5kZXgudHNcbmZ1bmN0aW9uIGdldEFsbFJlbGF5c0ZvckFsbFB1YmtleXMobmRrLCBwdWJrZXlzLCB0eXBlID0gXCJyZWFkXCIpIHtcbiAgY29uc3QgcHVia2V5c1RvUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgYXV0aG9yc01pc3NpbmdSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBwdWJrZXlzLmZvckVhY2goKHB1YmtleSkgPT4ge1xuICAgIGNvbnN0IHJlbGF5cyA9IGdldFJlbGF5c0ZvclN5bmMobmRrLCBwdWJrZXksIHR5cGUpO1xuICAgIGlmIChyZWxheXMgJiYgcmVsYXlzLnNpemUgPiAwKSB7XG4gICAgICByZWxheXMuZm9yRWFjaCgocmVsYXkpID0+IHtcbiAgICAgICAgY29uc3QgcHVia2V5c0luUmVsYXkgPSBwdWJrZXlzVG9SZWxheXMuZ2V0KHJlbGF5KSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICBwdWJrZXlzSW5SZWxheS5hZGQocHVia2V5KTtcbiAgICAgIH0pO1xuICAgICAgcHVia2V5c1RvUmVsYXlzLnNldChwdWJrZXksIHJlbGF5cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF1dGhvcnNNaXNzaW5nUmVsYXlzLmFkZChwdWJrZXkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7IHB1YmtleXNUb1JlbGF5cywgYXV0aG9yc01pc3NpbmdSZWxheXMgfTtcbn1cbmZ1bmN0aW9uIGNob29zZVJlbGF5Q29tYmluYXRpb25Gb3JQdWJrZXlzKG5kaywgcHVia2V5cywgdHlwZSwgeyBjb3VudCwgcHJlZmVycmVkUmVsYXlzIH0gPSB7fSkge1xuICBjb3VudCA/Pz0gMjtcbiAgcHJlZmVycmVkUmVsYXlzID8/PSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBwb29sID0gbmRrLnBvb2w7XG4gIGNvbnN0IGNvbm5lY3RlZFJlbGF5cyA9IHBvb2wuY29ubmVjdGVkUmVsYXlzKCk7XG4gIGNvbm5lY3RlZFJlbGF5cy5mb3JFYWNoKChyZWxheSkgPT4ge1xuICAgIHByZWZlcnJlZFJlbGF5cz8uYWRkKHJlbGF5LnVybCk7XG4gIH0pO1xuICBjb25zdCByZWxheVRvQXV0aG9yc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHsgcHVia2V5c1RvUmVsYXlzLCBhdXRob3JzTWlzc2luZ1JlbGF5cyB9ID0gZ2V0QWxsUmVsYXlzRm9yQWxsUHVia2V5cyhuZGssIHB1YmtleXMsIHR5cGUpO1xuICBjb25zdCBzb3J0ZWRSZWxheXMgPSBnZXRUb3BSZWxheXNGb3JBdXRob3JzKG5kaywgcHVia2V5cyk7XG4gIGNvbnN0IGFkZEF1dGhvclRvUmVsYXkgPSAoYXV0aG9yLCByZWxheSkgPT4ge1xuICAgIGNvbnN0IGF1dGhvcnNJblJlbGF5ID0gcmVsYXlUb0F1dGhvcnNNYXAuZ2V0KHJlbGF5KSB8fCBbXTtcbiAgICBhdXRob3JzSW5SZWxheS5wdXNoKGF1dGhvcik7XG4gICAgcmVsYXlUb0F1dGhvcnNNYXAuc2V0KHJlbGF5LCBhdXRob3JzSW5SZWxheSk7XG4gIH07XG4gIGZvciAoY29uc3QgW2F1dGhvciwgYXV0aG9yUmVsYXlzXSBvZiBwdWJrZXlzVG9SZWxheXMuZW50cmllcygpKSB7XG4gICAgbGV0IG1pc3NpbmdSZWxheUNvdW50ID0gY291bnQ7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiBjb25uZWN0ZWRSZWxheXMpIHtcbiAgICAgIGlmIChhdXRob3JSZWxheXMuaGFzKHJlbGF5LnVybCkpIHtcbiAgICAgICAgYWRkQXV0aG9yVG9SZWxheShhdXRob3IsIHJlbGF5LnVybCk7XG4gICAgICAgIG1pc3NpbmdSZWxheUNvdW50LS07XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXV0aG9yUmVsYXkgb2YgYXV0aG9yUmVsYXlzKSB7XG4gICAgICBpZiAocmVsYXlUb0F1dGhvcnNNYXAuaGFzKGF1dGhvclJlbGF5KSkge1xuICAgICAgICBhZGRBdXRob3JUb1JlbGF5KGF1dGhvciwgYXV0aG9yUmVsYXkpO1xuICAgICAgICBtaXNzaW5nUmVsYXlDb3VudC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWlzc2luZ1JlbGF5Q291bnQgPD0gMCkgY29udGludWU7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiBzb3J0ZWRSZWxheXMpIHtcbiAgICAgIGlmIChtaXNzaW5nUmVsYXlDb3VudCA8PSAwKSBicmVhaztcbiAgICAgIGlmIChhdXRob3JSZWxheXMuaGFzKHJlbGF5KSkge1xuICAgICAgICBhZGRBdXRob3JUb1JlbGF5KGF1dGhvciwgcmVsYXkpO1xuICAgICAgICBtaXNzaW5nUmVsYXlDb3VudC0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGF1dGhvciBvZiBhdXRob3JzTWlzc2luZ1JlbGF5cykge1xuICAgIHBvb2wucGVybWFuZW50QW5kQ29ubmVjdGVkUmVsYXlzKCkuZm9yRWFjaCgocmVsYXkpID0+IHtcbiAgICAgIGNvbnN0IGF1dGhvcnNJblJlbGF5ID0gcmVsYXlUb0F1dGhvcnNNYXAuZ2V0KHJlbGF5LnVybCkgfHwgW107XG4gICAgICBhdXRob3JzSW5SZWxheS5wdXNoKGF1dGhvcik7XG4gICAgICByZWxheVRvQXV0aG9yc01hcC5zZXQocmVsYXkudXJsLCBhdXRob3JzSW5SZWxheSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlbGF5VG9BdXRob3JzTWFwO1xufVxuXG4vLyBzcmMvb3V0Ym94L3JlYWQvd2l0aC1hdXRob3JzLnRzXG5mdW5jdGlvbiBnZXRSZWxheXNGb3JGaWx0ZXJXaXRoQXV0aG9ycyhuZGssIGF1dGhvcnMsIHJlbGF5R29hbFBlckF1dGhvciA9IDIpIHtcbiAgcmV0dXJuIGNob29zZVJlbGF5Q29tYmluYXRpb25Gb3JQdWJrZXlzKG5kaywgYXV0aG9ycywgXCJ3cml0ZVwiLCB7IGNvdW50OiByZWxheUdvYWxQZXJBdXRob3IgfSk7XG59XG5cbi8vIHNyYy91dGlscy9ub3JtYWxpemUtdXJsLnRzXG5mdW5jdGlvbiB0cnlOb3JtYWxpemVSZWxheVVybCh1cmwpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbm9ybWFsaXplUmVsYXlVcmwodXJsKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVsYXlVcmwodXJsKSB7XG4gIGxldCByID0gbm9ybWFsaXplVXJsKHVybCwge1xuICAgIHN0cmlwQXV0aGVudGljYXRpb246IGZhbHNlLFxuICAgIHN0cmlwV1dXOiBmYWxzZSxcbiAgICBzdHJpcEhhc2g6IHRydWVcbiAgfSk7XG4gIGlmICghci5lbmRzV2l0aChcIi9cIikpIHtcbiAgICByICs9IFwiL1wiO1xuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKHVybHMpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgdXJsIG9mIHVybHMpIHtcbiAgICB0cnkge1xuICAgICAgbm9ybWFsaXplZC5hZGQobm9ybWFsaXplUmVsYXlVcmwodXJsKSk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKG5vcm1hbGl6ZWQpO1xufVxudmFyIERBVEFfVVJMX0RFRkFVTFRfTUlNRV9UWVBFID0gXCJ0ZXh0L3BsYWluXCI7XG52YXIgREFUQV9VUkxfREVGQVVMVF9DSEFSU0VUID0gXCJ1cy1hc2NpaVwiO1xudmFyIHRlc3RQYXJhbWV0ZXIgPSAobmFtZSwgZmlsdGVycykgPT4gZmlsdGVycy5zb21lKChmaWx0ZXIpID0+IGZpbHRlciBpbnN0YW5jZW9mIFJlZ0V4cCA/IGZpbHRlci50ZXN0KG5hbWUpIDogZmlsdGVyID09PSBuYW1lKTtcbnZhciBzdXBwb3J0ZWRQcm90b2NvbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJodHRwczpcIiwgXCJodHRwOlwiLCBcImZpbGU6XCJdKTtcbnZhciBoYXNDdXN0b21Qcm90b2NvbCA9ICh1cmxTdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IHByb3RvY29sIH0gPSBuZXcgVVJMKHVybFN0cmluZyk7XG4gICAgcmV0dXJuIHByb3RvY29sLmVuZHNXaXRoKFwiOlwiKSAmJiAhcHJvdG9jb2wuaW5jbHVkZXMoXCIuXCIpICYmICFzdXBwb3J0ZWRQcm90b2NvbHMuaGFzKHByb3RvY29sKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIG5vcm1hbGl6ZURhdGFVUkwgPSAodXJsU3RyaW5nLCB7IHN0cmlwSGFzaCB9KSA9PiB7XG4gIGNvbnN0IG1hdGNoID0gL15kYXRhOig/PHR5cGU+W14sXSo/KSwoPzxkYXRhPlteI10qPykoPzojKD88aGFzaD4uKikpPyQvLmV4ZWModXJsU3RyaW5nKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVUkw6ICR7dXJsU3RyaW5nfWApO1xuICB9XG4gIGNvbnN0IHR5cGUgPSBtYXRjaC5ncm91cHM/LnR5cGUgPz8gXCJcIjtcbiAgY29uc3QgZGF0YSA9IG1hdGNoLmdyb3Vwcz8uZGF0YSA/PyBcIlwiO1xuICBsZXQgaGFzaCA9IG1hdGNoLmdyb3Vwcz8uaGFzaCA/PyBcIlwiO1xuICBjb25zdCBtZWRpYVR5cGUgPSB0eXBlLnNwbGl0KFwiO1wiKTtcbiAgaGFzaCA9IHN0cmlwSGFzaCA/IFwiXCIgOiBoYXNoO1xuICBsZXQgaXNCYXNlNjQgPSBmYWxzZTtcbiAgaWYgKG1lZGlhVHlwZVttZWRpYVR5cGUubGVuZ3RoIC0gMV0gPT09IFwiYmFzZTY0XCIpIHtcbiAgICBtZWRpYVR5cGUucG9wKCk7XG4gICAgaXNCYXNlNjQgPSB0cnVlO1xuICB9XG4gIGNvbnN0IG1pbWVUeXBlID0gbWVkaWFUeXBlLnNoaWZ0KCk/LnRvTG93ZXJDYXNlKCkgPz8gXCJcIjtcbiAgY29uc3QgYXR0cmlidXRlcyA9IG1lZGlhVHlwZS5tYXAoKGF0dHJpYnV0ZSkgPT4ge1xuICAgIGxldCBba2V5LCB2YWx1ZSA9IFwiXCJdID0gYXR0cmlidXRlLnNwbGl0KFwiPVwiKS5tYXAoKHN0cmluZykgPT4gc3RyaW5nLnRyaW0oKSk7XG4gICAgaWYgKGtleSA9PT0gXCJjaGFyc2V0XCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gREFUQV9VUkxfREVGQVVMVF9DSEFSU0VUKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYCR7a2V5fSR7dmFsdWUgPyBgPSR7dmFsdWV9YCA6IFwiXCJ9YDtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBub3JtYWxpemVkTWVkaWFUeXBlID0gWy4uLmF0dHJpYnV0ZXNdO1xuICBpZiAoaXNCYXNlNjQpIHtcbiAgICBub3JtYWxpemVkTWVkaWFUeXBlLnB1c2goXCJiYXNlNjRcIik7XG4gIH1cbiAgaWYgKG5vcm1hbGl6ZWRNZWRpYVR5cGUubGVuZ3RoID4gMCB8fCBtaW1lVHlwZSAmJiBtaW1lVHlwZSAhPT0gREFUQV9VUkxfREVGQVVMVF9NSU1FX1RZUEUpIHtcbiAgICBub3JtYWxpemVkTWVkaWFUeXBlLnVuc2hpZnQobWltZVR5cGUpO1xuICB9XG4gIHJldHVybiBgZGF0YToke25vcm1hbGl6ZWRNZWRpYVR5cGUuam9pbihcIjtcIil9LCR7aXNCYXNlNjQgPyBkYXRhLnRyaW0oKSA6IGRhdGF9JHtoYXNoID8gYCMke2hhc2h9YCA6IFwiXCJ9YDtcbn07XG5mdW5jdGlvbiBub3JtYWxpemVVcmwodXJsU3RyaW5nLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucyA9IHtcbiAgICBkZWZhdWx0UHJvdG9jb2w6IFwiaHR0cFwiLFxuICAgIG5vcm1hbGl6ZVByb3RvY29sOiB0cnVlLFxuICAgIGZvcmNlSHR0cDogZmFsc2UsXG4gICAgZm9yY2VIdHRwczogZmFsc2UsXG4gICAgc3RyaXBBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICBzdHJpcEhhc2g6IGZhbHNlLFxuICAgIHN0cmlwVGV4dEZyYWdtZW50OiB0cnVlLFxuICAgIHN0cmlwV1dXOiB0cnVlLFxuICAgIHJlbW92ZVF1ZXJ5UGFyYW1ldGVyczogWy9edXRtX1xcdysvaV0sXG4gICAgcmVtb3ZlVHJhaWxpbmdTbGFzaDogdHJ1ZSxcbiAgICByZW1vdmVTaW5nbGVTbGFzaDogdHJ1ZSxcbiAgICByZW1vdmVEaXJlY3RvcnlJbmRleDogZmFsc2UsXG4gICAgcmVtb3ZlRXhwbGljaXRQb3J0OiBmYWxzZSxcbiAgICBzb3J0UXVlcnlQYXJhbWV0ZXJzOiB0cnVlLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmRlZmF1bHRQcm90b2NvbCA9PT0gXCJzdHJpbmdcIiAmJiAhb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wuZW5kc1dpdGgoXCI6XCIpKSB7XG4gICAgb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wgPSBgJHtvcHRpb25zLmRlZmF1bHRQcm90b2NvbH06YDtcbiAgfVxuICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcudHJpbSgpO1xuICBpZiAoL15kYXRhOi9pLnRlc3QodXJsU3RyaW5nKSkge1xuICAgIHJldHVybiBub3JtYWxpemVEYXRhVVJMKHVybFN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGhhc0N1c3RvbVByb3RvY29sKHVybFN0cmluZykpIHtcbiAgICByZXR1cm4gdXJsU3RyaW5nO1xuICB9XG4gIGNvbnN0IGhhc1JlbGF0aXZlUHJvdG9jb2wgPSB1cmxTdHJpbmcuc3RhcnRzV2l0aChcIi8vXCIpO1xuICBjb25zdCBpc1JlbGF0aXZlVXJsID0gIWhhc1JlbGF0aXZlUHJvdG9jb2wgJiYgL15cXC4qXFwvLy50ZXN0KHVybFN0cmluZyk7XG4gIGlmICghaXNSZWxhdGl2ZVVybCkge1xuICAgIHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9eKD8hKD86XFx3KzopP1xcL1xcLyl8XlxcL1xcLy8sIG9wdGlvbnMuZGVmYXVsdFByb3RvY29sKTtcbiAgfVxuICBjb25zdCB1cmxPYmplY3QgPSBuZXcgVVJMKHVybFN0cmluZyk7XG4gIHVybE9iamVjdC5ob3N0bmFtZSA9IHVybE9iamVjdC5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAob3B0aW9ucy5mb3JjZUh0dHAgJiYgb3B0aW9ucy5mb3JjZUh0dHBzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGBmb3JjZUh0dHBgIGFuZCBgZm9yY2VIdHRwc2Agb3B0aW9ucyBjYW5ub3QgYmUgdXNlZCB0b2dldGhlclwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5mb3JjZUh0dHAgJiYgdXJsT2JqZWN0LnByb3RvY29sID09PSBcImh0dHBzOlwiKSB7XG4gICAgdXJsT2JqZWN0LnByb3RvY29sID0gXCJodHRwOlwiO1xuICB9XG4gIGlmIChvcHRpb25zLmZvcmNlSHR0cHMgJiYgdXJsT2JqZWN0LnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICB1cmxPYmplY3QucHJvdG9jb2wgPSBcImh0dHBzOlwiO1xuICB9XG4gIGlmIChvcHRpb25zLnN0cmlwQXV0aGVudGljYXRpb24pIHtcbiAgICB1cmxPYmplY3QudXNlcm5hbWUgPSBcIlwiO1xuICAgIHVybE9iamVjdC5wYXNzd29yZCA9IFwiXCI7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RyaXBIYXNoKSB7XG4gICAgdXJsT2JqZWN0Lmhhc2ggPSBcIlwiO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuc3RyaXBUZXh0RnJhZ21lbnQpIHtcbiAgICB1cmxPYmplY3QuaGFzaCA9IHVybE9iamVjdC5oYXNoLnJlcGxhY2UoLyM/On46dGV4dC4qPyQvaSwgXCJcIik7XG4gIH1cbiAgaWYgKHVybE9iamVjdC5wYXRobmFtZSkge1xuICAgIGNvbnN0IHByb3RvY29sUmVnZXggPSAvXFxiW2Etel1bYS16XFxkK1xcLS5dezEsNTB9OlxcL1xcLy9nO1xuICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAoOyA7ICkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBwcm90b2NvbFJlZ2V4LmV4ZWModXJsT2JqZWN0LnBhdGhuYW1lKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm90b2NvbCA9IG1hdGNoWzBdO1xuICAgICAgY29uc3QgcHJvdG9jb2xBdEluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICBjb25zdCBpbnRlcm1lZGlhdGUgPSB1cmxPYmplY3QucGF0aG5hbWUuc2xpY2UobGFzdEluZGV4LCBwcm90b2NvbEF0SW5kZXgpO1xuICAgICAgcmVzdWx0ICs9IGludGVybWVkaWF0ZS5yZXBsYWNlKC9cXC97Mix9L2csIFwiL1wiKTtcbiAgICAgIHJlc3VsdCArPSBwcm90b2NvbDtcbiAgICAgIGxhc3RJbmRleCA9IHByb3RvY29sQXRJbmRleCArIHByb3RvY29sLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVtbmFudCA9IHVybE9iamVjdC5wYXRobmFtZS5zbGljZShsYXN0SW5kZXgsIHVybE9iamVjdC5wYXRobmFtZS5sZW5ndGgpO1xuICAgIHJlc3VsdCArPSByZW1uYW50LnJlcGxhY2UoL1xcL3syLH0vZywgXCIvXCIpO1xuICAgIHVybE9iamVjdC5wYXRobmFtZSA9IHJlc3VsdDtcbiAgfVxuICBpZiAodXJsT2JqZWN0LnBhdGhuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHVybE9iamVjdC5wYXRobmFtZSA9IGRlY29kZVVSSSh1cmxPYmplY3QucGF0aG5hbWUpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleCA9PT0gdHJ1ZSkge1xuICAgIG9wdGlvbnMucmVtb3ZlRGlyZWN0b3J5SW5kZXggPSBbL15pbmRleFxcLlthLXpdKyQvXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4KSAmJiBvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4Lmxlbmd0aCA+IDApIHtcbiAgICBsZXQgcGF0aENvbXBvbmVudHMgPSB1cmxPYmplY3QucGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICAgIGNvbnN0IGxhc3RDb21wb25lbnQgPSBwYXRoQ29tcG9uZW50c1twYXRoQ29tcG9uZW50cy5sZW5ndGggLSAxXTtcbiAgICBpZiAodGVzdFBhcmFtZXRlcihsYXN0Q29tcG9uZW50LCBvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4KSkge1xuICAgICAgcGF0aENvbXBvbmVudHMgPSBwYXRoQ29tcG9uZW50cy5zbGljZSgwLCAtMSk7XG4gICAgICB1cmxPYmplY3QucGF0aG5hbWUgPSBgJHtwYXRoQ29tcG9uZW50cy5zbGljZSgxKS5qb2luKFwiL1wiKX0vYDtcbiAgICB9XG4gIH1cbiAgaWYgKHVybE9iamVjdC5ob3N0bmFtZSkge1xuICAgIHVybE9iamVjdC5ob3N0bmFtZSA9IHVybE9iamVjdC5ob3N0bmFtZS5yZXBsYWNlKC9cXC4kLywgXCJcIik7XG4gICAgaWYgKG9wdGlvbnMuc3RyaXBXV1cgJiYgL153d3dcXC4oPyF3d3dcXC4pW2EtelxcLVxcZF17MSw2M31cXC5bYS16LlxcLVxcZF17Miw2M30kLy50ZXN0KHVybE9iamVjdC5ob3N0bmFtZSkpIHtcbiAgICAgIHVybE9iamVjdC5ob3N0bmFtZSA9IHVybE9iamVjdC5ob3N0bmFtZS5yZXBsYWNlKC9ed3d3XFwuLywgXCJcIik7XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucmVtb3ZlUXVlcnlQYXJhbWV0ZXJzKSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFsuLi51cmxPYmplY3Quc2VhcmNoUGFyYW1zLmtleXMoKV0pIHtcbiAgICAgIGlmICh0ZXN0UGFyYW1ldGVyKGtleSwgb3B0aW9ucy5yZW1vdmVRdWVyeVBhcmFtZXRlcnMpKSB7XG4gICAgICAgIHVybE9iamVjdC5zZWFyY2hQYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmtlZXBRdWVyeVBhcmFtZXRlcnMpICYmIG9wdGlvbnMucmVtb3ZlUXVlcnlQYXJhbWV0ZXJzID09PSB0cnVlKSB7XG4gICAgdXJsT2JqZWN0LnNlYXJjaCA9IFwiXCI7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5rZWVwUXVlcnlQYXJhbWV0ZXJzKSAmJiBvcHRpb25zLmtlZXBRdWVyeVBhcmFtZXRlcnMubGVuZ3RoID4gMCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFsuLi51cmxPYmplY3Quc2VhcmNoUGFyYW1zLmtleXMoKV0pIHtcbiAgICAgIGlmICghdGVzdFBhcmFtZXRlcihrZXksIG9wdGlvbnMua2VlcFF1ZXJ5UGFyYW1ldGVycykpIHtcbiAgICAgICAgdXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuc29ydFF1ZXJ5UGFyYW1ldGVycykge1xuICAgIHVybE9iamVjdC5zZWFyY2hQYXJhbXMuc29ydCgpO1xuICAgIHRyeSB7XG4gICAgICB1cmxPYmplY3Quc2VhcmNoID0gZGVjb2RlVVJJQ29tcG9uZW50KHVybE9iamVjdC5zZWFyY2gpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5yZW1vdmVUcmFpbGluZ1NsYXNoKSB7XG4gICAgdXJsT2JqZWN0LnBhdGhuYW1lID0gdXJsT2JqZWN0LnBhdGhuYW1lLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5yZW1vdmVFeHBsaWNpdFBvcnQgJiYgdXJsT2JqZWN0LnBvcnQpIHtcbiAgICB1cmxPYmplY3QucG9ydCA9IFwiXCI7XG4gIH1cbiAgY29uc3Qgb2xkVXJsU3RyaW5nID0gdXJsU3RyaW5nO1xuICB1cmxTdHJpbmcgPSB1cmxPYmplY3QudG9TdHJpbmcoKTtcbiAgaWYgKCFvcHRpb25zLnJlbW92ZVNpbmdsZVNsYXNoICYmIHVybE9iamVjdC5wYXRobmFtZSA9PT0gXCIvXCIgJiYgIW9sZFVybFN0cmluZy5lbmRzV2l0aChcIi9cIikgJiYgdXJsT2JqZWN0Lmhhc2ggPT09IFwiXCIpIHtcbiAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICB9XG4gIGlmICgob3B0aW9ucy5yZW1vdmVUcmFpbGluZ1NsYXNoIHx8IHVybE9iamVjdC5wYXRobmFtZSA9PT0gXCIvXCIpICYmIHVybE9iamVjdC5oYXNoID09PSBcIlwiICYmIG9wdGlvbnMucmVtb3ZlU2luZ2xlU2xhc2gpIHtcbiAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICB9XG4gIGlmIChoYXNSZWxhdGl2ZVByb3RvY29sICYmICFvcHRpb25zLm5vcm1hbGl6ZVByb3RvY29sKSB7XG4gICAgdXJsU3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UoL15odHRwOlxcL1xcLy8sIFwiLy9cIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RyaXBQcm90b2NvbCkge1xuICAgIHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9eKD86aHR0cHM/Oik/XFwvXFwvLywgXCJcIik7XG4gIH1cbiAgcmV0dXJuIHVybFN0cmluZztcbn1cblxuLy8gc3JjL3JlbGF5L2luZGV4LnRzXG5pbXBvcnQgZGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL3JlbGF5L2Nvbm5lY3Rpdml0eS50c1xudmFyIE1BWF9SRUNPTk5FQ1RfQVRURU1QVFMgPSA1O1xudmFyIEZMQVBQSU5HX1RIUkVTSE9MRF9NUyA9IDFlMztcbnZhciBOREtSZWxheUNvbm5lY3Rpdml0eSA9IGNsYXNzIHtcbiAgbmRrUmVsYXk7XG4gIHdzO1xuICBfc3RhdHVzO1xuICB0aW1lb3V0TXM7XG4gIGNvbm5lY3RlZEF0O1xuICBfY29ubmVjdGlvblN0YXRzID0ge1xuICAgIGF0dGVtcHRzOiAwLFxuICAgIHN1Y2Nlc3M6IDAsXG4gICAgZHVyYXRpb25zOiBbXVxuICB9O1xuICBkZWJ1ZztcbiAgbmV0RGVidWc7XG4gIGNvbm5lY3RUaW1lb3V0O1xuICByZWNvbm5lY3RUaW1lb3V0O1xuICBuZGs7XG4gIG9wZW5TdWJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgb3BlbkNvdW50UmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBvcGVuRXZlbnRQdWJsaXNoZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzZXJpYWwgPSAwO1xuICBiYXNlRW9zZVRpbWVvdXQgPSA0NDAwO1xuICBjb25zdHJ1Y3RvcihuZGtSZWxheSwgbmRrKSB7XG4gICAgdGhpcy5uZGtSZWxheSA9IG5ka1JlbGF5O1xuICAgIHRoaXMuX3N0YXR1cyA9IDEgLyogRElTQ09OTkVDVEVEICovO1xuICAgIGNvbnN0IHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTMpO1xuICAgIHRoaXMuZGVidWcgPSB0aGlzLm5ka1JlbGF5LmRlYnVnLmV4dGVuZChgY29ubmVjdGl2aXR5JHtyYW5kfWApO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byB0aGUgTkRLIHJlbGF5IGFuZCBoYW5kbGVzIHRoZSBjb25uZWN0aW9uIGxpZmVjeWNsZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgYXR0ZW1wdHMgdG8gZXN0YWJsaXNoIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIE5ESyByZWxheSBzcGVjaWZpZWQgaW4gdGhlIGBuZGtSZWxheWAgb2JqZWN0LlxuICAgKiBJZiB0aGUgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsLCBpdCB1cGRhdGVzIHRoZSBjb25uZWN0aW9uIHN0YXRpc3RpY3MsIHNldHMgdGhlIGNvbm5lY3Rpb24gc3RhdHVzIHRvIGBDT05ORUNURURgLFxuICAgKiBhbmQgZW1pdHMgYGNvbm5lY3RgIGFuZCBgcmVhZHlgIGV2ZW50cyBvbiB0aGUgYG5ka1JlbGF5YCBvYmplY3QuXG4gICAqXG4gICAqIElmIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQgZmFpbHMsIGl0IGhhbmRsZXMgdGhlIGVycm9yIGJ5IGVpdGhlciBpbml0aWF0aW5nIGEgcmVjb25uZWN0aW9uIGF0dGVtcHQgb3IgZW1pdHRpbmcgYVxuICAgKiBgZGVsYXllZC1jb25uZWN0YCBldmVudCBvbiB0aGUgYG5ka1JlbGF5YCBvYmplY3QsIGRlcGVuZGluZyBvbiB0aGUgYHJlY29ubmVjdGAgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0gdGltZW91dE1zIC0gVGhlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgY29ubmVjdGlvbiBhdHRlbXB0LiBJZiBub3QgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IHRpbWVvdXQgZnJvbSB0aGUgYG5ka1JlbGF5YCBvYmplY3QgaXMgdXNlZC5cbiAgICogQHBhcmFtIHJlY29ubmVjdCAtIEluZGljYXRlcyB3aGV0aGVyIGEgcmVjb25uZWN0aW9uIHNob3VsZCBiZSBhdHRlbXB0ZWQgaWYgdGhlIGNvbm5lY3Rpb24gZmFpbHMuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgb3IgcmVqZWN0cyBpZiB0aGUgY29ubmVjdGlvbiBmYWlscy5cbiAgICovXG4gIGFzeW5jIGNvbm5lY3QodGltZW91dE1zLCByZWNvbm5lY3QgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuX3N0YXR1cyAhPT0gMiAvKiBSRUNPTk5FQ1RJTkcgKi8gJiYgdGhpcy5fc3RhdHVzICE9PSAxIC8qIERJU0NPTk5FQ1RFRCAqLyB8fCB0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgIFwiUmVsYXkgcmVxdWVzdGVkIHRvIGJlIGNvbm5lY3RlZCBidXQgd2FzIGluIHN0YXRlICVzIG9yIGl0IGhhZCBhIHJlY29ubmVjdCB0aW1lb3V0XCIsXG4gICAgICAgIHRoaXMuX3N0YXR1c1xuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dCk7XG4gICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0ID0gdm9pZCAwO1xuICAgIH1cbiAgICB0aW1lb3V0TXMgPz89IHRoaXMudGltZW91dE1zO1xuICAgIGlmICghdGhpcy50aW1lb3V0TXMgJiYgdGltZW91dE1zKSB0aGlzLnRpbWVvdXRNcyA9IHRpbWVvdXRNcztcbiAgICBpZiAodGhpcy50aW1lb3V0TXMpIHRoaXMuY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMub25Db25uZWN0aW9uRXJyb3IocmVjb25uZWN0KSwgdGhpcy50aW1lb3V0TXMpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0cy5hdHRlbXB0KCk7XG4gICAgICBpZiAodGhpcy5fc3RhdHVzID09PSAxIC8qIERJU0NPTk5FQ1RFRCAqLykgdGhpcy5fc3RhdHVzID0gNCAvKiBDT05ORUNUSU5HICovO1xuICAgICAgZWxzZSB0aGlzLl9zdGF0dXMgPSAyIC8qIFJFQ09OTkVDVElORyAqLztcbiAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHRoaXMubmRrUmVsYXkudXJsKTtcbiAgICAgIHRoaXMud3Mub25vcGVuID0gdGhpcy5vbkNvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMud3Mub25jbG9zZSA9IHRoaXMub25EaXNjb25uZWN0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IHRoaXMub25NZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLndzLm9uZXJyb3IgPSB0aGlzLm9uRXJyb3IuYmluZCh0aGlzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmRlYnVnKGBGYWlsZWQgdG8gY29ubmVjdCB0byAke3RoaXMubmRrUmVsYXkudXJsfWAsIGUpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gMSAvKiBESVNDT05ORUNURUQgKi87XG4gICAgICBpZiAocmVjb25uZWN0KSB0aGlzLmhhbmRsZVJlY29ubmVjdGlvbigpO1xuICAgICAgZWxzZSB0aGlzLm5ka1JlbGF5LmVtaXQoXCJkZWxheWVkLWNvbm5lY3RcIiwgMiAqIDI0ICogNjAgKiA2MCAqIDFlMyk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGlzY29ubmVjdHMgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSBOREsgcmVsYXkuXG4gICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIGNvbm5lY3Rpb24gc3RhdHVzIHRvIGBOREtSZWxheVN0YXR1cy5ESVNDT05ORUNUSU5HYCxcbiAgICogYXR0ZW1wdHMgdG8gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLCBhbmQgc2V0cyB0aGUgc3RhdHVzIHRvXG4gICAqIGBOREtSZWxheVN0YXR1cy5ESVNDT05ORUNURURgIGlmIHRoZSBkaXNjb25uZWN0IG9wZXJhdGlvbiBmYWlscy5cbiAgICovXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5fc3RhdHVzID0gMCAvKiBESVNDT05ORUNUSU5HICovO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLndzPy5jbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJGYWlsZWQgdG8gZGlzY29ubmVjdFwiLCBlKTtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IDEgLyogRElTQ09OTkVDVEVEICovO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgZXJyb3IgdGhhdCBvY2N1cnJlZCB3aGVuIGF0dGVtcHRpbmcgdG8gY29ubmVjdCB0byB0aGUgTkRLIHJlbGF5LlxuICAgKiBJZiBgcmVjb25uZWN0YCBpcyBgdHJ1ZWAsIHRoaXMgbWV0aG9kIHdpbGwgaW5pdGlhdGUgYSByZWNvbm5lY3Rpb24gYXR0ZW1wdC5cbiAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIGVtaXQgYSBgZGVsYXllZC1jb25uZWN0YCBldmVudCBvbiB0aGUgYG5ka1JlbGF5YCBvYmplY3QsXG4gICAqIGluZGljYXRpbmcgdGhhdCBhIHJlY29ubmVjdGlvbiBzaG91bGQgYmUgYXR0ZW1wdGVkIGFmdGVyIGEgZGVsYXkuXG4gICAqXG4gICAqIEBwYXJhbSByZWNvbm5lY3QgLSBJbmRpY2F0ZXMgd2hldGhlciBhIHJlY29ubmVjdGlvbiBzaG91bGQgYmUgYXR0ZW1wdGVkLlxuICAgKi9cbiAgb25Db25uZWN0aW9uRXJyb3IocmVjb25uZWN0KSB7XG4gICAgdGhpcy5kZWJ1ZyhgRXJyb3IgY29ubmVjdGluZyB0byAke3RoaXMubmRrUmVsYXkudXJsfWAsIHRoaXMudGltZW91dE1zKTtcbiAgICBpZiAocmVjb25uZWN0ICYmICF0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBjb25uZWN0aW9uIGV2ZW50IHdoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bGx5IG9wZW5lZC5cbiAgICogSXQgY2xlYXJzIGFueSBleGlzdGluZyBjb25uZWN0aW9uIGFuZCByZWNvbm5lY3Rpb24gdGltZW91dHMsIHVwZGF0ZXMgdGhlIGNvbm5lY3Rpb24gc3RhdGlzdGljcyxcbiAgICogc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYENPTk5FQ1RFRGAsIGFuZCBlbWl0cyBgY29ubmVjdGAgYW5kIGByZWFkeWAgZXZlbnRzIG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdC5cbiAgICovXG4gIG9uQ29ubmVjdCgpIHtcbiAgICB0aGlzLm5ldERlYnVnPy4oXCJjb25uZWN0ZWRcIiwgdGhpcy5uZGtSZWxheSk7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dCk7XG4gICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0ID0gdm9pZCAwO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWQoKTtcbiAgICB0aGlzLl9zdGF0dXMgPSA1IC8qIENPTk5FQ1RFRCAqLztcbiAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJjb25uZWN0XCIpO1xuICAgIHRoaXMubmRrUmVsYXkuZW1pdChcInJlYWR5XCIpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBkaXNjb25uZWN0aW9uIGV2ZW50IHdoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBjbG9zZWQuXG4gICAqIEl0IHVwZGF0ZXMgdGhlIGNvbm5lY3Rpb24gc3RhdGlzdGljcywgc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYERJU0NPTk5FQ1RFRGAsXG4gICAqIGluaXRpYXRlcyBhIHJlY29ubmVjdGlvbiBhdHRlbXB0IGlmIHdlIGRpZG4ndCBkaXNjb25uZWN0IG91cnNlbHZlcyxcbiAgICogYW5kIGVtaXRzIGEgYGRpc2Nvbm5lY3RgIGV2ZW50IG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdC5cbiAgICovXG4gIG9uRGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLm5ldERlYnVnPy4oXCJkaXNjb25uZWN0ZWRcIiwgdGhpcy5uZGtSZWxheSk7XG4gICAgdGhpcy51cGRhdGVDb25uZWN0aW9uU3RhdHMuZGlzY29ubmVjdGVkKCk7XG4gICAgaWYgKHRoaXMuX3N0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuX3N0YXR1cyA9IDEgLyogRElTQ09OTkVDVEVEICovO1xuICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImRpc2Nvbm5lY3RcIik7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgaW5jb21pbmcgbWVzc2FnZXMgZnJvbSB0aGUgTkRLIHJlbGF5IFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBtZXNzYWdlIGlzIHJlY2VpdmVkIGZyb20gdGhlIHJlbGF5LlxuICAgKiBJdCBwYXJzZXMgdGhlIG1lc3NhZ2UgZGF0YSBhbmQgZGlzcGF0Y2hlcyB0aGUgYXBwcm9wcmlhdGUgaGFuZGxpbmcgbG9naWMgYmFzZWQgb24gdGhlIG1lc3NhZ2UgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIE1lc3NhZ2VFdmVudCBjb250YWluaW5nIHRoZSByZWNlaXZlZCBtZXNzYWdlIGRhdGEuXG4gICAqL1xuICBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICB0aGlzLm5ldERlYnVnPy4oZXZlbnQuZGF0YSwgdGhpcy5uZGtSZWxheSwgXCJyZWN2XCIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgIGNvbnN0IFtjbWQsIGlkLCAuLi5fcmVzdF0gPSBkYXRhO1xuICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgY2FzZSBcIkVWRU5UXCI6IHtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGlkKTtcbiAgICAgICAgICBjb25zdCBldmVudDIgPSBkYXRhWzJdO1xuICAgICAgICAgIGlmICghc28pIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoYFJlY2VpdmVkIGV2ZW50IGZvciB1bmtub3duIHN1YnNjcmlwdGlvbiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzby5vbmV2ZW50KGV2ZW50Mik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDT1VOVFwiOiB7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGFbMl07XG4gICAgICAgICAgY29uc3QgY3IgPSB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLmdldChpZCk7XG4gICAgICAgICAgaWYgKGNyKSB7XG4gICAgICAgICAgICBjci5yZXNvbHZlKHBheWxvYWQuY291bnQpO1xuICAgICAgICAgICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5kZWxldGUoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkVPU0VcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoaWQpO1xuICAgICAgICAgIGlmICghc28pIHJldHVybjtcbiAgICAgICAgICBzby5vbmVvc2UoaWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiT0tcIjoge1xuICAgICAgICAgIGNvbnN0IG9rID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zdCByZWFzb24gPSBkYXRhWzNdO1xuICAgICAgICAgIGNvbnN0IGVwID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGlkKTtcbiAgICAgICAgICBjb25zdCBmaXJzdEVwID0gZXA/LnBvcCgpO1xuICAgICAgICAgIGlmICghZXAgfHwgIWZpcnN0RXApIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoXCJSZWNlaXZlZCBPSyBmb3IgdW5rbm93biBldmVudCBwdWJsaXNoXCIsIGlkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9rKSBmaXJzdEVwLnJlc29sdmUocmVhc29uKTtcbiAgICAgICAgICBlbHNlIGZpcnN0RXAucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICAgICAgICBpZiAoZXAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5kZWxldGUoaWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5zZXQoaWQsIGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDTE9TRURcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoaWQpO1xuICAgICAgICAgIGlmICghc28pIHJldHVybjtcbiAgICAgICAgICBzby5vbmNsb3NlZChkYXRhWzJdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk5PVElDRVwiOlxuICAgICAgICAgIHRoaXMub25Ob3RpY2UoZGF0YVsxXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwiQVVUSFwiOiB7XG4gICAgICAgICAgdGhpcy5vbkF1dGhSZXF1ZXN0ZWQoZGF0YVsxXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZGVidWcoYEVycm9yIHBhcnNpbmcgbWVzc2FnZSBmcm9tICR7dGhpcy5uZGtSZWxheS51cmx9OiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3I/LnN0YWNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gYXV0aGVudGljYXRpb24gcmVxdWVzdCBmcm9tIHRoZSBOREsgcmVsYXkuXG4gICAqXG4gICAqIElmIGFuIGF1dGhlbnRpY2F0aW9uIHBvbGljeSBpcyBjb25maWd1cmVkLCBpdCB3aWxsIGJlIHVzZWQgdG8gYXV0aGVudGljYXRlIHRoZSBjb25uZWN0aW9uLlxuICAgKiBPdGhlcndpc2UsIHRoZSBgYXV0aGAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIHRvIGFsbG93IHRoZSBhcHBsaWNhdGlvbiB0byBoYW5kbGUgdGhlIGF1dGhlbnRpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gY2hhbGxlbmdlIC0gVGhlIGF1dGhlbnRpY2F0aW9uIGNoYWxsZW5nZSBwcm92aWRlZCBieSB0aGUgTkRLIHJlbGF5LlxuICAgKi9cbiAgYXN5bmMgb25BdXRoUmVxdWVzdGVkKGNoYWxsZW5nZSkge1xuICAgIGNvbnN0IGF1dGhQb2xpY3kgPSB0aGlzLm5ka1JlbGF5LmF1dGhQb2xpY3kgPz8gdGhpcy5uZGs/LnJlbGF5QXV0aERlZmF1bHRQb2xpY3k7XG4gICAgdGhpcy5kZWJ1ZyhcIlJlbGF5IHJlcXVlc3RlZCBhdXRoZW50aWNhdGlvblwiLCB7XG4gICAgICBoYXZlUG9saWN5OiAhIWF1dGhQb2xpY3lcbiAgICB9KTtcbiAgICBpZiAodGhpcy5fc3RhdHVzID09PSA3IC8qIEFVVEhFTlRJQ0FUSU5HICovKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiQWxyZWFkeSBhdXRoZW50aWNhdGluZywgaWdub3JpbmdcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3N0YXR1cyA9IDYgLyogQVVUSF9SRVFVRVNURUQgKi87XG4gICAgaWYgKGF1dGhQb2xpY3kpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gNyAvKiBBVVRIRU5USUNBVElORyAqLztcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSBhd2FpdCBhdXRoUG9saWN5KHRoaXMubmRrUmVsYXksIGNoYWxsZW5nZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmRlYnVnKFwiQXV0aGVudGljYXRpb24gcG9saWN5IHRocmV3IGFuIGVycm9yXCIsIGUpO1xuICAgICAgICAgIHJlcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcoXCJBdXRoZW50aWNhdGlvbiBwb2xpY3kgcmV0dXJuZWRcIiwgISFyZXMpO1xuICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgTkRLRXZlbnQgfHwgcmVzID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIE5ES0V2ZW50KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmF1dGgocmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYXV0aGVudGljYXRlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLyAmJiB0aGlzLl9zdGF0dXMgPCA4IC8qIEFVVEhFTlRJQ0FURUQgKi8pIHtcbiAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGspO1xuICAgICAgICAgICAgICBldmVudC5raW5kID0gMjIyNDIgLyogQ2xpZW50QXV0aCAqLztcbiAgICAgICAgICAgICAgZXZlbnQudGFncyA9IFtcbiAgICAgICAgICAgICAgICBbXCJyZWxheVwiLCB0aGlzLm5ka1JlbGF5LnVybF0sXG4gICAgICAgICAgICAgICAgW1wiY2hhbGxlbmdlXCIsIGNoYWxsZW5nZV1cbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgYXdhaXQgZXZlbnQuc2lnbigpO1xuICAgICAgICAgICAgICB0aGlzLmF1dGgoZXZlbnQpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IDggLyogQVVUSEVOVElDQVRFRCAqLztcbiAgICAgICAgICAgICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJhdXRoZWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkF1dGhlbnRpY2F0aW9uIHN1Y2Nlc3NmdWxcIik7XG4gICAgICAgICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gNiAvKiBBVVRIX1JFUVVFU1RFRCAqLztcbiAgICAgICAgICAgICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJhdXRoOmZhaWxlZFwiLCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwiQXV0aGVudGljYXRpb24gZmFpbGVkXCIsIGUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVidWcoXCJBdXRoZW50aWNhdGlvbiBmYWlsZWQsIGl0IGNoYW5nZWQgc3RhdHVzLCBzdGF0dXMgaXMgJWRcIiwgdGhpcy5fc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChyZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5uZGs/LnNpZ25lcikge1xuICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwiTm8gc2lnbmVyIGF2YWlsYWJsZSBmb3IgYXV0aGVudGljYXRpb24gbG9jYWxob3N0XCIpO1xuICAgICAgICAgICAgICB0aGlzLm5kaz8ub25jZShcInNpZ25lcjpyZWFkeVwiLCBhdXRoZW50aWNhdGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXV0aGVudGljYXRlKCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYXV0aGVudGljYXRpbmdcIiwgZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zdGF0dXMgPSA1IC8qIENPTk5FQ1RFRCAqLztcbiAgICAgICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJhdXRoZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uZGtSZWxheS5lbWl0KFwiYXV0aFwiLCBjaGFsbGVuZ2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBlcnJvcnMgdGhhdCBvY2N1ciBvbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIHJlbGF5LlxuICAgKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3Igb3IgZXZlbnQgdGhhdCBvY2N1cnJlZC5cbiAgICovXG4gIG9uRXJyb3IoZXJyb3IpIHtcbiAgICB0aGlzLmRlYnVnKGBXZWJTb2NrZXQgZXJyb3Igb24gJHt0aGlzLm5ka1JlbGF5LnVybH06YCwgZXJyb3IpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgTkRLIHJlbGF5IGNvbm5lY3Rpb24uXG4gICAqIEByZXR1cm5zIHtOREtSZWxheVN0YXR1c30gVGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBOREsgcmVsYXkgY29ubmVjdGlvbi5cbiAgICovXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBOREsgcmVsYXkgY29ubmVjdGlvbiBpcyBjdXJyZW50bHkgYXZhaWxhYmxlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSByZWxheSBjb25uZWN0aW9uIGlzIGluIHRoZSBgQ09OTkVDVEVEYCBzdGF0dXMsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNBdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi87XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgTkRLIHJlbGF5IGNvbm5lY3Rpb24gaXMgZmxhcHBpbmcsIHdoaWNoIG1lYW5zIHRoZSBjb25uZWN0aW9uIGlzIHJhcGlkbHlcbiAgICogZGlzY29ubmVjdGluZyBhbmQgcmVjb25uZWN0aW5nLiBUaGlzIGlzIGRldGVybWluZWQgYnkgYW5hbHl6aW5nIHRoZSBkdXJhdGlvbnMgb2YgdGhlXG4gICAqIGxhc3QgdGhyZWUgY29ubmVjdGlvbiBhdHRlbXB0cy4gSWYgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgZHVyYXRpb25zIGlzIGxlc3NcbiAgICogdGhhbiAxMDAwIG1pbGxpc2Vjb25kcywgdGhlIGNvbm5lY3Rpb24gaXMgY29uc2lkZXJlZCB0byBiZSBmbGFwcGluZy5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgY29ubmVjdGlvbiBpcyBmbGFwcGluZywgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICBpc0ZsYXBwaW5nKCkge1xuICAgIGNvbnN0IGR1cmF0aW9ucyA9IHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5kdXJhdGlvbnM7XG4gICAgaWYgKGR1cmF0aW9ucy5sZW5ndGggJSAzICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgc3VtID0gZHVyYXRpb25zLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICAgIGNvbnN0IGF2ZyA9IHN1bSAvIGR1cmF0aW9ucy5sZW5ndGg7XG4gICAgY29uc3QgdmFyaWFuY2UgPSBkdXJhdGlvbnMubWFwKCh4KSA9PiAoeCAtIGF2ZykgKiogMikucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBkdXJhdGlvbnMubGVuZ3RoO1xuICAgIGNvbnN0IHN0ZERldiA9IE1hdGguc3FydCh2YXJpYW5jZSk7XG4gICAgY29uc3QgaXNGbGFwcGluZyA9IHN0ZERldiA8IEZMQVBQSU5HX1RIUkVTSE9MRF9NUztcbiAgICByZXR1cm4gaXNGbGFwcGluZztcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBhIG5vdGljZSByZWNlaXZlZCBmcm9tIHRoZSBOREsgcmVsYXkuXG4gICAqIElmIHRoZSBub3RpY2UgaW5kaWNhdGVzIHRoZSByZWxheSBpcyBjb21wbGFpbmluZyAoZS5nLiBcInRvbyBtYW55XCIgb3IgXCJtYXhpbXVtXCIpLFxuICAgKiB0aGUgbWV0aG9kIGRpc2Nvbm5lY3RzIGZyb20gdGhlIHJlbGF5IGFuZCBhdHRlbXB0cyB0byByZWNvbm5lY3QgYWZ0ZXIgYSAyLXNlY29uZCBkZWxheS5cbiAgICogQSBkZWJ1ZyBtZXNzYWdlIGlzIGxvZ2dlZCB3aXRoIHRoZSByZWxheSBVUkwgYW5kIHRoZSBub3RpY2UgdGV4dC5cbiAgICogVGhlIFwibm90aWNlXCIgZXZlbnQgaXMgZW1pdHRlZCBvbiB0aGUgbmRrUmVsYXkgaW5zdGFuY2Ugd2l0aCB0aGUgbm90aWNlIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSBub3RpY2UgLSBUaGUgbm90aWNlIHRleHQgcmVjZWl2ZWQgZnJvbSB0aGUgTkRLIHJlbGF5LlxuICAgKi9cbiAgYXN5bmMgb25Ob3RpY2Uobm90aWNlKSB7XG4gICAgdGhpcy5uZGtSZWxheS5lbWl0KFwibm90aWNlXCIsIG5vdGljZSk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIHJlY29ubmVjdCB0byB0aGUgTkRLIHJlbGF5IGFmdGVyIGEgY29ubmVjdGlvbiBpcyBsb3N0LlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCByZWN1cnNpdmVseSB0byBoYW5kbGUgbXVsdGlwbGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzLlxuICAgKiBJdCBjaGVja3MgaWYgdGhlIHJlbGF5IGlzIGZsYXBwaW5nIGFuZCBlbWl0cyBhIFwiZmxhcHBpbmdcIiBldmVudCBpZiBzby5cbiAgICogSXQgdGhlbiBjYWxjdWxhdGVzIGEgZGVsYXkgYmVmb3JlIHRoZSBuZXh0IHJlY29ubmVjdGlvbiBhdHRlbXB0IGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgcHJldmlvdXMgYXR0ZW1wdHMuXG4gICAqIFRoZSBmdW5jdGlvbiBzZXRzIGEgdGltZW91dCB0byBleGVjdXRlIHRoZSBuZXh0IHJlY29ubmVjdGlvbiBhdHRlbXB0IGFmdGVyIHRoZSBjYWxjdWxhdGVkIGRlbGF5LlxuICAgKiBJZiB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGlzIHJlYWNoZWQsIGEgZGVidWcgbWVzc2FnZSBpcyBsb2dnZWQuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRlbXB0IC0gVGhlIGN1cnJlbnQgYXR0ZW1wdCBudW1iZXIgKGRlZmF1bHQgaXMgMCkuXG4gICAqL1xuICBoYW5kbGVSZWNvbm5lY3Rpb24oYXR0ZW1wdCA9IDApIHtcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSByZXR1cm47XG4gICAgaWYgKHRoaXMuaXNGbGFwcGluZygpKSB7XG4gICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJmbGFwcGluZ1wiLCB0aGlzLl9jb25uZWN0aW9uU3RhdHMpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gMyAvKiBGTEFQUElORyAqLztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVjb25uZWN0RGVsYXkgPSB0aGlzLmNvbm5lY3RlZEF0ID8gTWF0aC5tYXgoMCwgNmU0IC0gKERhdGUubm93KCkgLSB0aGlzLmNvbm5lY3RlZEF0KSkgOiA1ZTMgKiAodGhpcy5fY29ubmVjdGlvblN0YXRzLmF0dGVtcHRzICsgMSk7XG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICB0aGlzLl9zdGF0dXMgPSAyIC8qIFJFQ09OTkVDVElORyAqLztcbiAgICAgIHRoaXMuY29ubmVjdCgpLmNhdGNoKChfZXJyKSA9PiB7XG4gICAgICAgIGlmIChhdHRlbXB0IDwgTUFYX1JFQ09OTkVDVF9BVFRFTVBUUykge1xuICAgICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKGF0dGVtcHQgKyAxKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAxZTMgKiAoYXR0ZW1wdCArIDEpIF4gNFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZyhcIlJlY29ubmVjdCBmYWlsZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHJlY29ubmVjdERlbGF5KTtcbiAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJkZWxheWVkLWNvbm5lY3RcIiwgcmVjb25uZWN0RGVsYXkpO1xuICAgIHRoaXMuZGVidWcoXCJSZWNvbm5lY3RpbmcgaW5cIiwgcmVjb25uZWN0RGVsYXkpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5uZXh0UmVjb25uZWN0QXQgPSBEYXRlLm5vdygpICsgcmVjb25uZWN0RGVsYXk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgTkRLIHJlbGF5IGlmIHRoZSBjb25uZWN0aW9uIGlzIGluIHRoZSBDT05ORUNURUQgc3RhdGUgYW5kIHRoZSBXZWJTb2NrZXQgaXMgb3Blbi5cbiAgICogSWYgdGhlIGNvbm5lY3Rpb24gaXMgbm90IGluIHRoZSBDT05ORUNURUQgc3RhdGUgb3IgdGhlIFdlYlNvY2tldCBpcyBub3Qgb3BlbiwgbG9ncyBhIGRlYnVnIG1lc3NhZ2UgYW5kIHRocm93cyBhbiBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBzZW5kIHRvIHRoZSBOREsgcmVsYXkuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhdHRlbXB0aW5nIHRvIHNlbmQgb24gYSBjbG9zZWQgcmVsYXkgY29ubmVjdGlvbi5cbiAgICovXG4gIGFzeW5jIHNlbmQobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLl9zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi8gJiYgdGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHRoaXMud3M/LnNlbmQobWVzc2FnZSk7XG4gICAgICB0aGlzLm5ldERlYnVnPy4obWVzc2FnZSwgdGhpcy5uZGtSZWxheSwgXCJzZW5kXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlYnVnKGBOb3QgY29ubmVjdGVkIHRvICR7dGhpcy5uZGtSZWxheS51cmx9ICglZCksIG5vdCBzZW5kaW5nIG1lc3NhZ2UgJHttZXNzYWdlfWAsIHRoaXMuX3N0YXR1cyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBdXRoZW50aWNhdGVzIHRoZSBOREsgZXZlbnQgYnkgc2VuZGluZyBpdCB0byB0aGUgTkRLIHJlbGF5IGFuZCByZXR1cm5pbmcgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgTkRLIGV2ZW50IHRvIGF1dGhlbnRpY2F0ZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgYXV0aGVudGljYXRpb24gcmVzdWx0LlxuICAgKi9cbiAgYXN5bmMgYXV0aChldmVudCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHZhbCA9IHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmdldChldmVudC5pZCkgPz8gW107XG4gICAgICB2YWwucHVzaCh7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChldmVudC5pZCwgdmFsKTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoYFtcIkFVVEhcIiwke0pTT04uc3RyaW5naWZ5KGV2ZW50LnJhd0V2ZW50KCkpfV1gKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoZXMgYW4gTkRLIGV2ZW50IHRvIHRoZSByZWxheSBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBOREsgZXZlbnQgdG8gcHVibGlzaC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBldmVudCBwdWJsaWNhdGlvbi5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIGF0dGVtcHRpbmcgdG8gcHVibGlzaCBvbiBhIGNsb3NlZCByZWxheSBjb25uZWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChldmVudCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHZhbCA9IHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmdldChldmVudC5pZCkgPz8gW107XG4gICAgICBpZiAodmFsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBEdXBsaWNhdGUgZXZlbnQgcHVibGlzaGluZyBkZXRlY3RlZCwgeW91IGFyZSBwdWJsaXNoaW5nIGV2ZW50ICR7ZXZlbnQuaWR9IHR3aWNlYCk7XG4gICAgICB9XG4gICAgICB2YWwucHVzaCh7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChldmVudC5pZCwgdmFsKTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoYFtcIkVWRU5UXCIsJHtKU09OLnN0cmluZ2lmeShldmVudCl9XWApO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgLyoqXG4gICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGV2ZW50cyB0aGF0IG1hdGNoIHRoZSBwcm92aWRlZCBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gZmlsdGVycyAtIFRoZSBmaWx0ZXJzIHRvIGFwcGx5IHRvIHRoZSBjb3VudCByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IGNvbnRhaW5pbmcgYSBjdXN0b20gaWQgZm9yIHRoZSBjb3VudCByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBudW1iZXIgb2YgbWF0Y2hpbmcgZXZlbnRzLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYXR0ZW1wdGluZyB0byBzZW5kIHRoZSBjb3VudCByZXF1ZXN0IG9uIGEgY2xvc2VkIHJlbGF5IGNvbm5lY3Rpb24uXG4gICAqL1xuICBhc3luYyBjb3VudChmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnNlcmlhbCsrO1xuICAgIGNvbnN0IGlkID0gcGFyYW1zPy5pZCB8fCBgY291bnQ6JHt0aGlzLnNlcmlhbH1gO1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuc2V0KGlkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoYFtcIkNPVU5UXCIsXCIke2lkfVwiLCR7SlNPTi5zdHJpbmdpZnkoZmlsdGVycykuc3Vic3RyaW5nKDEpfWApO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgY2xvc2Uoc3ViSWQsIHJlYXNvbikge1xuICAgIHRoaXMuc2VuZChgW1wiQ0xPU0VcIixcIiR7c3ViSWR9XCJdYCk7XG4gICAgY29uc3Qgc3ViID0gdGhpcy5vcGVuU3Vicy5nZXQoc3ViSWQpO1xuICAgIHRoaXMub3BlblN1YnMuZGVsZXRlKHN1YklkKTtcbiAgICBpZiAoc3ViKSBzdWIub25jbG9zZShyZWFzb24pO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBOREsgcmVsYXkgd2l0aCB0aGUgcHJvdmlkZWQgZmlsdGVycyBhbmQgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIGZpbHRlcnMgLSBUaGUgZmlsdGVycyB0byBhcHBseSB0byB0aGUgc3Vic2NyaXB0aW9uLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHN1YnNjcmlwdGlvbiBwYXJhbWV0ZXJzLCBpbmNsdWRpbmcgYW4gb3B0aW9uYWwgY3VzdG9tIGlkLlxuICAgKiBAcmV0dXJucyBBIG5ldyBOREtSZWxheVN1YnNjcmlwdGlvbiBpbnN0YW5jZS5cbiAgICovXG4gIHJlcShyZWxheVN1Yikge1xuICAgIGAke3RoaXMuc2VuZChgW1wiUkVRXCIsXCIke3JlbGF5U3ViLnN1YklkfVwiLCR7SlNPTi5zdHJpbmdpZnkocmVsYXlTdWIuZXhlY3V0ZUZpbHRlcnMpLnN1YnN0cmluZygxKX1gKX1dYDtcbiAgICB0aGlzLm9wZW5TdWJzLnNldChyZWxheVN1Yi5zdWJJZCwgcmVsYXlTdWIpO1xuICB9XG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB1cGRhdGUgdGhlIGNvbm5lY3Rpb24gc3RhdHMuXG4gICAqL1xuICB1cGRhdGVDb25uZWN0aW9uU3RhdHMgPSB7XG4gICAgY29ubmVjdGVkOiAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuc3VjY2VzcysrO1xuICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuICAgIGRpc2Nvbm5lY3RlZDogKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuZHVyYXRpb25zLnB1c2goRGF0ZS5ub3coKSAtIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCk7XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9uU3RhdHMuZHVyYXRpb25zLmxlbmd0aCA+IDEwMCkge1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5kdXJhdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZEF0ID0gdm9pZCAwO1xuICAgIH0sXG4gICAgYXR0ZW1wdDogKCkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmF0dGVtcHRzKys7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXQgPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgfTtcbiAgLyoqIFJldHVybnMgdGhlIGNvbm5lY3Rpb24gc3RhdHMuICovXG4gIGdldCBjb25uZWN0aW9uU3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cztcbiAgfVxuICAvKiogUmV0dXJucyB0aGUgcmVsYXkgVVJMICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMubmRrUmVsYXkudXJsO1xuICB9XG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLyAmJiB0aGlzLndzPy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTjtcbiAgfVxufTtcblxuLy8gc3JjL3JlbGF5L3B1Ymxpc2hlci50c1xudmFyIE5ES1JlbGF5UHVibGlzaGVyID0gY2xhc3Mge1xuICBuZGtSZWxheTtcbiAgZGVidWc7XG4gIGNvbnN0cnVjdG9yKG5ka1JlbGF5KSB7XG4gICAgdGhpcy5uZGtSZWxheSA9IG5ka1JlbGF5O1xuICAgIHRoaXMuZGVidWcgPSBuZGtSZWxheS5kZWJ1Zy5leHRlbmQoXCJwdWJsaXNoZXJcIik7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2hlZCBhbiBldmVudCB0byB0aGUgcmVsYXk7IGlmIHRoZSByZWxheSBpcyBub3QgY29ubmVjdGVkLCBpdCB3aWxsXG4gICAqIHdhaXQgZm9yIHRoZSByZWxheSB0byBjb25uZWN0IGJlZm9yZSBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAgICpcbiAgICogSWYgdGhlIHJlbGF5IGRvZXMgbm90IGNvbm5lY3Qgd2l0aGluIHRoZSB0aW1lb3V0LCB0aGUgcHVibGlzaCBvcGVyYXRpb25cbiAgICogd2lsbCBmYWlsLlxuICAgKiBAcGFyYW0gZXZlbnQgIFRoZSBldmVudCB0byBwdWJsaXNoXG4gICAqIEBwYXJhbSB0aW1lb3V0TXMgIFRoZSB0aW1lb3V0IGZvciB0aGUgcHVibGlzaCBvcGVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGV2ZW50IGhhcyBiZWVuIHB1Ymxpc2hlZCBvciByZWplY3RzIGlmIHRoZSBvcGVyYXRpb24gdGltZXMgb3V0XG4gICAqL1xuICBhc3luYyBwdWJsaXNoKGV2ZW50LCB0aW1lb3V0TXMgPSAyNTAwKSB7XG4gICAgbGV0IHRpbWVvdXQ7XG4gICAgY29uc3QgcHVibGlzaENvbm5lY3RlZCA9ICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5wdWJsaXNoRXZlbnQoZXZlbnQpLnRoZW4oKF9yZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcInB1Ymxpc2hlZFwiLCBldmVudCk7XG4gICAgICAgICAgICBldmVudC5lbWl0KFwicmVsYXk6cHVibGlzaGVkXCIsIHRoaXMubmRrUmVsYXkpO1xuICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGltZW91dCA9IHZvaWQgMDtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgVGltZW91dDogJHt0aW1lb3V0TXN9bXNgKSk7XG4gICAgICB9LCB0aW1lb3V0TXMpO1xuICAgIH0pO1xuICAgIGNvbnN0IG9uQ29ubmVjdEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBwdWJsaXNoQ29ubmVjdGVkKCkudGhlbigocmVzdWx0KSA9PiBjb25uZWN0UmVzb2x2ZShyZXN1bHQpKS5jYXRjaCgoZXJyKSA9PiBjb25uZWN0UmVqZWN0KGVycikpO1xuICAgIH07XG4gICAgbGV0IGNvbm5lY3RSZXNvbHZlO1xuICAgIGxldCBjb25uZWN0UmVqZWN0O1xuICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICB0aGlzLm5ka1JlbGF5LmRlYnVnKFwiUHVibGlzaCBmYWlsZWRcIiwgZXJyLCBldmVudC5pZCk7XG4gICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJwdWJsaXNoOmZhaWxlZFwiLCBldmVudCwgZXJyKTtcbiAgICAgIGV2ZW50LmVtaXQoXCJyZWxheTpwdWJsaXNoOmZhaWxlZFwiLCB0aGlzLm5ka1JlbGF5LCBlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH07XG4gICAgY29uc3Qgb25GaW5hbGx5ID0gKCkgPT4ge1xuICAgICAgaWYgKHRpbWVvdXQpIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRoaXMubmRrUmVsYXkucmVtb3ZlTGlzdGVuZXIoXCJjb25uZWN0XCIsIG9uQ29ubmVjdEhhbmRsZXIpO1xuICAgIH07XG4gICAgaWYgKHRoaXMubmRrUmVsYXkuc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtwdWJsaXNoQ29ubmVjdGVkKCksIHRpbWVvdXRQcm9taXNlXSkuY2F0Y2gob25FcnJvcikuZmluYWxseShvbkZpbmFsbHkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZGtSZWxheS5zdGF0dXMgPD0gMSAvKiBESVNDT05ORUNURUQgKi8pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlJlbGF5IGlzIGRpc2Nvbm5lY3RlZCwgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gcHVibGlzaCBhbiBldmVudFwiLCB0aGlzLm5ka1JlbGF5LnVybCk7XG4gICAgICB0aGlzLm5ka1JlbGF5LmNvbm5lY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiUmVsYXkgbm90IGNvbm5lY3RlZCwgd2FpdGluZyBmb3IgY29ubmVjdGlvbiB0byBwdWJsaXNoIGFuIGV2ZW50XCIsIHRoaXMubmRrUmVsYXkudXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbm5lY3RSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgY29ubmVjdFJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgdGhpcy5uZGtSZWxheS5vbmNlKFwiY29ubmVjdFwiLCBvbkNvbm5lY3RIYW5kbGVyKTtcbiAgICAgIH0pLFxuICAgICAgdGltZW91dFByb21pc2VcbiAgICBdKS5jYXRjaChvbkVycm9yKS5maW5hbGx5KG9uRmluYWxseSk7XG4gIH1cbiAgYXN5bmMgcHVibGlzaEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMubmRrUmVsYXkuY29ubmVjdGl2aXR5LnB1Ymxpc2goZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vZ3JvdXBpbmcudHNcbmZ1bmN0aW9uIGZpbHRlckZpbmdlcnByaW50KGZpbHRlcnMsIGNsb3NlT25Fb3NlKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gW107XG4gIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmVudHJpZXMoZmlsdGVyIHx8IHt9KS5tYXAoKFtrZXksIHZhbHVlc10pID0+IHtcbiAgICAgIGlmIChbXCJzaW5jZVwiLCBcInVudGlsXCJdLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGAke2tleX06JHt2YWx1ZXN9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXk7XG4gICAgfSkuc29ydCgpLmpvaW4oXCItXCIpO1xuICAgIGVsZW1lbnRzLnB1c2goa2V5cyk7XG4gIH1cbiAgbGV0IGlkID0gY2xvc2VPbkVvc2UgPyBcIitcIiA6IFwiXCI7XG4gIGlkICs9IGVsZW1lbnRzLmpvaW4oXCJ8XCIpO1xuICByZXR1cm4gaWQ7XG59XG5mdW5jdGlvbiBtZXJnZUZpbHRlcnMoZmlsdGVycykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgbGFzdFJlc3VsdCA9IHt9O1xuICBmaWx0ZXJzLmZpbHRlcigoZikgPT4gISFmLmxpbWl0KS5mb3JFYWNoKChmaWx0ZXJXaXRoTGltaXQpID0+IHJlc3VsdC5wdXNoKGZpbHRlcldpdGhMaW1pdCkpO1xuICBmaWx0ZXJzID0gZmlsdGVycy5maWx0ZXIoKGYpID0+ICFmLmxpbWl0KTtcbiAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzdWx0O1xuICBmaWx0ZXJzLmZvckVhY2goKGZpbHRlcikgPT4ge1xuICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGxhc3RSZXN1bHRba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgbGFzdFJlc3VsdFtrZXldID0gWy4uLnZhbHVlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0UmVzdWx0W2tleV0gPSBBcnJheS5mcm9tKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5sYXN0UmVzdWx0W2tleV0sIC4uLnZhbHVlXSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0UmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBbLi4ucmVzdWx0LCBsYXN0UmVzdWx0XTtcbn1cblxuLy8gc3JjL3JlbGF5L3N1YnNjcmlwdGlvbi50c1xudmFyIE5ES1JlbGF5U3Vic2NyaXB0aW9uID0gY2xhc3Mge1xuICBmaW5nZXJwcmludDtcbiAgaXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB0b3BTdWJNYW5hZ2VyO1xuICBkZWJ1ZztcbiAgLyoqXG4gICAqIFRyYWNrcyB0aGUgc3RhdHVzIG9mIHRoaXMgUkVRLlxuICAgKi9cbiAgc3RhdHVzID0gMCAvKiBJTklUSUFMICovO1xuICBvbkNsb3NlO1xuICByZWxheTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBzdWJzY3JpcHRpb24gaGFzIHJlYWNoZWQgRU9TRS5cbiAgICovXG4gIGVvc2VkID0gZmFsc2U7XG4gIC8qKlxuICAgKiBUaW1lb3V0IGF0IHdoaWNoIHRoaXMgc3Vic2NyaXB0aW9uIHdpbGxcbiAgICogc3RhcnQgZXhlY3V0aW5nLlxuICAgKi9cbiAgZXhlY3V0aW9uVGltZXI7XG4gIC8qKlxuICAgKiBUcmFjayB0aGUgdGltZSBhdCB3aGljaCB0aGlzIHN1YnNjcmlwdGlvbiB3aWxsIGZpcmUuXG4gICAqL1xuICBmaXJlVGltZTtcbiAgLyoqXG4gICAqIFRoZSBkZWxheSB0eXBlIHRoYXQgdGhlIGN1cnJlbnQgZmlyZVRpbWUgd2FzIGNhbGN1bGF0ZWQgd2l0aC5cbiAgICovXG4gIGRlbGF5VHlwZTtcbiAgLyoqXG4gICAqIFRoZSBmaWx0ZXJzIHRoYXQgaGF2ZSBiZWVuIGV4ZWN1dGVkLlxuICAgKi9cbiAgZXhlY3V0ZUZpbHRlcnM7XG4gIGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGZpbmdlcnByaW50IFRoZSBmaW5nZXJwcmludCBvZiB0aGlzIHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbGF5LCBmaW5nZXJwcmludCwgdG9wU3ViTWFuYWdlcikge1xuICAgIHRoaXMucmVsYXkgPSByZWxheTtcbiAgICB0aGlzLnRvcFN1Yk1hbmFnZXIgPSB0b3BTdWJNYW5hZ2VyO1xuICAgIHRoaXMuZGVidWcgPSByZWxheS5kZWJ1Zy5leHRlbmQoYHN1Ylske3RoaXMuaWR9XWApO1xuICAgIHRoaXMuZmluZ2VycHJpbnQgPSBmaW5nZXJwcmludCB8fCBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyk7XG4gIH1cbiAgX3N1YklkO1xuICBnZXQgc3ViSWQoKSB7XG4gICAgaWYgKHRoaXMuX3N1YklkKSByZXR1cm4gdGhpcy5fc3ViSWQ7XG4gICAgdGhpcy5fc3ViSWQgPSB0aGlzLmZpbmdlcnByaW50LnNsaWNlKDAsIDE1KTtcbiAgICByZXR1cm4gdGhpcy5fc3ViSWQ7XG4gIH1cbiAgc3ViSWRQYXJ0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGFkZFN1YklkUGFydChwYXJ0KSB7XG4gICAgdGhpcy5zdWJJZFBhcnRzLmFkZChwYXJ0KTtcbiAgfVxuICBhZGRJdGVtKHN1YnNjcmlwdGlvbiwgZmlsdGVycykge1xuICAgIHRoaXMuZGVidWcoXCJBZGRpbmcgaXRlbVwiLCB7XG4gICAgICBmaWx0ZXJzLFxuICAgICAgaW50ZXJuYWxJZDogc3Vic2NyaXB0aW9uLmludGVybmFsSWQsXG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgZmluZ2VycHJpbnQ6IHRoaXMuZmluZ2VycHJpbnQsXG4gICAgICBpZDogdGhpcy5zdWJJZCxcbiAgICAgIGl0ZW1zOiB0aGlzLml0ZW1zLFxuICAgICAgaXRlbXNTaXplOiB0aGlzLml0ZW1zLnNpemVcbiAgICB9KTtcbiAgICBpZiAodGhpcy5pdGVtcy5oYXMoc3Vic2NyaXB0aW9uLmludGVybmFsSWQpKSByZXR1cm47XG4gICAgc3Vic2NyaXB0aW9uLm9uKFwiY2xvc2VcIiwgdGhpcy5yZW1vdmVJdGVtLmJpbmQodGhpcywgc3Vic2NyaXB0aW9uKSk7XG4gICAgdGhpcy5pdGVtcy5zZXQoc3Vic2NyaXB0aW9uLmludGVybmFsSWQsIHsgc3Vic2NyaXB0aW9uLCBmaWx0ZXJzIH0pO1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gMyAvKiBSVU5OSU5HICovKSB7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uLnN1YklkICYmICghdGhpcy5fc3ViSWQgfHwgdGhpcy5fc3ViSWQubGVuZ3RoIDwgNDgpKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMCAvKiBJTklUSUFMICovIHx8IHRoaXMuc3RhdHVzID09PSAxIC8qIFBFTkRJTkcgKi8pIHtcbiAgICAgICAgICB0aGlzLmFkZFN1YklkUGFydChzdWJzY3JpcHRpb24uc3ViSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5zdGF0dXMpIHtcbiAgICAgIGNhc2UgMCAvKiBJTklUSUFMICovOlxuICAgICAgICB0aGlzLmV2YWx1YXRlRXhlY3V0aW9uUGxhbihzdWJzY3JpcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMyAvKiBSVU5OSU5HICovOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMSAvKiBQRU5ESU5HICovOlxuICAgICAgICB0aGlzLmV2YWx1YXRlRXhlY3V0aW9uUGxhbihzdWJzY3JpcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNCAvKiBDTE9TRUQgKi86XG4gICAgICAgIHRoaXMuZGVidWcoXCJTdWJzY3JpcHRpb24gaXMgY2xvc2VkLCBjYW5ub3QgYWRkIG5ldyBpdGVtcyAlbyAoJW8pXCIsIHN1YnNjcmlwdGlvbiwgZmlsdGVycyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgbmV3IGl0ZW1zIHRvIGEgY2xvc2VkIHN1YnNjcmlwdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEEgc3Vic2NyaXB0aW9uIGhhcyBiZWVuIGNsb3NlZCwgcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3Qgb2YgaXRlbXMuXG4gICAqIEBwYXJhbSBzdWJzY3JpcHRpb25cbiAgICovXG4gIHJlbW92ZUl0ZW0oc3Vic2NyaXB0aW9uKSB7XG4gICAgdGhpcy5pdGVtcy5kZWxldGUoc3Vic2NyaXB0aW9uLmludGVybmFsSWQpO1xuICAgIGlmICh0aGlzLml0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIGlmICghdGhpcy5lb3NlZCkgcmV0dXJuO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfVxuICB9XG4gIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gNCAvKiBDTE9TRUQgKi8pIHJldHVybjtcbiAgICBjb25zdCBwcmV2U3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gICAgdGhpcy5zdGF0dXMgPSA0IC8qIENMT1NFRCAqLztcbiAgICBpZiAocHJldlN0YXR1cyA9PT0gMyAvKiBSVU5OSU5HICovKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnJlbGF5LmNsb3NlKHRoaXMuc3ViSWQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiRXJyb3IgY2xvc2luZyBzdWJzY3JpcHRpb25cIiwgZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVidWcoXCJTdWJzY3JpcHRpb24gd2FudGVkIHRvIGNsb3NlIGJ1dCBpdCB3YXNuJ3QgcnVubmluZywgdGhpcyBpcyBwcm9iYWJseSBva1wiLCB7XG4gICAgICAgIHN1YklkOiB0aGlzLnN1YklkLFxuICAgICAgICBwcmV2U3RhdHVzLFxuICAgICAgICBzdWI6IHRoaXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5leGVjdXRpb25UaW1lcik7XG4gICAgdGhpcy5yZWxheS5vZmYoXCJyZWFkeVwiLCB0aGlzLmV4ZWN1dGVPblJlbGF5UmVhZHkpO1xuICAgIHRoaXMucmVsYXkub2ZmKFwiYXV0aGVkXCIsIHRoaXMucmVFeGVjdXRlQWZ0ZXJBdXRoKTtcbiAgICBpZiAodGhpcy5vbkNsb3NlKSB0aGlzLm9uQ2xvc2UodGhpcyk7XG4gIH1cbiAgZXZhbHVhdGVFeGVjdXRpb25QbGFuKHN1YnNjcmlwdGlvbikge1xuICAgIGlmICghc3Vic2NyaXB0aW9uLmlzR3JvdXBhYmxlKCkpIHtcbiAgICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgICAgdGhpcy5leGVjdXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdWJzY3JpcHRpb24uZmlsdGVycy5maW5kKChmaWx0ZXIpID0+ICEhZmlsdGVyLmxpbWl0KSkge1xuICAgICAgdGhpcy5leGVjdXRlRmlsdGVycyA9IHRoaXMuY29tcGlsZUZpbHRlcnMoKTtcbiAgICAgIGlmICh0aGlzLmV4ZWN1dGVGaWx0ZXJzLmxlbmd0aCA+PSAxMCkge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IDEgLyogUEVORElORyAqLztcbiAgICAgICAgdGhpcy5leGVjdXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVsYXkgPSBzdWJzY3JpcHRpb24uZ3JvdXBhYmxlRGVsYXk7XG4gICAgY29uc3QgZGVsYXlUeXBlID0gc3Vic2NyaXB0aW9uLmdyb3VwYWJsZURlbGF5VHlwZTtcbiAgICBpZiAoIWRlbGF5KSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ3JvdXAgYSBzdWJzY3JpcHRpb24gd2l0aG91dCBhIGRlbGF5XCIpO1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMCAvKiBJTklUSUFMICovKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBleGlzdGluZ0RlbGF5VHlwZSA9IHRoaXMuZGVsYXlUeXBlO1xuICAgICAgY29uc3QgdGltZVVudGlsRmlyZSA9IHRoaXMuZmlyZVRpbWUgLSBEYXRlLm5vdygpO1xuICAgICAgaWYgKGV4aXN0aW5nRGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIgJiYgZGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIpIHtcbiAgICAgICAgaWYgKHRpbWVVbnRpbEZpcmUgPCBkZWxheSkge1xuICAgICAgICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5leGVjdXRpb25UaW1lcik7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZShkZWxheSwgZGVsYXlUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleGlzdGluZ0RlbGF5VHlwZSA9PT0gXCJhdC1sZWFzdFwiICYmIGRlbGF5VHlwZSA9PT0gXCJhdC1tb3N0XCIpIHtcbiAgICAgICAgaWYgKHRpbWVVbnRpbEZpcmUgPiBkZWxheSkge1xuICAgICAgICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5leGVjdXRpb25UaW1lcik7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZShkZWxheSwgZGVsYXlUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleGlzdGluZ0RlbGF5VHlwZSA9PT0gXCJhdC1tb3N0XCIgJiYgZGVsYXlUeXBlID09PSBcImF0LW1vc3RcIikge1xuICAgICAgICBpZiAodGltZVVudGlsRmlyZSA+IGRlbGF5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nRGVsYXlUeXBlID09PSBcImF0LW1vc3RcIiAmJiBkZWxheVR5cGUgPT09IFwiYXQtbGVhc3RcIikge1xuICAgICAgICBpZiAodGltZVVudGlsRmlyZSA+IGRlbGF5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGVsYXkgdHlwZSBjb21iaW5hdGlvbiAke2V4aXN0aW5nRGVsYXlUeXBlfSAke2RlbGF5VHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSkge1xuICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmZpcmVUaW1lID0gY3VycmVudFRpbWUgKyBkZWxheTtcbiAgICB0aGlzLmRlbGF5VHlwZSA9IGRlbGF5VHlwZTtcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQodGhpcy5leGVjdXRlLmJpbmQodGhpcyksIGRlbGF5KTtcbiAgICBpZiAoZGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIpIHtcbiAgICAgIHRoaXMuZXhlY3V0aW9uVGltZXIgPSB0aW1lcjtcbiAgICB9XG4gIH1cbiAgZXhlY3V0ZU9uUmVsYXlSZWFkeSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IDIgLyogV0FJVElORyAqLykgcmV0dXJuO1xuICAgIGlmICh0aGlzLml0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuZGVidWcoXCJObyBpdGVtcyB0byBleGVjdXRlOyB0aGlzIHJlbGF5IHdhcyBwcm9iYWJseSB0b28gc2xvdyB0byByZXNwb25kIGFuZCB0aGUgY2FsbGVyIGdhdmUgdXBcIiwge1xuICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICBmaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCxcbiAgICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICAgIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgc3ViSWQ6IHRoaXMuc3ViSWRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGVidWcoXCJFeGVjdXRpbmcgb24gcmVsYXkgcmVhZHlcIiwge1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LFxuICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICBpdGVtc1NpemU6IHRoaXMuaXRlbXMuc2l6ZVxuICAgIH0pO1xuICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgIHRoaXMuZXhlY3V0ZSgpO1xuICB9O1xuICBmaW5hbGl6ZVN1YklkKCkge1xuICAgIGlmICh0aGlzLnN1YklkUGFydHMuc2l6ZSA+IDApIHtcbiAgICAgIHRoaXMuX3N1YklkID0gQXJyYXkuZnJvbSh0aGlzLnN1YklkUGFydHMpLmpvaW4oXCItXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdWJJZCA9IHRoaXMuZmluZ2VycHJpbnQuc2xpY2UoMCwgMTUpO1xuICAgIH1cbiAgICB0aGlzLl9zdWJJZCArPSBgLSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDcpfWA7XG4gIH1cbiAgLy8gd2UgZG8gaXQgdGhpcyB3YXkgc28gdGhhdCB3ZSBjYW4gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuICByZUV4ZWN1dGVBZnRlckF1dGggPSAoKCkgPT4ge1xuICAgIGNvbnN0IG9sZFN1YklkID0gdGhpcy5zdWJJZDtcbiAgICB0aGlzLmRlYnVnKFwiUmUtZXhlY3V0aW5nIGFmdGVyIGF1dGhcIiwgdGhpcy5pdGVtcy5zaXplKTtcbiAgICBpZiAodGhpcy5lb3NlZCkge1xuICAgICAgdGhpcy5yZWxheS5jbG9zZSh0aGlzLnN1YklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWJ1ZyhcIldlIGFyZSBhYmFuZG9uaW5nIGFuIG9wZW5lZCBzdWJzY3JpcHRpb24sIG9uY2UgaXQgRU9TRSdzLCB0aGUgaGFuZGxlciB3aWxsIGNsb3NlIGl0XCIsIHtcbiAgICAgICAgb2xkU3ViSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9zdWJJZCA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXR1cyA9IDEgLyogUEVORElORyAqLztcbiAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICB0aGlzLmRlYnVnKFwiUmUtZXhlY3V0ZWQgYWZ0ZXIgYXV0aCAlcyBcXHV7MUY0NDl9ICVzXCIsIG9sZFN1YklkLCB0aGlzLnN1YklkKTtcbiAgfSkuYmluZCh0aGlzKTtcbiAgZXhlY3V0ZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IDEgLyogUEVORElORyAqLykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVsYXkuY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IDIgLyogV0FJVElORyAqLztcbiAgICAgIHRoaXMuZGVidWcoXCJXYWl0aW5nIGZvciByZWxheSB0byBiZSByZWFkeVwiLCB7XG4gICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgIGlkOiB0aGlzLnN1YklkLFxuICAgICAgICBmaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCxcbiAgICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICAgIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplXG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVsYXkub25jZShcInJlYWR5XCIsIHRoaXMuZXhlY3V0ZU9uUmVsYXlSZWFkeSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbGF5LnN0YXR1cyA8IDggLyogQVVUSEVOVElDQVRFRCAqLykge1xuICAgICAgdGhpcy5yZWxheS5vbmNlKFwiYXV0aGVkXCIsIHRoaXMucmVFeGVjdXRlQWZ0ZXJBdXRoKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0dXMgPSAzIC8qIFJVTk5JTkcgKi87XG4gICAgdGhpcy5maW5hbGl6ZVN1YklkKCk7XG4gICAgdGhpcy5leGVjdXRlRmlsdGVycyA9IHRoaXMuY29tcGlsZUZpbHRlcnMoKTtcbiAgICB0aGlzLnJlbGF5LnJlcSh0aGlzKTtcbiAgfVxuICBvbnN0YXJ0KCkge1xuICB9XG4gIG9uZXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLnRvcFN1Yk1hbmFnZXIuZGlzcGF0Y2hFdmVudChldmVudCwgdGhpcy5yZWxheSk7XG4gIH1cbiAgb25lb3NlKHN1YklkKSB7XG4gICAgdGhpcy5lb3NlZCA9IHRydWU7XG4gICAgaWYgKHN1YklkICE9PSB0aGlzLnN1YklkKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiUmVjZWl2ZWQgRU9TRSBmb3IgYW4gYWJhbmRvbmVkIHN1YnNjcmlwdGlvblwiLCBzdWJJZCwgdGhpcy5zdWJJZCk7XG4gICAgICB0aGlzLnJlbGF5LmNsb3NlKHN1YklkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXRlbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHsgc3Vic2NyaXB0aW9uIH0gb2YgdGhpcy5pdGVtcy52YWx1ZXMoKSkge1xuICAgICAgc3Vic2NyaXB0aW9uLmVvc2VSZWNlaXZlZCh0aGlzLnJlbGF5KTtcbiAgICAgIGlmIChzdWJzY3JpcHRpb24uY2xvc2VPbkVvc2UpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIlJlbW92aW5nIGl0ZW0gYmVjYXVzZSBvZiBFT1NFXCIsIHtcbiAgICAgICAgICBmaWx0ZXJzOiBzdWJzY3JpcHRpb24uZmlsdGVycyxcbiAgICAgICAgICBpbnRlcm5hbElkOiBzdWJzY3JpcHRpb24uaW50ZXJuYWxJZCxcbiAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LFxuICAgICAgICAgIGl0ZW1zOiB0aGlzLml0ZW1zLFxuICAgICAgICAgIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oc3Vic2NyaXB0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25jbG9zZShfcmVhc29uKSB7XG4gICAgdGhpcy5zdGF0dXMgPSA0IC8qIENMT1NFRCAqLztcbiAgfVxuICBvbmNsb3NlZChyZWFzb24pIHtcbiAgICBpZiAoIXJlYXNvbikgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgeyBzdWJzY3JpcHRpb24gfSBvZiB0aGlzLml0ZW1zLnZhbHVlcygpKSB7XG4gICAgICBzdWJzY3JpcHRpb24uY2xvc2VkUmVjZWl2ZWQodGhpcy5yZWxheSwgcmVhc29uKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdyYWJzIHRoZSBmaWx0ZXJzIGZyb20gYWxsIHRoZSBzdWJzY3JpcHRpb25zXG4gICAqIGFuZCBtZXJnZXMgdGhlbSBpbnRvIGEgc2luZ2xlIGZpbHRlci5cbiAgICovXG4gIGNvbXBpbGVGaWx0ZXJzKCkge1xuICAgIGNvbnN0IG1lcmdlZEZpbHRlcnMgPSBbXTtcbiAgICBjb25zdCBmaWx0ZXJzID0gQXJyYXkuZnJvbSh0aGlzLml0ZW1zLnZhbHVlcygpKS5tYXAoKGl0ZW0pID0+IGl0ZW0uZmlsdGVycyk7XG4gICAgaWYgKCFmaWx0ZXJzWzBdKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiXFx1ezFGNDQwfSBObyBmaWx0ZXJzIHRvIG1lcmdlXCIsIHRoaXMuaXRlbXMpO1xuICAgICAgY29uc29sZS5lcnJvcihcIkJVRzogTm8gZmlsdGVycyB0byBtZXJnZSFcIiwgdGhpcy5pdGVtcyk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlckNvdW50ID0gZmlsdGVyc1swXS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhbGxGaWx0ZXJzQXRJbmRleCA9IGZpbHRlcnMubWFwKChmaWx0ZXIpID0+IGZpbHRlcltpXSk7XG4gICAgICBtZXJnZWRGaWx0ZXJzLnB1c2goLi4ubWVyZ2VGaWx0ZXJzKGFsbEZpbHRlcnNBdEluZGV4KSk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRGaWx0ZXJzO1xuICB9XG59O1xuXG4vLyBzcmMvcmVsYXkvc3ViLW1hbmFnZXIudHNcbnZhciBOREtSZWxheVN1YnNjcmlwdGlvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIHJlbGF5O1xuICBzdWJzY3JpcHRpb25zO1xuICBnZW5lcmFsU3ViTWFuYWdlcjtcbiAgLyoqXG4gICAqIEBwYXJhbSByZWxheSAtIFRoZSByZWxheSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIGdlbmVyYWxTdWJNYW5hZ2VyIC0gVGhlIHN1YnNjcmlwdGlvbiBtYW5hZ2VyIGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVsYXksIGdlbmVyYWxTdWJNYW5hZ2VyKSB7XG4gICAgdGhpcy5yZWxheSA9IHJlbGF5O1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5nZW5lcmFsU3ViTWFuYWdlciA9IGdlbmVyYWxTdWJNYW5hZ2VyO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgc3Vic2NyaXB0aW9uIHRvIHRoZSBtYW5hZ2VyLlxuICAgKi9cbiAgYWRkU3Vic2NyaXB0aW9uKHN1YiwgZmlsdGVycykge1xuICAgIGxldCByZWxheVN1YjtcbiAgICBpZiAoIXN1Yi5pc0dyb3VwYWJsZSgpKSB7XG4gICAgICByZWxheVN1YiA9IHRoaXMuY3JlYXRlU3Vic2NyaXB0aW9uKHN1YiwgZmlsdGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpbHRlckZwID0gZmlsdGVyRmluZ2VycHJpbnQoZmlsdGVycywgc3ViLmNsb3NlT25Fb3NlKTtcbiAgICAgIGlmIChmaWx0ZXJGcCkge1xuICAgICAgICBjb25zdCBleGlzdGluZ1N1YnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KGZpbHRlckZwKTtcbiAgICAgICAgcmVsYXlTdWIgPSAoZXhpc3RpbmdTdWJzIHx8IFtdKS5maW5kKChzdWIyKSA9PiBzdWIyLnN0YXR1cyA8IDMgLyogUlVOTklORyAqLyk7XG4gICAgICB9XG4gICAgICByZWxheVN1YiA/Pz0gdGhpcy5jcmVhdGVTdWJzY3JpcHRpb24oc3ViLCBmaWx0ZXJzLCBmaWx0ZXJGcCk7XG4gICAgfVxuICAgIHJlbGF5U3ViLmFkZEl0ZW0oc3ViLCBmaWx0ZXJzKTtcbiAgfVxuICBjcmVhdGVTdWJzY3JpcHRpb24oX3N1YiwgX2ZpbHRlcnMsIGZpbmdlcnByaW50KSB7XG4gICAgY29uc3QgcmVsYXlTdWIgPSBuZXcgTkRLUmVsYXlTdWJzY3JpcHRpb24odGhpcy5yZWxheSwgZmluZ2VycHJpbnQgfHwgbnVsbCwgdGhpcy5nZW5lcmFsU3ViTWFuYWdlcik7XG4gICAgcmVsYXlTdWIub25DbG9zZSA9IHRoaXMub25SZWxheVN1YnNjcmlwdGlvbkNsb3NlLmJpbmQodGhpcyk7XG4gICAgY29uc3QgY3VycmVudFZhbCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQocmVsYXlTdWIuZmluZ2VycHJpbnQpID8/IFtdO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQocmVsYXlTdWIuZmluZ2VycHJpbnQsIFsuLi5jdXJyZW50VmFsLCByZWxheVN1Yl0pO1xuICAgIHJldHVybiByZWxheVN1YjtcbiAgfVxuICBvblJlbGF5U3Vic2NyaXB0aW9uQ2xvc2Uoc3ViKSB7XG4gICAgbGV0IGN1cnJlbnRWYWwgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KHN1Yi5maW5nZXJwcmludCkgPz8gW107XG4gICAgaWYgKCFjdXJyZW50VmFsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJVbmV4cGVjdGVkbHkgZGlkIG5vdCBmaW5kIGEgc3Vic2NyaXB0aW9uIHdpdGggZmluZ2VycHJpbnRcIiwgc3ViLmZpbmdlcnByaW50KTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRWYWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1Yi5maW5nZXJwcmludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRWYWwgPSBjdXJyZW50VmFsLmZpbHRlcigocykgPT4gcy5pZCAhPT0gc3ViLmlkKTtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQoc3ViLmZpbmdlcnByaW50LCBjdXJyZW50VmFsKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9pbmRleC50c1xudmFyIE5ES1JlbGF5U3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoTkRLUmVsYXlTdGF0dXMyKSA9PiB7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJESVNDT05ORUNUSU5HXCJdID0gMF0gPSBcIkRJU0NPTk5FQ1RJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkRJU0NPTk5FQ1RFRFwiXSA9IDFdID0gXCJESVNDT05ORUNURURcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIlJFQ09OTkVDVElOR1wiXSA9IDJdID0gXCJSRUNPTk5FQ1RJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkZMQVBQSU5HXCJdID0gM10gPSBcIkZMQVBQSU5HXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJDT05ORUNUSU5HXCJdID0gNF0gPSBcIkNPTk5FQ1RJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkNPTk5FQ1RFRFwiXSA9IDVdID0gXCJDT05ORUNURURcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkFVVEhfUkVRVUVTVEVEXCJdID0gNl0gPSBcIkFVVEhfUkVRVUVTVEVEXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJBVVRIRU5USUNBVElOR1wiXSA9IDddID0gXCJBVVRIRU5USUNBVElOR1wiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiQVVUSEVOVElDQVRFRFwiXSA9IDhdID0gXCJBVVRIRU5USUNBVEVEXCI7XG4gIHJldHVybiBOREtSZWxheVN0YXR1czI7XG59KShOREtSZWxheVN0YXR1cyB8fCB7fSk7XG52YXIgTkRLUmVsYXkgPSBjbGFzcyBfTkRLUmVsYXkgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICB1cmw7XG4gIHNjb3JlcztcbiAgY29ubmVjdGl2aXR5O1xuICBzdWJzO1xuICBwdWJsaXNoZXI7XG4gIGF1dGhQb2xpY3k7XG4gIC8qKlxuICAgKiBUaGUgbG93ZXN0IHZhbGlkYXRpb24gcmF0aW8gdGhpcyByZWxheSBjYW4gcmVhY2guXG4gICAqL1xuICBsb3dlc3RWYWxpZGF0aW9uUmF0aW87XG4gIC8qKlxuICAgKiBDdXJyZW50IHZhbGlkYXRpb24gcmF0aW8gdGhpcyByZWxheSBpcyB0YXJnZXRpbmcuXG4gICAqL1xuICB0YXJnZXRWYWxpZGF0aW9uUmF0aW87XG4gIHZhbGlkYXRpb25SYXRpb0ZuO1xuICAvKipcbiAgICogVGhpcyB0cmFja3MgZXZlbnRzIHRoYXQgaGF2ZSBiZWVuIHNlZW4gYnkgdGhpcyByZWxheVxuICAgKiB3aXRoIGEgdmFsaWQgc2lnbmF0dXJlLlxuICAgKi9cbiAgdmFsaWRhdGVkRXZlbnRDb3VudCA9IDA7XG4gIC8qKlxuICAgKiBUaGlzIHRyYWNrcyBldmVudHMgdGhhdCBoYXZlIGJlZW4gc2VlbiBieSB0aGlzIHJlbGF5XG4gICAqIGJ1dCBoYXZlIG5vdCBiZWVuIHZhbGlkYXRlZC5cbiAgICovXG4gIG5vblZhbGlkYXRlZEV2ZW50Q291bnQgPSAwO1xuICAvKipcbiAgICogV2hldGhlciB0aGlzIHJlbGF5IGlzIHRydXN0ZWQuXG4gICAqXG4gICAqIFRydXN0ZWQgcmVsYXkncyBldmVudHMgZG8gbm90IGdldCB0aGVpciBzaWduYXR1cmUgdmVyaWZpZWQuXG4gICAqL1xuICB0cnVzdGVkID0gZmFsc2U7XG4gIGNvbXBsYWluaW5nID0gZmFsc2U7XG4gIGRlYnVnO1xuICBzdGF0aWMgZGVmYXVsdFZhbGlkYXRpb25SYXRpb1VwZGF0ZUZuID0gKHJlbGF5LCB2YWxpZGF0ZWRDb3VudCwgX25vblZhbGlkYXRlZENvdW50KSA9PiB7XG4gICAgaWYgKHJlbGF5Lmxvd2VzdFZhbGlkYXRpb25SYXRpbyA9PT0gdm9pZCAwIHx8IHJlbGF5LnRhcmdldFZhbGlkYXRpb25SYXRpbyA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICBsZXQgbmV3UmF0aW8gPSByZWxheS52YWxpZGF0aW9uUmF0aW87XG4gICAgaWYgKHJlbGF5LnZhbGlkYXRpb25SYXRpbyA+IHJlbGF5LnRhcmdldFZhbGlkYXRpb25SYXRpbykge1xuICAgICAgY29uc3QgZmFjdG9yID0gdmFsaWRhdGVkQ291bnQgLyAxMDA7XG4gICAgICBuZXdSYXRpbyA9IE1hdGgubWF4KHJlbGF5Lmxvd2VzdFZhbGlkYXRpb25SYXRpbywgcmVsYXkudmFsaWRhdGlvblJhdGlvIC0gZmFjdG9yKTtcbiAgICB9XG4gICAgaWYgKG5ld1JhdGlvIDwgcmVsYXkudmFsaWRhdGlvblJhdGlvKSB7XG4gICAgICByZXR1cm4gbmV3UmF0aW87XG4gICAgfVxuICAgIHJldHVybiByZWxheS52YWxpZGF0aW9uUmF0aW87XG4gIH07XG4gIGNvbnN0cnVjdG9yKHVybCwgYXV0aFBvbGljeSwgbmRrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVybCA9IG5vcm1hbGl6ZVJlbGF5VXJsKHVybCk7XG4gICAgdGhpcy5zY29yZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZyhgbmRrOnJlbGF5OiR7dXJsfWApO1xuICAgIHRoaXMuY29ubmVjdGl2aXR5ID0gbmV3IE5ES1JlbGF5Q29ubmVjdGl2aXR5KHRoaXMsIG5kayk7XG4gICAgdGhpcy5jb25uZWN0aXZpdHkubmV0RGVidWcgPSBuZGs/Lm5ldERlYnVnO1xuICAgIHRoaXMucmVxID0gdGhpcy5jb25uZWN0aXZpdHkucmVxLmJpbmQodGhpcy5jb25uZWN0aXZpdHkpO1xuICAgIHRoaXMuY2xvc2UgPSB0aGlzLmNvbm5lY3Rpdml0eS5jbG9zZS5iaW5kKHRoaXMuY29ubmVjdGl2aXR5KTtcbiAgICB0aGlzLnN1YnMgPSBuZXcgTkRLUmVsYXlTdWJzY3JpcHRpb25NYW5hZ2VyKHRoaXMsIG5kay5zdWJNYW5hZ2VyKTtcbiAgICB0aGlzLnB1Ymxpc2hlciA9IG5ldyBOREtSZWxheVB1Ymxpc2hlcih0aGlzKTtcbiAgICB0aGlzLmF1dGhQb2xpY3kgPSBhdXRoUG9saWN5O1xuICAgIHRoaXMudGFyZ2V0VmFsaWRhdGlvblJhdGlvID0gbmRrPy5pbml0aWFsVmFsaWRhdGlvblJhdGlvO1xuICAgIHRoaXMubG93ZXN0VmFsaWRhdGlvblJhdGlvID0gbmRrPy5sb3dlc3RWYWxpZGF0aW9uUmF0aW87XG4gICAgdGhpcy52YWxpZGF0aW9uUmF0aW9GbiA9IChuZGs/LnZhbGlkYXRpb25SYXRpb0ZuID8/IF9OREtSZWxheS5kZWZhdWx0VmFsaWRhdGlvblJhdGlvVXBkYXRlRm4pLmJpbmQodGhpcyk7XG4gICAgdGhpcy51cGRhdGVWYWxpZGF0aW9uUmF0aW8oKTtcbiAgICBpZiAoIW5kaykge1xuICAgICAgY29uc29sZS50cmFjZShcInJlbGF5IGNyZWF0ZWQgd2l0aG91dCBuZGtcIik7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVZhbGlkYXRpb25SYXRpbygpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlVmFsaWRhdGlvblJhdGlvKCk7XG4gICAgfSwgM2U0KTtcbiAgfVxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eS5zdGF0dXM7XG4gIH1cbiAgZ2V0IGNvbm5lY3Rpb25TdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aXZpdHkuY29ubmVjdGlvblN0YXRzO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byB0aGUgcmVsYXkuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KHRpbWVvdXRNcywgcmVjb25uZWN0ID0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eS5jb25uZWN0KHRpbWVvdXRNcywgcmVjb25uZWN0KTtcbiAgfVxuICAvKipcbiAgICogRGlzY29ubmVjdHMgZnJvbSB0aGUgcmVsYXkuXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMSAvKiBESVNDT05ORUNURUQgKi8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aXZpdHkuZGlzY29ubmVjdCgpO1xuICB9XG4gIC8qKlxuICAgKiBRdWV1ZXMgb3IgZXhlY3V0ZXMgdGhlIHN1YnNjcmlwdGlvbiBvZiBhIHNwZWNpZmljIHNldCBvZiBmaWx0ZXJzXG4gICAqIHdpdGhpbiB0aGlzIHJlbGF5LlxuICAgKlxuICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9uIE5ES1N1YnNjcmlwdGlvbiB0aGlzIGZpbHRlcnMgYmVsb25nIHRvLlxuICAgKiBAcGFyYW0gZmlsdGVycyBGaWx0ZXJzIHRvIGV4ZWN1dGVcbiAgICovXG4gIHN1YnNjcmliZShzdWJzY3JpcHRpb24sIGZpbHRlcnMpIHtcbiAgICB0aGlzLnN1YnMuYWRkU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgZmlsdGVycyk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2hlcyBhbiBldmVudCB0byB0aGUgcmVsYXkgd2l0aCBhbiBvcHRpb25hbCB0aW1lb3V0LlxuICAgKlxuICAgKiBJZiB0aGUgcmVsYXkgaXMgbm90IGNvbm5lY3RlZCwgdGhlIGV2ZW50IHdpbGwgYmUgcHVibGlzaGVkIHdoZW4gdGhlIHJlbGF5IGNvbm5lY3RzLFxuICAgKiB1bmxlc3MgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCBiZWZvcmUgdGhlIHJlbGF5IGNvbm5lY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHB1Ymxpc2hcbiAgICogQHBhcmFtIHRpbWVvdXRNcyBUaGUgdGltZW91dCBmb3IgdGhlIHB1Ymxpc2ggb3BlcmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBldmVudCBoYXMgYmVlbiBwdWJsaXNoZWQgb3IgcmVqZWN0cyBpZiB0aGUgb3BlcmF0aW9uIHRpbWVzIG91dFxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChldmVudCwgdGltZW91dE1zID0gMjUwMCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5wdWJsaXNoKGV2ZW50LCB0aW1lb3V0TXMpO1xuICB9XG4gIHJlZmVyZW5jZVRhZ3MoKSB7XG4gICAgcmV0dXJuIFtbXCJyXCIsIHRoaXMudXJsXV07XG4gIH1cbiAgYWRkVmFsaWRhdGVkRXZlbnQoKSB7XG4gICAgdGhpcy52YWxpZGF0ZWRFdmVudENvdW50Kys7XG4gIH1cbiAgYWRkTm9uVmFsaWRhdGVkRXZlbnQoKSB7XG4gICAgdGhpcy5ub25WYWxpZGF0ZWRFdmVudENvdW50Kys7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZhbGlkYXRpb24gcmF0aW8gdGhpcyByZWxheSBoYXMgYWNoaWV2ZWQuXG4gICAqL1xuICBnZXQgdmFsaWRhdGlvblJhdGlvKCkge1xuICAgIGlmICh0aGlzLm5vblZhbGlkYXRlZEV2ZW50Q291bnQgPT09IDApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZWRFdmVudENvdW50IC8gKHRoaXMudmFsaWRhdGVkRXZlbnRDb3VudCArIHRoaXMubm9uVmFsaWRhdGVkRXZlbnRDb3VudCk7XG4gIH1cbiAgc2hvdWxkVmFsaWRhdGVFdmVudCgpIHtcbiAgICBpZiAodGhpcy50cnVzdGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnRhcmdldFZhbGlkYXRpb25SYXRpbyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGlvblJhdGlvIDwgdGhpcy50YXJnZXRWYWxpZGF0aW9uUmF0aW87XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aXZpdHkuY29ubmVjdGVkO1xuICB9XG4gIHJlcTtcbiAgY2xvc2U7XG59O1xuXG4vLyBzcmMvcmVsYXkvc2V0cy9pbmRleC50c1xudmFyIE5ES1B1Ymxpc2hFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBlcnJvcnM7XG4gIHB1Ymxpc2hlZFRvUmVsYXlzO1xuICAvKipcbiAgICogSW50ZW5kZWQgcmVsYXkgc2V0IHdoZXJlIHRoZSBwdWJsaXNoaW5nIHdhcyBpbnRlbmRlZCB0byBoYXBwZW4uXG4gICAqL1xuICBpbnRlbmRlZFJlbGF5U2V0O1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvcnMsIHB1Ymxpc2hlZFRvUmVsYXlzLCBpbnRlbmRlZFJlbGF5U2V0KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5wdWJsaXNoZWRUb1JlbGF5cyA9IHB1Ymxpc2hlZFRvUmVsYXlzO1xuICAgIHRoaXMuaW50ZW5kZWRSZWxheVNldCA9IGludGVuZGVkUmVsYXlTZXQ7XG4gIH1cbiAgZ2V0IHJlbGF5RXJyb3JzKCkge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgW3JlbGF5LCBlcnJdIG9mIHRoaXMuZXJyb3JzKSB7XG4gICAgICBlcnJvcnMucHVzaChgJHtyZWxheS51cmx9OiAke2Vycn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycy5qb2luKFwiXFxuXCIpO1xuICB9XG59O1xudmFyIE5ES1JlbGF5U2V0ID0gY2xhc3MgX05ES1JlbGF5U2V0IHtcbiAgcmVsYXlzO1xuICBkZWJ1ZztcbiAgbmRrO1xuICBwb29sO1xuICBjb25zdHJ1Y3RvcihyZWxheXMsIG5kaywgcG9vbCkge1xuICAgIHRoaXMucmVsYXlzID0gcmVsYXlzO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMucG9vbCA9IHBvb2wgPz8gbmRrLnBvb2w7XG4gICAgdGhpcy5kZWJ1ZyA9IG5kay5kZWJ1Zy5leHRlbmQoXCJyZWxheXNldFwiKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJlbGF5IHRvIHRoaXMgc2V0LlxuICAgKi9cbiAgYWRkUmVsYXkocmVsYXkpIHtcbiAgICB0aGlzLnJlbGF5cy5hZGQocmVsYXkpO1xuICB9XG4gIGdldCByZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWxheXMpLm1hcCgocikgPT4gci51cmwpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVsYXkgc2V0IGZyb20gYSBsaXN0IG9mIHJlbGF5IFVSTHMuXG4gICAqXG4gICAqIElmIG5vIGNvbm5lY3Rpb24gdG8gdGhlIHJlbGF5IGlzIGZvdW5kIGluIHRoZSBwb29sIGl0IHdpbGwgdGVtcG9yYXJpbHlcbiAgICogY29ubmVjdCB0byBpdC5cbiAgICpcbiAgICogQHBhcmFtIHJlbGF5VXJscyAtIGxpc3Qgb2YgcmVsYXkgVVJMcyB0byBpbmNsdWRlIGluIHRoaXMgc2V0XG4gICAqIEBwYXJhbSBuZGtcbiAgICogQHBhcmFtIGNvbm5lY3QgLSB3aGV0aGVyIHRvIGNvbm5lY3QgdG8gdGhlIHJlbGF5IGltbWVkaWF0ZWx5IGlmIGl0IHdhcyBhbHJlYWR5IGluIHRoZSBwb29sIGJ1dCBub3QgY29ubmVjdGVkXG4gICAqIEByZXR1cm5zIE5ES1JlbGF5U2V0XG4gICAqL1xuICBzdGF0aWMgZnJvbVJlbGF5VXJscyhyZWxheVVybHMsIG5kaywgY29ubmVjdCA9IHRydWUsIHBvb2wpIHtcbiAgICBwb29sID0gcG9vbCA/PyBuZGsucG9vbDtcbiAgICBpZiAoIXBvb2wpIHRocm93IG5ldyBFcnJvcihcIk5vIHBvb2wgcHJvdmlkZWRcIik7XG4gICAgY29uc3QgcmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiByZWxheVVybHMpIHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gcG9vbC5yZWxheXMuZ2V0KG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkpO1xuICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgIGlmIChyZWxheS5zdGF0dXMgPCA1IC8qIENPTk5FQ1RFRCAqLyAmJiBjb25uZWN0KSB7XG4gICAgICAgICAgcmVsYXkuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlbGF5cy5hZGQocmVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGVtcG9yYXJ5UmVsYXkgPSBuZXcgTkRLUmVsYXkobm9ybWFsaXplUmVsYXlVcmwodXJsKSwgbmRrPy5yZWxheUF1dGhEZWZhdWx0UG9saWN5LCBuZGspO1xuICAgICAgICBwb29sLnVzZVRlbXBvcmFyeVJlbGF5KHRlbXBvcmFyeVJlbGF5LCB2b2lkIDAsIGByZXF1ZXN0ZWQgZnJvbSBmcm9tUmVsYXlVcmxzICR7cmVsYXlVcmxzfWApO1xuICAgICAgICByZWxheXMuYWRkKHRlbXBvcmFyeVJlbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfTkRLUmVsYXlTZXQobmV3IFNldChyZWxheXMpLCBuZGssIHBvb2wpO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoIGFuIGV2ZW50IHRvIGFsbCByZWxheXMgaW4gdGhpcyByZWxheSBzZXQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGltcGxlbWVudHMgYSByb2J1c3QgbWVjaGFuaXNtIGZvciBwdWJsaXNoaW5nIGV2ZW50cyB0byBtdWx0aXBsZSByZWxheXMgd2l0aFxuICAgKiBidWlsdC1pbiBoYW5kbGluZyBmb3IgcmFjZSBjb25kaXRpb25zLCB0aW1lb3V0cywgYW5kIHBhcnRpYWwgZmFpbHVyZXMuIFRoZSBpbXBsZW1lbnRhdGlvblxuICAgKiB1c2VzIGEgZHVhbC10cmFja2luZyBtZWNoYW5pc20gdG8gZW5zdXJlIGFjY3VyYXRlIHJlcG9ydGluZyBvZiB3aGljaCByZWxheXMgc3VjY2Vzc2Z1bGx5XG4gICAqIHJlY2VpdmVkIGFuIGV2ZW50LlxuICAgKlxuICAgKiBLZXkgYXNwZWN0cyBvZiB0aGlzIGltcGxlbWVudGF0aW9uOlxuICAgKlxuICAgKiAxLiBEVUFMLVRSQUNLSU5HIE1FQ0hBTklTTTpcbiAgICogICAgLSBQcm9taXNlLWJhc2VkIHRyYWNraW5nOiBSZWNvcmRzIHN1Y2Nlc3Nlcy9mYWlsdXJlcyBmcm9tIHRoZSBwcm9taXNlcyByZXR1cm5lZCBieSByZWxheS5wdWJsaXNoKClcbiAgICogICAgLSBFdmVudC1iYXNlZCB0cmFja2luZzogTGlzdGVucyBmb3IgJ3JlbGF5OnB1Ymxpc2hlZCcgZXZlbnRzIHRoYXQgaW5kaWNhdGUgc3VjY2Vzc2Z1bCBwdWJsaXNoaW5nXG4gICAqICAgIFRoaXMgYXBwcm9hY2ggZW5zdXJlcyB3ZSBkb24ndCBtaXNzIHN1Y2Nlc3NmdWwgcHVibGlzaGVzIGV2ZW4gaWYgdGhlcmUgYXJlIHN1YnNlcXVlbnQgZXJyb3JzIGluXG4gICAqICAgIHRoZSBwcm9taXNlIGNoYWluLlxuICAgKlxuICAgKiAyLiBSQUNFIENPTkRJVElPTiBIQU5ETElORzpcbiAgICogICAgLSBJZiBhIHJlbGF5IGVtaXRzIGEgc3VjY2VzcyBldmVudCBidXQgbGF0ZXIgZmFpbHMgaW4gdGhlIHByb21pc2UgY2hhaW4sIHdlIHN0aWxsIGNvdW50IGl0IGFzIGEgc3VjY2Vzc1xuICAgKiAgICAtIElmIGEgcmVsYXkgdGltZXMgb3V0IGFmdGVyIHN1Y2Nlc3NmdWxseSBwdWJsaXNoaW5nLCB3ZSBzdGlsbCBjb3VudCBpdCBhcyBhIHN1Y2Nlc3NcbiAgICogICAgLSBBbGwgcmVsYXkgb3BlcmF0aW9ucyBoYXBwZW4gaW4gcGFyYWxsZWwsIHdpdGggcHJvcGVyIHRyYWNraW5nIHJlZ2FyZGxlc3Mgb2YgY29tcGxldGlvbiBvcmRlclxuICAgKlxuICAgKiAzLiBUSU1FT1VUIE1BTkFHRU1FTlQ6XG4gICAqICAgIC0gSW5kaXZpZHVhbCB0aW1lb3V0cyBmb3IgZWFjaCByZWxheSBvcGVyYXRpb25cbiAgICogICAgLSBQcm9wZXIgY2xlYW51cCBvZiB0aW1lb3V0cyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgKiAgICAtIENsZWFyIHRpbWVvdXQgZXJyb3IgcmVwb3J0aW5nXG4gICAqXG4gICAqIDQuIEVSUk9SIEhBTkRMSU5HOlxuICAgKiAgICAtIERldGFpbGVkIHRyYWNraW5nIG9mIHNwZWNpZmljIGVycm9ycyBmb3IgZWFjaCBmYWlsZWQgcmVsYXlcbiAgICogICAgLSBTcGVjaWFsIGhhbmRsaW5nIGZvciBlcGhlbWVyYWwgZXZlbnRzICh3aGljaCBkb24ndCBleHBlY3QgYWNrbm93bGVkZ2VtZW50KVxuICAgKiAgICAtIFJlcXVpcmVkUmVsYXlDb3VudCBwYXJhbWV0ZXIgdG8gY29udHJvbCB0aGUgbWluaW11bSBzdWNjZXNzIHRocmVzaG9sZFxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgRXZlbnQgdG8gcHVibGlzaFxuICAgKiBAcGFyYW0gdGltZW91dE1zIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciBlYWNoIHJlbGF5IHB1Ymxpc2ggb3BlcmF0aW9uXG4gICAqIEBwYXJhbSByZXF1aXJlZFJlbGF5Q291bnQgVGhlIG1pbmltdW0gbnVtYmVyIG9mIHJlbGF5cyB3ZSBleHBlY3QgdGhlIGV2ZW50IHRvIGJlIHB1Ymxpc2hlZCB0b1xuICAgKiBAcmV0dXJucyBBIHNldCBvZiByZWxheXMgdGhlIGV2ZW50IHdhcyBwdWJsaXNoZWQgdG9cbiAgICogQHRocm93cyB7TkRLUHVibGlzaEVycm9yfSBJZiB0aGUgZXZlbnQgY291bGQgbm90IGJlIHB1Ymxpc2hlZCB0byBhdCBsZWFzdCBgcmVxdWlyZWRSZWxheUNvdW50YCByZWxheXNcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZWxheVNldCA9IG5ldyBOREtSZWxheVNldChuZXcgU2V0KFtyZWxheTEsIHJlbGF5Ml0pLCBuZGspO1xuICAgKiBjb25zdCBwdWJsaXNoZWRUb1JlbGF5cyA9IGF3YWl0IHJlbGF5U2V0LnB1Ymxpc2goZXZlbnQpO1xuICAgKiAvLyBwdWJsaXNoZWRUb1JlbGF5cyBjYW4gY29udGFpbiByZWxheTEsIHJlbGF5MiwgYm90aCwgb3Igbm9uZVxuICAgKiAvLyBkZXBlbmRpbmcgb24gd2hpY2ggcmVsYXlzIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZCB0b1xuICAgKiBpZiAocHVibGlzaGVkVG9SZWxheXMuc2l6ZSA+IDApIHtcbiAgICogICBjb25zb2xlLmxvZyhcIkV2ZW50IHB1Ymxpc2hlZCB0byBhdCBsZWFzdCBvbmUgcmVsYXlcIik7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKGV2ZW50LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCA9IDEpIHtcbiAgICBjb25zdCBwdWJsaXNoZWRUb1JlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgZXJyb3JzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBpc0VwaGVtZXJhbDIgPSBldmVudC5pc0VwaGVtZXJhbCgpO1xuICAgIGV2ZW50LnB1Ymxpc2hTdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICBjb25zdCByZWxheVB1Ymxpc2hlZEhhbmRsZXIgPSAocmVsYXkpID0+IHtcbiAgICAgIHB1Ymxpc2hlZFRvUmVsYXlzLmFkZChyZWxheSk7XG4gICAgfTtcbiAgICBldmVudC5vbihcInJlbGF5OnB1Ymxpc2hlZFwiLCByZWxheVB1Ymxpc2hlZEhhbmRsZXIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IEFycmF5LmZyb20odGhpcy5yZWxheXMpLm1hcCgocmVsYXkpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGltZW91dElkID0gdGltZW91dE1zID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXB1Ymxpc2hlZFRvUmVsYXlzLmhhcyhyZWxheSkpIHtcbiAgICAgICAgICAgICAgZXJyb3JzLnNldChyZWxheSwgbmV3IEVycm9yKGBQdWJsaXNoIHRpbWVvdXQgYWZ0ZXIgJHt0aW1lb3V0TXN9bXNgKSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRpbWVvdXRNcykgOiBudWxsO1xuICAgICAgICAgIHJlbGF5LnB1Ymxpc2goZXZlbnQsIHRpbWVvdXRNcykudGhlbigoc3VjY2VzcykgPT4ge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICBwdWJsaXNoZWRUb1JlbGF5cy5hZGQocmVsYXkpO1xuICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICBpZiAoIWlzRXBoZW1lcmFsMikge1xuICAgICAgICAgICAgICBlcnJvcnMuc2V0KHJlbGF5LCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICBpZiAocHVibGlzaGVkVG9SZWxheXMuc2l6ZSA8IHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgICAgICBpZiAoIWlzRXBoZW1lcmFsMikge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IE5ES1B1Ymxpc2hFcnJvcihcbiAgICAgICAgICAgIFwiTm90IGVub3VnaCByZWxheXMgcmVjZWl2ZWQgdGhlIGV2ZW50XCIsXG4gICAgICAgICAgICBlcnJvcnMsXG4gICAgICAgICAgICBwdWJsaXNoZWRUb1JlbGF5cyxcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICApO1xuICAgICAgICAgIGV2ZW50LnB1Ymxpc2hTdGF0dXMgPSBcImVycm9yXCI7XG4gICAgICAgICAgZXZlbnQucHVibGlzaEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgdGhpcy5uZGs/LmVtaXQoXCJldmVudDpwdWJsaXNoLWZhaWxlZFwiLCBldmVudCwgZXJyb3IsIHRoaXMucmVsYXlVcmxzKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnQucHVibGlzaFN0YXR1cyA9IFwic3VjY2Vzc1wiO1xuICAgICAgICBldmVudC5lbWl0KFwicHVibGlzaGVkXCIsIHsgcmVsYXlTZXQ6IHRoaXMsIHB1Ymxpc2hlZFRvUmVsYXlzIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHB1Ymxpc2hlZFRvUmVsYXlzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBldmVudC5vZmYoXCJyZWxheTpwdWJsaXNoZWRcIiwgcmVsYXlQdWJsaXNoZWRIYW5kbGVyKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlzLnNpemU7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9zZXRzL2NhbGN1bGF0ZS50c1xudmFyIGQgPSBjcmVhdGVEZWJ1ZyhcIm5kazpvdXRib3g6Y2FsY3VsYXRlXCIpO1xuYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXlTZXRGcm9tRXZlbnQobmRrLCBldmVudCkge1xuICBjb25zdCByZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBhdXRob3JXcml0ZVJlbGF5cyA9IGF3YWl0IGdldFdyaXRlUmVsYXlzRm9yKG5kaywgZXZlbnQucHVia2V5KTtcbiAgaWYgKGF1dGhvcldyaXRlUmVsYXlzKSB7XG4gICAgYXV0aG9yV3JpdGVSZWxheXMuZm9yRWFjaCgocmVsYXlVcmwpID0+IHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gbmRrLnBvb2w/LmdldFJlbGF5KHJlbGF5VXJsKTtcbiAgICAgIGlmIChyZWxheSkgcmVsYXlzLmFkZChyZWxheSk7XG4gICAgfSk7XG4gIH1cbiAgbGV0IHJlbGF5SGludHMgPSBldmVudC50YWdzLmZpbHRlcigodGFnKSA9PiBbXCJhXCIsIFwiZVwiXS5pbmNsdWRlcyh0YWdbMF0pKS5tYXAoKHRhZykgPT4gdGFnWzJdKS5maWx0ZXIoKHVybCkgPT4gdXJsPy5zdGFydHNXaXRoKFwid3NzOi8vXCIpKS5maWx0ZXIoKHVybCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBuZXcgVVJMKHVybCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pLm1hcCgodXJsKSA9PiBub3JtYWxpemVSZWxheVVybCh1cmwpKTtcbiAgcmVsYXlIaW50cyA9IEFycmF5LmZyb20obmV3IFNldChyZWxheUhpbnRzKSkuc2xpY2UoMCwgNSk7XG4gIHJlbGF5SGludHMuZm9yRWFjaCgocmVsYXlVcmwpID0+IHtcbiAgICBjb25zdCByZWxheSA9IG5kay5wb29sPy5nZXRSZWxheShyZWxheVVybCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgaWYgKHJlbGF5KSB7XG4gICAgICBkKFwiQWRkaW5nIHJlbGF5IGhpbnQgJXNcIiwgcmVsYXlVcmwpO1xuICAgICAgcmVsYXlzLmFkZChyZWxheSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcFRhZ3MgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICBpZiAocFRhZ3MubGVuZ3RoIDwgNSkge1xuICAgIGNvbnN0IHBUYWdnZWRSZWxheXMgPSBBcnJheS5mcm9tKFxuICAgICAgY2hvb3NlUmVsYXlDb21iaW5hdGlvbkZvclB1YmtleXMobmRrLCBwVGFncywgXCJyZWFkXCIsIHtcbiAgICAgICAgcHJlZmVycmVkUmVsYXlzOiBuZXcgU2V0KGF1dGhvcldyaXRlUmVsYXlzKVxuICAgICAgfSkua2V5cygpXG4gICAgKTtcbiAgICBwVGFnZ2VkUmVsYXlzLmZvckVhY2goKHJlbGF5VXJsKSA9PiB7XG4gICAgICBjb25zdCByZWxheSA9IG5kay5wb29sPy5nZXRSZWxheShyZWxheVVybCwgZmFsc2UsIHRydWUpO1xuICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgIGQoXCJBZGRpbmcgcC10YWdnZWQgcmVsYXkgJXNcIiwgcmVsYXlVcmwpO1xuICAgICAgICByZWxheXMuYWRkKHJlbGF5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkKFwiVG9vIG1hbnkgcC10YWdzIHRvIGNvbnNpZGVyICVkXCIsIHBUYWdzLmxlbmd0aCk7XG4gIH1cbiAgbmRrLnBvb2w/LnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLmZvckVhY2goKHJlbGF5KSA9PiByZWxheXMuYWRkKHJlbGF5KSk7XG4gIHJldHVybiBuZXcgTkRLUmVsYXlTZXQocmVsYXlzLCBuZGspO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcihuZGssIGZpbHRlcnMsIHBvb2wpIHtcbiAgY29uc3QgcmVzdWx0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgYXV0aG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XG4gICAgaWYgKGZpbHRlci5hdXRob3JzKSB7XG4gICAgICBmaWx0ZXIuYXV0aG9ycy5mb3JFYWNoKChhdXRob3IpID0+IGF1dGhvcnMuYWRkKGF1dGhvcikpO1xuICAgIH1cbiAgfSk7XG4gIGlmIChhdXRob3JzLnNpemUgPiAwKSB7XG4gICAgY29uc3QgYXV0aG9yVG9SZWxheXNNYXAgPSBnZXRSZWxheXNGb3JGaWx0ZXJXaXRoQXV0aG9ycyhuZGssIEFycmF5LmZyb20oYXV0aG9ycykpO1xuICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2YgYXV0aG9yVG9SZWxheXNNYXAua2V5cygpKSB7XG4gICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBbXSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICAgIGlmIChmaWx0ZXIuYXV0aG9ycykge1xuICAgICAgICBmb3IgKGNvbnN0IFtyZWxheVVybCwgYXV0aG9yczJdIG9mIGF1dGhvclRvUmVsYXlzTWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgIGNvbnN0IGF1dGhvckZpbHRlckFuZFJlbGF5UHVia2V5SW50ZXJzZWN0aW9uID0gZmlsdGVyLmF1dGhvcnMuZmlsdGVyKFxuICAgICAgICAgICAgKGF1dGhvcikgPT4gYXV0aG9yczIuaW5jbHVkZXMoYXV0aG9yKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdWx0LnNldChyZWxheVVybCwgW1xuICAgICAgICAgICAgLi4ucmVzdWx0LmdldChyZWxheVVybCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmZpbHRlcixcbiAgICAgICAgICAgICAgLy8gT3ZlcndyaXRlIGF1dGhvcnMgc2VudCB0byB0aGlzIHJlbGF5IHdpdGggdGhlIGF1dGhvcnMgdGhhdCB3ZXJlXG4gICAgICAgICAgICAgIC8vIHByZXNlbnQgaW4gdGhlIGZpbHRlciBhbmQgYXJlIGFsc28gcHJlc2VudCBpbiB0aGUgcmVsYXlcbiAgICAgICAgICAgICAgYXV0aG9yczogYXV0aG9yRmlsdGVyQW5kUmVsYXlQdWJrZXlJbnRlcnNlY3Rpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCByZWxheVVybCBvZiBhdXRob3JUb1JlbGF5c01hcC5rZXlzKCkpIHtcbiAgICAgICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBbLi4ucmVzdWx0LmdldChyZWxheVVybCksIGZpbHRlcl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChuZGsuZXhwbGljaXRSZWxheVVybHMpIHtcbiAgICAgIG5kay5leHBsaWNpdFJlbGF5VXJscy5mb3JFYWNoKChyZWxheVVybCkgPT4ge1xuICAgICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBmaWx0ZXJzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAocmVzdWx0LnNpemUgPT09IDApIHtcbiAgICBwb29sLnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLnNsaWNlKDAsIDUpLmZvckVhY2goKHJlbGF5KSA9PiB7XG4gICAgICByZXN1bHQuc2V0KHJlbGF5LnVybCwgZmlsdGVycyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlbGF5U2V0c0Zyb21GaWx0ZXJzKG5kaywgZmlsdGVycywgcG9vbCkge1xuICBjb25zdCBhID0gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcihuZGssIGZpbHRlcnMsIHBvb2wpO1xuICByZXR1cm4gYTtcbn1cblxuLy8gc3JjL2V2ZW50cy9jb250ZW50LXRhZ2dlci50c1xuaW1wb3J0IHsgbmlwMTkgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbmZ1bmN0aW9uIG1lcmdlVGFncyh0YWdzMSwgdGFnczIpIHtcbiAgY29uc3QgdGFnTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgZ2VuZXJhdGVLZXkgPSAodGFnKSA9PiB0YWcuam9pbihcIixcIik7XG4gIGNvbnN0IGlzQ29udGFpbmVkID0gKHNtYWxsZXIsIGxhcmdlcikgPT4ge1xuICAgIHJldHVybiBzbWFsbGVyLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlID09PSBsYXJnZXJbaW5kZXhdKTtcbiAgfTtcbiAgY29uc3QgcHJvY2Vzc1RhZyA9ICh0YWcpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGV4aXN0aW5nVGFnXSBvZiB0YWdNYXApIHtcbiAgICAgIGlmIChpc0NvbnRhaW5lZChleGlzdGluZ1RhZywgdGFnKSB8fCBpc0NvbnRhaW5lZCh0YWcsIGV4aXN0aW5nVGFnKSkge1xuICAgICAgICBpZiAodGFnLmxlbmd0aCA+PSBleGlzdGluZ1RhZy5sZW5ndGgpIHtcbiAgICAgICAgICB0YWdNYXAuc2V0KGtleSwgdGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRhZ01hcC5zZXQoZ2VuZXJhdGVLZXkodGFnKSwgdGFnKTtcbiAgfTtcbiAgdGFnczEuY29uY2F0KHRhZ3MyKS5mb3JFYWNoKHByb2Nlc3NUYWcpO1xuICByZXR1cm4gQXJyYXkuZnJvbSh0YWdNYXAudmFsdWVzKCkpO1xufVxuZnVuY3Rpb24gdW5pcXVlVGFnKGEsIGIpIHtcbiAgY29uc3QgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICBjb25zdCBiTGVuZ3RoID0gYi5sZW5ndGg7XG4gIGNvbnN0IHNhbWVMZW5ndGggPSBhTGVuZ3RoID09PSBiTGVuZ3RoO1xuICBpZiAoc2FtZUxlbmd0aCkge1xuICAgIGlmIChhLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBiW2ldKSkge1xuICAgICAgcmV0dXJuIFthXTtcbiAgICB9XG4gICAgcmV0dXJuIFthLCBiXTtcbiAgfVxuICBpZiAoYUxlbmd0aCA+IGJMZW5ndGggJiYgYS5ldmVyeSgodiwgaSkgPT4gdiA9PT0gYltpXSkpIHtcbiAgICByZXR1cm4gW2FdO1xuICB9XG4gIGlmIChiTGVuZ3RoID4gYUxlbmd0aCAmJiBiLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBhW2ldKSkge1xuICAgIHJldHVybiBbYl07XG4gIH1cbiAgcmV0dXJuIFthLCBiXTtcbn1cbnZhciBoYXNodGFnUmVnZXggPSAvKD88PVxcc3xeKSgjW15cXHMhQCMkJV4mKigpPSsuLyxbe1xcXX07OidcIj8+PF0rKS9nO1xuZnVuY3Rpb24gZ2VuZXJhdGVIYXNodGFncyhjb250ZW50KSB7XG4gIGNvbnN0IGhhc2h0YWdzID0gY29udGVudC5tYXRjaChoYXNodGFnUmVnZXgpO1xuICBjb25zdCB0YWdJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCB0YWcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBpZiAoaGFzaHRhZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGhhc2h0YWcgb2YgaGFzaHRhZ3MpIHtcbiAgICAgIGlmICh0YWdJZHMuaGFzKGhhc2h0YWcuc2xpY2UoMSkpKSBjb250aW51ZTtcbiAgICAgIHRhZy5hZGQoaGFzaHRhZy5zbGljZSgxKSk7XG4gICAgICB0YWdJZHMuYWRkKGhhc2h0YWcuc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbSh0YWcpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50VGFncyhjb250ZW50LCB0YWdzID0gW10pIHtcbiAgY29uc3QgdGFnUmVnZXggPSAvKEB8bm9zdHI6KShucHVifG5wcm9maWxlfG5vdGV8bmV2ZW50fG5hZGRyKVthLXpBLVowLTldKy9nO1xuICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICBjb25zdCBhZGRUYWdJZk5ldyA9ICh0KSA9PiB7XG4gICAgaWYgKCF0YWdzLmZpbmQoKHQyKSA9PiBbXCJxXCIsIHRbMF1dLmluY2x1ZGVzKHQyWzBdKSAmJiB0MlsxXSA9PT0gdFsxXSkpIHtcbiAgICAgIHRhZ3MucHVzaCh0KTtcbiAgICB9XG4gIH07XG4gIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UodGFnUmVnZXgsICh0YWcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW50aXR5ID0gdGFnLnNwbGl0KC8oQHxub3N0cjopLylbMl07XG4gICAgICBjb25zdCB7IHR5cGUsIGRhdGEgfSA9IG5pcDE5LmRlY29kZShlbnRpdHkpO1xuICAgICAgbGV0IHQ7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm5wdWJcIjpcbiAgICAgICAgICB0ID0gW1wicFwiLCBkYXRhXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5wcm9maWxlXCI6XG4gICAgICAgICAgdCA9IFtcInBcIiwgZGF0YS5wdWJrZXldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICBhZGRUYWdJZk5ldyhbXCJxXCIsIGRhdGEsIGF3YWl0IG1heWJlR2V0RXZlbnRSZWxheVVybChlbnRpdHkpXSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5ldmVudFwiOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7IGlkLCBhdXRob3IgfSA9IGRhdGE7XG4gICAgICAgICAgICAgIGxldCB7IHJlbGF5cyB9ID0gZGF0YTtcbiAgICAgICAgICAgICAgaWYgKCFyZWxheXMgfHwgcmVsYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlbGF5cyA9IFthd2FpdCBtYXliZUdldEV2ZW50UmVsYXlVcmwoZW50aXR5KV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWRkVGFnSWZOZXcoW1wicVwiLCBpZCwgcmVsYXlzWzBdXSk7XG4gICAgICAgICAgICAgIGlmIChhdXRob3IpIGFkZFRhZ0lmTmV3KFtcInBcIiwgYXV0aG9yXSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5hZGRyXCI6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGlkID0gW2RhdGEua2luZCwgZGF0YS5wdWJrZXksIGRhdGEuaWRlbnRpZmllcl0uam9pbihcIjpcIik7XG4gICAgICAgICAgICAgIGxldCByZWxheXMgPSBkYXRhLnJlbGF5cyA/PyBbXTtcbiAgICAgICAgICAgICAgaWYgKHJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZWxheXMgPSBbYXdhaXQgbWF5YmVHZXRFdmVudFJlbGF5VXJsKGVudGl0eSldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFkZFRhZ0lmTmV3KFtcInFcIiwgaWQsIHJlbGF5c1swXV0pO1xuICAgICAgICAgICAgICBhZGRUYWdJZk5ldyhbXCJwXCIsIGRhdGEucHVia2V5XSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgfVxuICAgICAgaWYgKHQpIGFkZFRhZ0lmTmV3KHQpO1xuICAgICAgcmV0dXJuIGBub3N0cjoke2VudGl0eX1gO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gIH0pO1xuICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIGNvbnN0IG5ld1RhZ3MgPSBnZW5lcmF0ZUhhc2h0YWdzKGNvbnRlbnQpLm1hcCgoaGFzaHRhZykgPT4gW1widFwiLCBoYXNodGFnXSk7XG4gIHRhZ3MgPSBtZXJnZVRhZ3ModGFncywgbmV3VGFncyk7XG4gIHJldHVybiB7IGNvbnRlbnQsIHRhZ3MgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG1heWJlR2V0RXZlbnRSZWxheVVybChfbmlwMTlJZCkge1xuICByZXR1cm4gXCJcIjtcbn1cblxuLy8gc3JjL2V2ZW50cy9lbmNyeXB0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0KHJlY2lwaWVudCwgc2lnbmVyLCBzY2hlbWUgPSBcIm5pcDQ0XCIpIHtcbiAgbGV0IGVuY3J5cHRlZDtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kIVwiKTtcbiAgbGV0IGN1cnJlbnRTaWduZXIgPSBzaWduZXI7XG4gIGlmICghY3VycmVudFNpZ25lcikge1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGN1cnJlbnRTaWduZXIgPSB0aGlzLm5kay5zaWduZXI7XG4gIH1cbiAgaWYgKCFjdXJyZW50U2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBOREsgc2lnbmVyXCIpO1xuICBjb25zdCBjdXJyZW50UmVjaXBpZW50ID0gcmVjaXBpZW50IHx8ICgoKSA9PiB7XG4gICAgY29uc3QgcFRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIik7XG4gICAgaWYgKHBUYWdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVjaXBpZW50IGNvdWxkIGJlIGRldGVybWluZWQgYW5kIG5vIGV4cGxpY2l0IHJlY2lwaWVudCB3YXMgcHJvdmlkZWRcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5OiBwVGFnc1swXVsxXSB9KTtcbiAgfSkoKTtcbiAgaWYgKHNjaGVtZSA9PT0gXCJuaXA0NFwiICYmIGF3YWl0IGlzRW5jcnlwdGlvbkVuYWJsZWQoY3VycmVudFNpZ25lciwgXCJuaXA0NFwiKSkge1xuICAgIGVuY3J5cHRlZCA9IGF3YWl0IGN1cnJlbnRTaWduZXIuZW5jcnlwdChjdXJyZW50UmVjaXBpZW50LCB0aGlzLmNvbnRlbnQsIFwibmlwNDRcIik7XG4gIH1cbiAgaWYgKCghZW5jcnlwdGVkIHx8IHNjaGVtZSA9PT0gXCJuaXAwNFwiKSAmJiBhd2FpdCBpc0VuY3J5cHRpb25FbmFibGVkKGN1cnJlbnRTaWduZXIsIFwibmlwMDRcIikpIHtcbiAgICBlbmNyeXB0ZWQgPSBhd2FpdCBjdXJyZW50U2lnbmVyLmVuY3J5cHQoY3VycmVudFJlY2lwaWVudCwgdGhpcy5jb250ZW50LCBcIm5pcDA0XCIpO1xuICB9XG4gIGlmICghZW5jcnlwdGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZW5jcnlwdCBldmVudC5cIik7XG4gIHRoaXMuY29udGVudCA9IGVuY3J5cHRlZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQoc2VuZGVyLCBzaWduZXIsIHNjaGVtZSkge1xuICBpZiAodGhpcy5uZGs/LmNhY2hlQWRhcHRlcj8uZ2V0RGVjcnlwdGVkRXZlbnQpIHtcbiAgICBsZXQgY2FjaGVkRXZlbnQgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmdldERlY3J5cHRlZEV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNhY2hlZEV2ZW50ID0gdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmdldERlY3J5cHRlZEV2ZW50KHRoaXMuaWQpO1xuICAgIH1cbiAgICBpZiAoY2FjaGVkRXZlbnQpIHtcbiAgICAgIHRoaXMuY29udGVudCA9IGNhY2hlZEV2ZW50LmNvbnRlbnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGxldCBkZWNyeXB0ZWQ7XG4gIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZCFcIik7XG4gIGxldCBjdXJyZW50U2lnbmVyID0gc2lnbmVyO1xuICBpZiAoIWN1cnJlbnRTaWduZXIpIHtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBjdXJyZW50U2lnbmVyID0gdGhpcy5uZGsuc2lnbmVyO1xuICB9XG4gIGlmICghY3VycmVudFNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwibm8gTkRLIHNpZ25lclwiKTtcbiAgY29uc3QgY3VycmVudFNlbmRlciA9IHNlbmRlciB8fCB0aGlzLmF1dGhvcjtcbiAgaWYgKCFjdXJyZW50U2VuZGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzZW5kZXIgcHJvdmlkZWQgYW5kIG5vIGF1dGhvciBhdmFpbGFibGVcIik7XG4gIGNvbnN0IGN1cnJlbnRTY2hlbWUgPSBzY2hlbWUgfHwgKHRoaXMuY29udGVudC5tYXRjaCgvXFxcXD9pdj0vKSA/IFwibmlwMDRcIiA6IFwibmlwNDRcIik7XG4gIGlmICgoY3VycmVudFNjaGVtZSA9PT0gXCJuaXAwNFwiIHx8IHRoaXMua2luZCA9PT0gNCkgJiYgYXdhaXQgaXNFbmNyeXB0aW9uRW5hYmxlZChjdXJyZW50U2lnbmVyLCBcIm5pcDA0XCIpICYmIHRoaXMuY29udGVudC5zZWFyY2goXCJcXFxcP2l2PVwiKSkge1xuICAgIGRlY3J5cHRlZCA9IGF3YWl0IGN1cnJlbnRTaWduZXIuZGVjcnlwdChjdXJyZW50U2VuZGVyLCB0aGlzLmNvbnRlbnQsIFwibmlwMDRcIik7XG4gIH1cbiAgaWYgKCFkZWNyeXB0ZWQgJiYgY3VycmVudFNjaGVtZSA9PT0gXCJuaXA0NFwiICYmIGF3YWl0IGlzRW5jcnlwdGlvbkVuYWJsZWQoY3VycmVudFNpZ25lciwgXCJuaXA0NFwiKSkge1xuICAgIGRlY3J5cHRlZCA9IGF3YWl0IGN1cnJlbnRTaWduZXIuZGVjcnlwdChjdXJyZW50U2VuZGVyLCB0aGlzLmNvbnRlbnQsIFwibmlwNDRcIik7XG4gIH1cbiAgaWYgKCFkZWNyeXB0ZWQpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNyeXB0IGV2ZW50LlwiKTtcbiAgdGhpcy5jb250ZW50ID0gZGVjcnlwdGVkO1xuICBpZiAodGhpcy5uZGs/LmNhY2hlQWRhcHRlcj8uYWRkRGVjcnlwdGVkRXZlbnQpIHtcbiAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuYWRkRGVjcnlwdGVkRXZlbnQodGhpcyk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGlzRW5jcnlwdGlvbkVuYWJsZWQoc2lnbmVyLCBzY2hlbWUpIHtcbiAgaWYgKCFzaWduZXIuZW5jcnlwdGlvbkVuYWJsZWQpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFzY2hlbWUpIHJldHVybiB0cnVlO1xuICByZXR1cm4gQm9vbGVhbihhd2FpdCBzaWduZXIuZW5jcnlwdGlvbkVuYWJsZWQoc2NoZW1lKSk7XG59XG5cbi8vIHNyYy90aHJlYWQvaW5kZXgudHNcbmZ1bmN0aW9uIGV2ZW50c0J5U2FtZUF1dGhvcihvcCwgZXZlbnRzKSB7XG4gIGNvbnN0IGV2ZW50c0J5QXV0aG9yID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZXZlbnRzQnlBdXRob3Iuc2V0KG9wLmlkLCBvcCk7XG4gIGV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5wdWJrZXkgPT09IG9wLnB1YmtleSkge1xuICAgICAgZXZlbnRzQnlBdXRob3Iuc2V0KGV2ZW50LmlkLCBldmVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGV2ZW50c0J5QXV0aG9yO1xufVxudmFyIGhhc01hcmtlcnMgPSAoZXZlbnQsIHRhZ1R5cGUpID0+IHtcbiAgcmV0dXJuIGV2ZW50LmdldE1hdGNoaW5nVGFncyh0YWdUeXBlKS5zb21lKCh0YWcpID0+IHRhZ1szXSAmJiB0YWdbM10gIT09IFwiXCIpO1xufTtcbmZ1bmN0aW9uIGV2ZW50SXNSZXBseShvcCwgZXZlbnQsIHRocmVhZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIHRhZ1R5cGUpIHtcbiAgdGFnVHlwZSA/Pz0gb3AudGFnVHlwZSgpO1xuICBjb25zdCB0YWdzID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKHRhZ1R5cGUpO1xuICB0aHJlYWRJZHMuYWRkKG9wLnRhZ0lkKCkpO1xuICBpZiAodGhyZWFkSWRzLmhhcyhldmVudC50YWdJZCgpKSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBoZWVkRXhwbGljaXRSZXBseU1hcmtlciA9ICgpID0+IHtcbiAgICBsZXQgZXZlbnRJc1RhZ2dlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgIGlmICh0YWdbM10gPT09IFwicmVwbHlcIikgcmV0dXJuIHRocmVhZElkcy5oYXModGFnWzFdKTtcbiAgICAgIGNvbnN0IG1hcmtlcklzRW1wdHkgPSB0YWdbM10gPT09IFwiXCIgfHwgdGFnWzNdID09PSB2b2lkIDA7XG4gICAgICBjb25zdCBtYXJrZXJJc1Jvb3QgPSB0YWdbM10gPT09IFwicm9vdFwiO1xuICAgICAgaWYgKHRhZ1sxXSA9PT0gb3AudGFnSWQoKSAmJiAobWFya2VySXNFbXB0eSB8fCBtYXJrZXJJc1Jvb3QpKSB7XG4gICAgICAgIGV2ZW50SXNUYWdnZWQgPSBtYXJrZXJJc1Jvb3QgPyBcInJvb3RcIiA6IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZXZlbnRJc1RhZ2dlZCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChldmVudElzVGFnZ2VkID09PSBcInJvb3RcIikgcmV0dXJuIHRydWU7XG4gIH07XG4gIGNvbnN0IGV4cGxpY2l0UmVwbHlNYXJrZXIgPSBoZWVkRXhwbGljaXRSZXBseU1hcmtlcigpO1xuICBpZiAoZXhwbGljaXRSZXBseU1hcmtlciAhPT0gdm9pZCAwKSByZXR1cm4gZXhwbGljaXRSZXBseU1hcmtlcjtcbiAgaWYgKGhhc01hcmtlcnMoZXZlbnQsIHRhZ1R5cGUpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGV4cGVjdGVkVGFncyA9IG9wLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIGV4cGVjdGVkVGFncy5wdXNoKG9wLmlkKTtcbiAgcmV0dXJuIGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImVcIikuZXZlcnkoKHRhZykgPT4gZXhwZWN0ZWRUYWdzLmluY2x1ZGVzKHRhZ1sxXSkpO1xufVxuZnVuY3Rpb24gZXZlbnRUaHJlYWRzKG9wLCBldmVudHMpIHtcbiAgY29uc3QgZXZlbnRzQnlBdXRob3IgPSBldmVudHNCeVNhbWVBdXRob3Iob3AsIGV2ZW50cyk7XG4gIGNvbnN0IHRocmVhZEV2ZW50cyA9IGV2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiBldmVudElzUGFydE9mVGhyZWFkKG9wLCBldmVudCwgZXZlbnRzQnlBdXRob3IpKTtcbiAgcmV0dXJuIHRocmVhZEV2ZW50cy5zb3J0KChhLCBiKSA9PiBhLmNyZWF0ZWRfYXQgLSBiLmNyZWF0ZWRfYXQpO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRSZXBseUlkKGV2ZW50KSB7XG4gIGNvbnN0IHJlcGx5VGFnID0gZ2V0UmVwbHlUYWcoZXZlbnQpO1xuICBpZiAocmVwbHlUYWcpIHJldHVybiByZXBseVRhZ1sxXTtcbiAgY29uc3Qgcm9vdFRhZyA9IGdldFJvb3RUYWcoZXZlbnQpO1xuICBpZiAocm9vdFRhZykgcmV0dXJuIHJvb3RUYWdbMV07XG59XG5mdW5jdGlvbiBpc0V2ZW50T3JpZ2luYWxQb3N0KGV2ZW50KSB7XG4gIHJldHVybiBnZXRFdmVudFJlcGx5SWQoZXZlbnQpID09PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBldmVudFRocmVhZElkcyhvcCwgZXZlbnRzKSB7XG4gIGNvbnN0IHRocmVhZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHRocmVhZEV2ZW50cyA9IGV2ZW50VGhyZWFkcyhvcCwgZXZlbnRzKTtcbiAgdGhyZWFkRXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB0aHJlYWRJZHMuc2V0KGV2ZW50LmlkLCBldmVudCkpO1xuICByZXR1cm4gdGhyZWFkSWRzO1xufVxuZnVuY3Rpb24gZXZlbnRSZXBsaWVzKG9wLCBldmVudHMsIHRocmVhZEV2ZW50SWRzKSB7XG4gIHRocmVhZEV2ZW50SWRzID8/PSBuZXcgU2V0KGV2ZW50VGhyZWFkSWRzKG9wLCBldmVudHMpLmtleXMoKSk7XG4gIHJldHVybiBldmVudHMuZmlsdGVyKChldmVudCkgPT4gZXZlbnRJc1JlcGx5KG9wLCBldmVudCwgdGhyZWFkRXZlbnRJZHMpKTtcbn1cbmZ1bmN0aW9uIGV2ZW50SXNQYXJ0T2ZUaHJlYWQob3AsIGV2ZW50LCBldmVudHNCeUF1dGhvcikge1xuICBpZiAob3AucHVia2V5ICE9PSBldmVudC5wdWJrZXkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgdGFnZ2VkRXZlbnRJZHMgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICBjb25zdCBhbGxUYWdnZWRFdmVudHNBcmVCeU9yaWdpbmFsQXV0aG9yID0gdGFnZ2VkRXZlbnRJZHMuZXZlcnkoKGlkKSA9PiBldmVudHNCeUF1dGhvci5oYXMoaWQpKTtcbiAgcmV0dXJuIGFsbFRhZ2dlZEV2ZW50c0FyZUJ5T3JpZ2luYWxBdXRob3I7XG59XG5mdW5jdGlvbiBldmVudEhhc0VUYWdNYXJrZXJzKGV2ZW50KSB7XG4gIGZvciAoY29uc3QgdGFnIG9mIGV2ZW50LnRhZ3MpIHtcbiAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiAodGFnWzNdID8/IFwiXCIpLmxlbmd0aCA+IDApIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFJvb3RFdmVudElkKGV2ZW50LCBzZWFyY2hUYWcpIHtcbiAgc2VhcmNoVGFnID8/PSBldmVudC50YWdUeXBlKCk7XG4gIGNvbnN0IHJvb3RFdmVudFRhZyA9IGdldFJvb3RUYWcoZXZlbnQsIHNlYXJjaFRhZyk7XG4gIGlmIChyb290RXZlbnRUYWcpIHJldHVybiByb290RXZlbnRUYWdbMV07XG4gIGNvbnN0IHJlcGx5VGFnID0gZ2V0UmVwbHlUYWcoZXZlbnQsIHNlYXJjaFRhZyk7XG4gIHJldHVybiByZXBseVRhZz8uWzFdO1xufVxuZnVuY3Rpb24gZ2V0Um9vdFRhZyhldmVudCwgc2VhcmNoVGFnKSB7XG4gIHNlYXJjaFRhZyA/Pz0gZXZlbnQudGFnVHlwZSgpO1xuICBjb25zdCByb290RXZlbnRUYWcgPSBldmVudC50YWdzLmZpbmQoaXNUYWdSb290VGFnKTtcbiAgaWYgKCFyb290RXZlbnRUYWcpIHtcbiAgICBpZiAoZXZlbnRIYXNFVGFnTWFya2VycyhldmVudCkpIHJldHVybjtcbiAgICBjb25zdCBtYXRjaGluZ1RhZ3MgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3Moc2VhcmNoVGFnKTtcbiAgICBpZiAobWF0Y2hpbmdUYWdzLmxlbmd0aCA8IDMpIHJldHVybiBtYXRjaGluZ1RhZ3NbMF07XG4gIH1cbiAgcmV0dXJuIHJvb3RFdmVudFRhZztcbn1cbnZhciBuaXAyMlJvb3RUYWdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiQVwiLCBcIkVcIiwgXCJJXCJdKTtcbnZhciBuaXAyMlJlcGx5VGFncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImFcIiwgXCJlXCIsIFwiaVwiXSk7XG5mdW5jdGlvbiBnZXRSZXBseVRhZyhldmVudCwgc2VhcmNoVGFnKSB7XG4gIGlmIChldmVudC5raW5kID09PSAxMTExIC8qIEdlbmVyaWNSZXBseSAqLykge1xuICAgIGxldCByZXBseVRhZzI7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgICAgaWYgKG5pcDIyUm9vdFRhZ3MuaGFzKHRhZ1swXSkpIHJlcGx5VGFnMiA9IHRhZztcbiAgICAgIGVsc2UgaWYgKG5pcDIyUmVwbHlUYWdzLmhhcyh0YWdbMF0pKSB7XG4gICAgICAgIHJlcGx5VGFnMiA9IHRhZztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBseVRhZzI7XG4gIH1cbiAgc2VhcmNoVGFnID8/PSBldmVudC50YWdUeXBlKCk7XG4gIGxldCBoYXNNYXJrZXJzMiA9IGZhbHNlO1xuICBsZXQgcmVwbHlUYWc7XG4gIGZvciAoY29uc3QgdGFnIG9mIGV2ZW50LnRhZ3MpIHtcbiAgICBpZiAodGFnWzBdICE9PSBzZWFyY2hUYWcpIGNvbnRpbnVlO1xuICAgIGlmICgodGFnWzNdID8/IFwiXCIpLmxlbmd0aCA+IDApIGhhc01hcmtlcnMyID0gdHJ1ZTtcbiAgICBpZiAoaGFzTWFya2VyczIgJiYgdGFnWzNdID09PSBcInJlcGx5XCIpIHJldHVybiB0YWc7XG4gICAgaWYgKGhhc01hcmtlcnMyICYmIHRhZ1szXSA9PT0gXCJyb290XCIpIHJlcGx5VGFnID0gdGFnO1xuICAgIGlmICghaGFzTWFya2VyczIpIHJlcGx5VGFnID0gdGFnO1xuICB9XG4gIHJldHVybiByZXBseVRhZztcbn1cbmZ1bmN0aW9uIGlzVGFnUm9vdFRhZyh0YWcpIHtcbiAgcmV0dXJuIHRhZ1swXSA9PT0gXCJFXCIgfHwgdGFnWzNdID09PSBcInJvb3RcIjtcbn1cblxuLy8gc3JjL2V2ZW50cy9mZXRjaC10YWdnZWQtZXZlbnQudHNcbmFzeW5jIGZ1bmN0aW9uIGZldGNoVGFnZ2VkRXZlbnQodGFnLCBtYXJrZXIpIHtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBmb3VuZFwiKTtcbiAgY29uc3QgdCA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKHRhZywgbWFya2VyKTtcbiAgaWYgKHQubGVuZ3RoID09PSAwKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBbXywgaWQsIGhpbnRdID0gdFswXTtcbiAgbGV0IHJlbGF5ID0gaGludCAhPT0gXCJcIiA/IHRoaXMubmRrLnBvb2wuZ2V0UmVsYXkoaGludCkgOiB2b2lkIDA7XG4gIGNvbnN0IGV2ZW50ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChpZCwge30sIHJlbGF5KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSb290RXZlbnQoc3ViT3B0cykge1xuICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IGZvdW5kXCIpO1xuICBjb25zdCByb290VGFnID0gZ2V0Um9vdFRhZyh0aGlzKTtcbiAgaWYgKCFyb290VGFnKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gdGhpcy5uZGsuZmV0Y2hFdmVudEZyb21UYWcocm9vdFRhZywgdGhpcywgc3ViT3B0cyk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFJlcGx5RXZlbnQoc3ViT3B0cykge1xuICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IGZvdW5kXCIpO1xuICBjb25zdCByZXBseVRhZyA9IGdldFJlcGx5VGFnKHRoaXMpO1xuICBpZiAoIXJlcGx5VGFnKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gdGhpcy5uZGsuZmV0Y2hFdmVudEZyb21UYWcocmVwbHlUYWcsIHRoaXMsIHN1Yk9wdHMpO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmQudHNcbmZ1bmN0aW9uIGlzUmVwbGFjZWFibGUoKSB7XG4gIGlmICh0aGlzLmtpbmQgPT09IHZvaWQgMCkgdGhyb3cgbmV3IEVycm9yKFwiS2luZCBub3Qgc2V0XCIpO1xuICByZXR1cm4gWzAsIDNdLmluY2x1ZGVzKHRoaXMua2luZCkgfHwgdGhpcy5raW5kID49IDFlNCAmJiB0aGlzLmtpbmQgPCAyZTQgfHwgdGhpcy5raW5kID49IDNlNCAmJiB0aGlzLmtpbmQgPCA0ZTQ7XG59XG5mdW5jdGlvbiBpc0VwaGVtZXJhbCgpIHtcbiAgaWYgKHRoaXMua2luZCA9PT0gdm9pZCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJLaW5kIG5vdCBzZXRcIik7XG4gIHJldHVybiB0aGlzLmtpbmQgPj0gMmU0ICYmIHRoaXMua2luZCA8IDNlNDtcbn1cbmZ1bmN0aW9uIGlzUGFyYW1SZXBsYWNlYWJsZSgpIHtcbiAgaWYgKHRoaXMua2luZCA9PT0gdm9pZCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJLaW5kIG5vdCBzZXRcIik7XG4gIHJldHVybiB0aGlzLmtpbmQgPj0gM2U0ICYmIHRoaXMua2luZCA8IDRlNDtcbn1cblxuLy8gc3JjL2V2ZW50cy9uaXAxOS50c1xuaW1wb3J0IHsgbmlwMTkgYXMgbmlwMTkyIH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG52YXIgREVGQVVMVF9SRUxBWV9DT1VOVCA9IDI7XG5mdW5jdGlvbiBlbmNvZGUobWF4UmVsYXlDb3VudCA9IERFRkFVTFRfUkVMQVlfQ09VTlQpIHtcbiAgbGV0IHJlbGF5cyA9IFtdO1xuICBpZiAodGhpcy5vblJlbGF5cy5sZW5ndGggPiAwKSB7XG4gICAgcmVsYXlzID0gdGhpcy5vblJlbGF5cy5tYXAoKHJlbGF5KSA9PiByZWxheS51cmwpO1xuICB9IGVsc2UgaWYgKHRoaXMucmVsYXkpIHtcbiAgICByZWxheXMgPSBbdGhpcy5yZWxheS51cmxdO1xuICB9XG4gIGlmIChyZWxheXMubGVuZ3RoID4gbWF4UmVsYXlDb3VudCkge1xuICAgIHJlbGF5cyA9IHJlbGF5cy5zbGljZSgwLCBtYXhSZWxheUNvdW50KTtcbiAgfVxuICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgIHJldHVybiBuaXAxOTIubmFkZHJFbmNvZGUoe1xuICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgcHVia2V5OiB0aGlzLnB1YmtleSxcbiAgICAgIGlkZW50aWZpZXI6IHRoaXMucmVwbGFjZWFibGVEVGFnKCksXG4gICAgICByZWxheXNcbiAgICB9KTtcbiAgfVxuICBpZiAocmVsYXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gbmlwMTkyLm5ldmVudEVuY29kZSh7XG4gICAgICBpZDogdGhpcy50YWdJZCgpLFxuICAgICAgcmVsYXlzLFxuICAgICAgYXV0aG9yOiB0aGlzLnB1YmtleVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBuaXAxOTIubm90ZUVuY29kZSh0aGlzLnRhZ0lkKCkpO1xufVxuXG4vLyBzcmMvZXZlbnRzL3JlcG9zdC50c1xuYXN5bmMgZnVuY3Rpb24gcmVwb3N0KHB1Ymxpc2ggPSB0cnVlLCBzaWduZXIpIHtcbiAgaWYgKCFzaWduZXIgJiYgcHVibGlzaCkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBzaWduZXIgPSB0aGlzLm5kay5zaWduZXI7XG4gIH1cbiAgY29uc3QgZSA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgIGtpbmQ6IGdldEtpbmQodGhpcylcbiAgfSk7XG4gIGlmICghdGhpcy5pc1Byb3RlY3RlZCkgZS5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodGhpcy5yYXdFdmVudCgpKTtcbiAgZS50YWcodGhpcyk7XG4gIGlmICh0aGlzLmtpbmQgIT09IDEgLyogVGV4dCAqLykge1xuICAgIGUudGFncy5wdXNoKFtcImtcIiwgYCR7dGhpcy5raW5kfWBdKTtcbiAgfVxuICBpZiAoc2lnbmVyKSBhd2FpdCBlLnNpZ24oc2lnbmVyKTtcbiAgaWYgKHB1Ymxpc2gpIGF3YWl0IGUucHVibGlzaCgpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGdldEtpbmQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtpbmQgPT09IDEpIHtcbiAgICByZXR1cm4gNiAvKiBSZXBvc3QgKi87XG4gIH1cbiAgcmV0dXJuIDE2IC8qIEdlbmVyaWNSZXBvc3QgKi87XG59XG5cbi8vIHNyYy9ldmVudHMvc2VyaWFsaXplci50c1xuZnVuY3Rpb24gc2VyaWFsaXplKGluY2x1ZGVTaWcgPSBmYWxzZSwgaW5jbHVkZUlkID0gZmFsc2UpIHtcbiAgY29uc3QgcGF5bG9hZCA9IFswLCB0aGlzLnB1YmtleSwgdGhpcy5jcmVhdGVkX2F0LCB0aGlzLmtpbmQsIHRoaXMudGFncywgdGhpcy5jb250ZW50XTtcbiAgaWYgKGluY2x1ZGVTaWcpIHBheWxvYWQucHVzaCh0aGlzLnNpZyk7XG4gIGlmIChpbmNsdWRlSWQpIHBheWxvYWQucHVzaCh0aGlzLmlkKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZEV2ZW50KSB7XG4gIGNvbnN0IGV2ZW50QXJyYXkgPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWRFdmVudCk7XG4gIGNvbnN0IHJldCA9IHtcbiAgICBwdWJrZXk6IGV2ZW50QXJyYXlbMV0sXG4gICAgY3JlYXRlZF9hdDogZXZlbnRBcnJheVsyXSxcbiAgICBraW5kOiBldmVudEFycmF5WzNdLFxuICAgIHRhZ3M6IGV2ZW50QXJyYXlbNF0sXG4gICAgY29udGVudDogZXZlbnRBcnJheVs1XVxuICB9O1xuICBpZiAoZXZlbnRBcnJheS5sZW5ndGggPj0gNykgcmV0LnNpZyA9IGV2ZW50QXJyYXlbNl07XG4gIGlmIChldmVudEFycmF5Lmxlbmd0aCA+PSA4KSByZXQuaWQgPSBldmVudEFycmF5WzddO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBzcmMvZXZlbnRzL3ZhbGlkYXRpb24udHNcbmltcG9ydCB7IHNjaG5vcnIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBMUlVDYWNoZSB9IGZyb20gXCJ0eXBlc2NyaXB0LWxydS1jYWNoZVwiO1xuXG4vLyBzcmMvZXZlbnRzL3NpZ25hdHVyZS50c1xudmFyIHdvcmtlcjtcbnZhciBwcm9jZXNzaW5nUXVldWUgPSB7fTtcbmZ1bmN0aW9uIHNpZ25hdHVyZVZlcmlmaWNhdGlvbkluaXQodykge1xuICB3b3JrZXIgPSB3O1xuICB3b3JrZXIub25tZXNzYWdlID0gKG1zZykgPT4ge1xuICAgIGNvbnN0IFtldmVudElkLCByZXN1bHRdID0gbXNnLmRhdGE7XG4gICAgY29uc3QgcmVjb3JkID0gcHJvY2Vzc2luZ1F1ZXVlW2V2ZW50SWRdO1xuICAgIGlmICghcmVjb3JkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTm8gcmVjb3JkIGZvdW5kIGZvciBldmVudFwiLCBldmVudElkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHByb2Nlc3NpbmdRdWV1ZVtldmVudElkXTtcbiAgICBmb3IgKGNvbnN0IHJlc29sdmUgb2YgcmVjb3JkLnJlc29sdmVzKSB7XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlQXN5bmMoZXZlbnQsIF9wZXJzaXN0KSB7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBldmVudC5zZXJpYWxpemUoKTtcbiAgICBsZXQgZW5xdWV1ZSA9IGZhbHNlO1xuICAgIGlmICghcHJvY2Vzc2luZ1F1ZXVlW2V2ZW50LmlkXSkge1xuICAgICAgcHJvY2Vzc2luZ1F1ZXVlW2V2ZW50LmlkXSA9IHsgZXZlbnQsIHJlc29sdmVzOiBbXSB9O1xuICAgICAgZW5xdWV1ZSA9IHRydWU7XG4gICAgfVxuICAgIHByb2Nlc3NpbmdRdWV1ZVtldmVudC5pZF0ucmVzb2x2ZXMucHVzaChyZXNvbHZlKTtcbiAgICBpZiAoIWVucXVldWUpIHJldHVybjtcbiAgICB3b3JrZXI/LnBvc3RNZXNzYWdlKHtcbiAgICAgIHNlcmlhbGl6ZWQsXG4gICAgICBpZDogZXZlbnQuaWQsXG4gICAgICBzaWc6IGV2ZW50LnNpZyxcbiAgICAgIHB1YmtleTogZXZlbnQucHVia2V5XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gc3JjL2V2ZW50cy92YWxpZGF0aW9uLnRzXG52YXIgUFVCS0VZX1JFR0VYID0gL15bYS1mMC05XXs2NH0kLztcbmZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICBpZiAodHlwZW9mIHRoaXMua2luZCAhPT0gXCJudW1iZXJcIikgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHRoaXMuY29udGVudCAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHRoaXMuY3JlYXRlZF9hdCAhPT0gXCJudW1iZXJcIikgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHRoaXMucHVia2V5ICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG4gIGlmICghdGhpcy5wdWJrZXkubWF0Y2goUFVCS0VZX1JFR0VYKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy50YWdzKSkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGFncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnc1tpXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFnKSkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFnLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAodHlwZW9mIHRhZ1tqXSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbnZhciB2ZXJpZmllZFNpZ25hdHVyZXMgPSBuZXcgTFJVQ2FjaGUoe1xuICBtYXhTaXplOiAxZTMsXG4gIGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TOiA2ZTRcbn0pO1xuZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlKHBlcnNpc3QpIHtcbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkID09PSBcImJvb2xlYW5cIikgcmV0dXJuIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQ7XG4gIGNvbnN0IHByZXZWZXJpZmljYXRpb24gPSB2ZXJpZmllZFNpZ25hdHVyZXMuZ2V0KHRoaXMuaWQpO1xuICBpZiAocHJldlZlcmlmaWNhdGlvbiAhPT0gbnVsbCkge1xuICAgIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQgPSAhIXByZXZWZXJpZmljYXRpb247XG4gICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQ7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAodGhpcy5uZGs/LmFzeW5jU2lnVmVyaWZpY2F0aW9uKSB7XG4gICAgICB2ZXJpZnlTaWduYXR1cmVBc3luYyh0aGlzLCBwZXJzaXN0KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKHBlcnNpc3QpIHtcbiAgICAgICAgICB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkID0gcmVzdWx0O1xuICAgICAgICAgIGlmIChyZXN1bHQpIHZlcmlmaWVkU2lnbmF0dXJlcy5zZXQodGhpcy5pZCwgdGhpcy5zaWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgdGhpcy5uZGs/LmVtaXQoXCJldmVudDppbnZhbGlkLXNpZ1wiLCB0aGlzKTtcbiAgICAgICAgICB2ZXJpZmllZFNpZ25hdHVyZXMuc2V0KHRoaXMuaWQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhhc2ggPSBzaGEyNTYobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRoaXMuc2VyaWFsaXplKCkpKTtcbiAgICAgIGNvbnN0IHJlcyA9IHNjaG5vcnIudmVyaWZ5KHRoaXMuc2lnLCBoYXNoLCB0aGlzLnB1YmtleSk7XG4gICAgICBpZiAocmVzKSB2ZXJpZmllZFNpZ25hdHVyZXMuc2V0KHRoaXMuaWQsIHRoaXMuc2lnKTtcbiAgICAgIGVsc2UgdmVyaWZpZWRTaWduYXR1cmVzLnNldCh0aGlzLmlkLCBmYWxzZSk7XG4gICAgICB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkID0gcmVzO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRFdmVudEhhc2goKSB7XG4gIHJldHVybiBnZXRFdmVudEhhc2hGcm9tU2VyaWFsaXplZEV2ZW50KHRoaXMuc2VyaWFsaXplKCkpO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRIYXNoRnJvbVNlcmlhbGl6ZWRFdmVudChzZXJpYWxpemVkRXZlbnQpIHtcbiAgY29uc3QgZXZlbnRIYXNoID0gc2hhMjU2KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzZXJpYWxpemVkRXZlbnQpKTtcbiAgcmV0dXJuIGJ5dGVzVG9IZXgoZXZlbnRIYXNoKTtcbn1cblxuLy8gc3JjL2V2ZW50cy9pbmRleC50c1xudmFyIHNraXBDbGllbnRUYWdPbktpbmRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAwIC8qIE1ldGFkYXRhICovLFxuICA0IC8qIEVuY3J5cHRlZERpcmVjdE1lc3NhZ2UgKi8sXG4gIDEwNTkgLyogR2lmdFdyYXAgKi8sXG4gIDEzIC8qIEdpZnRXcmFwU2VhbCAqLyxcbiAgMyAvKiBDb250YWN0cyAqLyxcbiAgOTczNCAvKiBaYXBSZXF1ZXN0ICovLFxuICA1IC8qIEV2ZW50RGVsZXRpb24gKi9cbl0pO1xudmFyIE5ES0V2ZW50ID0gY2xhc3MgX05ES0V2ZW50IGV4dGVuZHMgRXZlbnRFbWl0dGVyMiB7XG4gIG5kaztcbiAgY3JlYXRlZF9hdDtcbiAgY29udGVudCA9IFwiXCI7XG4gIHRhZ3MgPSBbXTtcbiAga2luZDtcbiAgaWQgPSBcIlwiO1xuICBzaWc7XG4gIHB1YmtleSA9IFwiXCI7XG4gIHNpZ25hdHVyZVZlcmlmaWVkO1xuICBfYXV0aG9yID0gdm9pZCAwO1xuICAvKipcbiAgICogVGhlIHJlbGF5IHRoYXQgdGhpcyBldmVudCB3YXMgZmlyc3QgcmVjZWl2ZWQgZnJvbS5cbiAgICovXG4gIHJlbGF5O1xuICAvKipcbiAgICogVGhlIHJlbGF5cyB0aGF0IHRoaXMgZXZlbnQgd2FzIHJlY2VpdmVkIGZyb20gYW5kL29yIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQgdG8uXG4gICAqL1xuICBnZXQgb25SZWxheXMoKSB7XG4gICAgbGV0IHJlcyA9IFtdO1xuICAgIGlmICghdGhpcy5uZGspIHtcbiAgICAgIGlmICh0aGlzLnJlbGF5KSByZXMucHVzaCh0aGlzLnJlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gdGhpcy5uZGsuc3ViTWFuYWdlci5zZWVuRXZlbnRzLmdldCh0aGlzLmlkKSB8fCBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICAvKipcbiAgICogVGhlIHN0YXR1cyBvZiB0aGUgcHVibGlzaCBvcGVyYXRpb24uXG4gICAqL1xuICBwdWJsaXNoU3RhdHVzID0gXCJzdWNjZXNzXCI7XG4gIHB1Ymxpc2hFcnJvcjtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5jcmVhdGVkX2F0ID0gZXZlbnQ/LmNyZWF0ZWRfYXQ7XG4gICAgdGhpcy5jb250ZW50ID0gZXZlbnQ/LmNvbnRlbnQgfHwgXCJcIjtcbiAgICB0aGlzLnRhZ3MgPSBldmVudD8udGFncyB8fCBbXTtcbiAgICB0aGlzLmlkID0gZXZlbnQ/LmlkIHx8IFwiXCI7XG4gICAgdGhpcy5zaWcgPSBldmVudD8uc2lnO1xuICAgIHRoaXMucHVia2V5ID0gZXZlbnQ/LnB1YmtleSB8fCBcIlwiO1xuICAgIHRoaXMua2luZCA9IGV2ZW50Py5raW5kO1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIF9OREtFdmVudCkge1xuICAgICAgaWYgKHRoaXMucmVsYXkpIHtcbiAgICAgICAgdGhpcy5yZWxheSA9IGV2ZW50LnJlbGF5O1xuICAgICAgICB0aGlzLm5kaz8uc3ViTWFuYWdlci5zZWVuRXZlbnQoZXZlbnQuaWQsIHRoaXMucmVsYXkpO1xuICAgICAgfVxuICAgICAgdGhpcy5wdWJsaXNoU3RhdHVzID0gZXZlbnQucHVibGlzaFN0YXR1cztcbiAgICAgIHRoaXMucHVibGlzaEVycm9yID0gZXZlbnQucHVibGlzaEVycm9yO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemUgYW4gTkRLRXZlbnQgZnJvbSBhIHNlcmlhbGl6ZWQgcGF5bG9hZC5cbiAgICogQHBhcmFtIG5ka1xuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHJldHVybnNcbiAgICovXG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShuZGssIGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRXZlbnQobmRrLCBkZXNlcmlhbGl6ZShldmVudCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBldmVudCBhcyBpcy5cbiAgICovXG4gIHJhd0V2ZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVkX2F0OiB0aGlzLmNyZWF0ZWRfYXQsXG4gICAgICBjb250ZW50OiB0aGlzLmNvbnRlbnQsXG4gICAgICB0YWdzOiB0aGlzLnRhZ3MsXG4gICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICBwdWJrZXk6IHRoaXMucHVia2V5LFxuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBzaWc6IHRoaXMuc2lnXG4gICAgfTtcbiAgfVxuICBzZXQgYXV0aG9yKHVzZXIpIHtcbiAgICB0aGlzLnB1YmtleSA9IHVzZXIucHVia2V5O1xuICAgIHRoaXMuX2F1dGhvciA9IHVzZXI7XG4gICAgdGhpcy5fYXV0aG9yLm5kayA/Pz0gdGhpcy5uZGs7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gTkRLVXNlciBmb3IgdGhlIGF1dGhvciBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBnZXQgYXV0aG9yKCkge1xuICAgIGlmICh0aGlzLl9hdXRob3IpIHJldHVybiB0aGlzLl9hdXRob3I7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGNvbnN0IHVzZXIgPSB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5OiB0aGlzLnB1YmtleSB9KTtcbiAgICB0aGlzLl9hdXRob3IgPSB1c2VyO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIC8qKlxuICAgKiBOSVAtNzMgdGFnZ2luZyBvZiBleHRlcm5hbCBlbnRpdGllc1xuICAgKiBAcGFyYW0gZW50aXR5IHRvIGJlIHRhZ2dlZFxuICAgKiBAcGFyYW0gdHlwZSBvZiB0aGUgZW50aXR5XG4gICAqIEBwYXJhbSBtYXJrZXJVcmwgdG8gYmUgdXNlZCBhcyB0aGUgbWFya2VyIFVSTFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGV2ZW50LnRhZ0V4dGVybmFsKFwiaHR0cHM6Ly9leGFtcGxlLmNvbS9hcnRpY2xlLzEyMyNub3N0clwiLCBcInVybFwiKTtcbiAgICogZXZlbnQudGFncyA9PiBbW1wiaVwiLCBcImh0dHBzOi8vZXhhbXBsZS5jb20vMTIzXCJdLCBbXCJrXCIsIFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiXV1cbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlIHRhZyBhIHBvZGNhc3Q6aXRlbTpndWlkXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogZXZlbnQudGFnRXh0ZXJuYWwoXCJlMzJiNDg5MC1iOWVhLTRhZWYtYTBiZi01NGI3ODc4MzNkYzVcIiwgXCJwb2RjYXN0Oml0ZW06Z3VpZFwiKTtcbiAgICogZXZlbnQudGFncyA9PiBbW1wiaVwiLCBcInBvZGNhc3Q6aXRlbTpndWlkOmUzMmI0ODkwLWI5ZWEtNGFlZi1hMGJmLTU0Yjc4NzgzM2RjNVwiXSwgW1wia1wiLCBcInBvZGNhc3Q6aXRlbTpndWlkXCJdXVxuICAgKiBgYGBcbiAgICpcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9zdHItcHJvdG9jb2wvbmlwcy9ibG9iL21hc3Rlci83My5tZFxuICAgKi9cbiAgdGFnRXh0ZXJuYWwoZW50aXR5LCB0eXBlLCBtYXJrZXJVcmwpIHtcbiAgICBjb25zdCBpVGFnID0gW1wiaVwiXTtcbiAgICBjb25zdCBrVGFnID0gW1wia1wiXTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJ1cmxcIjoge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGVudGl0eSk7XG4gICAgICAgIHVybC5oYXNoID0gXCJcIjtcbiAgICAgICAgaVRhZy5wdXNoKHVybC50b1N0cmluZygpKTtcbiAgICAgICAga1RhZy5wdXNoKGAke3VybC5wcm90b2NvbH0vLyR7dXJsLmhvc3R9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImhhc2h0YWdcIjpcbiAgICAgICAgaVRhZy5wdXNoKGAjJHtlbnRpdHkudG9Mb3dlckNhc2UoKX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwiI1wiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZ2VvaGFzaFwiOlxuICAgICAgICBpVGFnLnB1c2goYGdlbzoke2VudGl0eS50b0xvd2VyQ2FzZSgpfWApO1xuICAgICAgICBrVGFnLnB1c2goXCJnZW9cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlzYm5cIjpcbiAgICAgICAgaVRhZy5wdXNoKGBpc2JuOiR7ZW50aXR5LnJlcGxhY2UoLy0vZywgXCJcIil9YCk7XG4gICAgICAgIGtUYWcucHVzaChcImlzYm5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvZGNhc3Q6Z3VpZFwiOlxuICAgICAgICBpVGFnLnB1c2goYHBvZGNhc3Q6Z3VpZDoke2VudGl0eX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwicG9kY2FzdDpndWlkXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb2RjYXN0Oml0ZW06Z3VpZFwiOlxuICAgICAgICBpVGFnLnB1c2goYHBvZGNhc3Q6aXRlbTpndWlkOiR7ZW50aXR5fWApO1xuICAgICAgICBrVGFnLnB1c2goXCJwb2RjYXN0Oml0ZW06Z3VpZFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicG9kY2FzdDpwdWJsaXNoZXI6Z3VpZFwiOlxuICAgICAgICBpVGFnLnB1c2goYHBvZGNhc3Q6cHVibGlzaGVyOmd1aWQ6JHtlbnRpdHl9YCk7XG4gICAgICAgIGtUYWcucHVzaChcInBvZGNhc3Q6cHVibGlzaGVyOmd1aWRcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlzYW5cIjpcbiAgICAgICAgaVRhZy5wdXNoKGBpc2FuOiR7ZW50aXR5LnNwbGl0KFwiLVwiKS5zbGljZSgwLCA0KS5qb2luKFwiLVwiKX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwiaXNhblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZG9pXCI6XG4gICAgICAgIGlUYWcucHVzaChgZG9pOiR7ZW50aXR5LnRvTG93ZXJDYXNlKCl9YCk7XG4gICAgICAgIGtUYWcucHVzaChcImRvaVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE5JUC03MyBlbnRpdHkgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgICBpZiAobWFya2VyVXJsKSB7XG4gICAgICBpVGFnLnB1c2gobWFya2VyVXJsKTtcbiAgICB9XG4gICAgdGhpcy50YWdzLnB1c2goaVRhZyk7XG4gICAgdGhpcy50YWdzLnB1c2goa1RhZyk7XG4gIH1cbiAgLyoqXG4gICAqIFRhZyBhIHVzZXIgd2l0aCBhbiBvcHRpb25hbCBtYXJrZXIuXG4gICAqIEBwYXJhbSB0YXJnZXQgV2hhdCBpcyB0byBiZSB0YWdnZWQuIENhbiBiZSBhbiBOREtVc2VyLCBOREtFdmVudCwgb3IgYW4gTkRLVGFnLlxuICAgKiBAcGFyYW0gbWFya2VyIFRoZSBtYXJrZXIgdG8gdXNlIGluIHRoZSB0YWcuXG4gICAqIEBwYXJhbSBza2lwQXV0aG9yVGFnIFdoZXRoZXIgdG8gZXhwbGljaXRseSBza2lwIGFkZGluZyB0aGUgYXV0aG9yIHRhZyBvZiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSBmb3JjZVRhZyBGb3JjZSBhIHNwZWNpZmljIHRhZyB0byBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgXCJlXCIgb3IgXCJhXCIgdGFnLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIHJlcGx5LnRhZyhvcEV2ZW50LCBcInJlcGx5XCIpO1xuICAgKiAvLyByZXBseS50YWdzID0+IFtbXCJlXCIsIDxpZD4sIDxyZWxheT4sIFwicmVwbHlcIl1dXG4gICAqIGBgYFxuICAgKi9cbiAgdGFnKHRhcmdldCwgbWFya2VyLCBza2lwQXV0aG9yVGFnLCBmb3JjZVRhZykge1xuICAgIGxldCB0YWdzID0gW107XG4gICAgY29uc3QgaXNOREtVc2VyID0gdGFyZ2V0LmZldGNoUHJvZmlsZSAhPT0gdm9pZCAwO1xuICAgIGlmIChpc05ES1VzZXIpIHtcbiAgICAgIGZvcmNlVGFnID8/PSBcInBcIjtcbiAgICAgIGNvbnN0IHRhZyA9IFtmb3JjZVRhZywgdGFyZ2V0LnB1YmtleV07XG4gICAgICBpZiAobWFya2VyKSB0YWcucHVzaCguLi5bXCJcIiwgbWFya2VyXSk7XG4gICAgICB0YWdzLnB1c2godGFnKTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIF9OREtFdmVudCkge1xuICAgICAgY29uc3QgZXZlbnQgPSB0YXJnZXQ7XG4gICAgICBza2lwQXV0aG9yVGFnID8/PSBldmVudD8ucHVia2V5ID09PSB0aGlzLnB1YmtleTtcbiAgICAgIHRhZ3MgPSBldmVudC5yZWZlcmVuY2VUYWdzKG1hcmtlciwgc2tpcEF1dGhvclRhZywgZm9yY2VUYWcpO1xuICAgICAgZm9yIChjb25zdCBwVGFnIG9mIGV2ZW50LmdldE1hdGNoaW5nVGFncyhcInBcIikpIHtcbiAgICAgICAgaWYgKHBUYWdbMV0gPT09IHRoaXMucHVia2V5KSBjb250aW51ZTtcbiAgICAgICAgaWYgKHRoaXMudGFncy5maW5kKCh0KSA9PiB0WzBdID09PSBcInBcIiAmJiB0WzFdID09PSBwVGFnWzFdKSkgY29udGludWU7XG4gICAgICAgIHRoaXMudGFncy5wdXNoKFtcInBcIiwgcFRhZ1sxXV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICB0YWdzID0gW3RhcmdldF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIiwgdGFyZ2V0KTtcbiAgICB9XG4gICAgdGhpcy50YWdzID0gbWVyZ2VUYWdzKHRoaXMudGFncywgdGFncyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIE5vc3RyRXZlbnQgb2JqZWN0LCB0cnlpbmcgdG8gZmlsbCBpbiBtaXNzaW5nIGZpZWxkc1xuICAgKiB3aGVuIHBvc3NpYmxlLCBhZGRpbmcgdGFncyB3aGVuIG5lY2Vzc2FyeS5cbiAgICogQHBhcmFtIHB1YmtleSB7c3RyaW5nfSBUaGUgcHVia2V5IG9mIHRoZSB1c2VyIHdobyB0aGUgZXZlbnQgYmVsb25ncyB0by5cbiAgICogQHJldHVybnMge1Byb21pc2U8Tm9zdHJFdmVudD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgTm9zdHJFdmVudC5cbiAgICovXG4gIGFzeW5jIHRvTm9zdHJFdmVudChwdWJrZXkpIHtcbiAgICBpZiAoIXB1YmtleSAmJiB0aGlzLnB1YmtleSA9PT0gXCJcIikge1xuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrPy5zaWduZXI/LnVzZXIoKTtcbiAgICAgIHRoaXMucHVia2V5ID0gdXNlcj8ucHVia2V5IHx8IFwiXCI7XG4gICAgfVxuICAgIGlmICghdGhpcy5jcmVhdGVkX2F0KSB7XG4gICAgICB0aGlzLmNyZWF0ZWRfYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnRlbnQsIHRhZ3MgfSA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVUYWdzKCk7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudCB8fCBcIlwiO1xuICAgIHRoaXMudGFncyA9IHRhZ3M7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLmdldEV2ZW50SGFzaCgpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJhd0V2ZW50KCk7XG4gIH1cbiAgc2VyaWFsaXplID0gc2VyaWFsaXplLmJpbmQodGhpcyk7XG4gIGdldEV2ZW50SGFzaCA9IGdldEV2ZW50SGFzaC5iaW5kKHRoaXMpO1xuICB2YWxpZGF0ZSA9IHZhbGlkYXRlLmJpbmQodGhpcyk7XG4gIHZlcmlmeVNpZ25hdHVyZSA9IHZlcmlmeVNpZ25hdHVyZS5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogSXMgdGhpcyBldmVudCByZXBsYWNlYWJsZSAod2hldGhlciBwYXJhbWV0ZXJpemVkIG9yIG5vdCk/XG4gICAqXG4gICAqIFRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBmb3Iga2luZCAwLCAzLCAxMGstMjBrIGFuZCAzMGstNDBrXG4gICAqL1xuICBpc1JlcGxhY2VhYmxlID0gaXNSZXBsYWNlYWJsZS5iaW5kKHRoaXMpO1xuICBpc0VwaGVtZXJhbCA9IGlzRXBoZW1lcmFsLmJpbmQodGhpcyk7XG4gIGlzRHZtID0gKCkgPT4gdGhpcy5raW5kICYmIHRoaXMua2luZCA+PSA1ZTMgJiYgdGhpcy5raW5kIDw9IDdlMztcbiAgLyoqXG4gICAqIElzIHRoaXMgZXZlbnQgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZT9cbiAgICpcbiAgICogVGhpcyB3aWxsIHJldHVybiB0cnVlIGZvciBraW5kIDMway00MGtcbiAgICovXG4gIGlzUGFyYW1SZXBsYWNlYWJsZSA9IGlzUGFyYW1SZXBsYWNlYWJsZS5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogRW5jb2RlcyBhIGJlY2gzMiBpZC5cbiAgICpcbiAgICogQHBhcmFtIHJlbGF5cyB7c3RyaW5nW119IFRoZSByZWxheXMgdG8gZW5jb2RlIGluIHRoZSBpZFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIEVuY29kZWQgbmFkZHIsIG5vdGUgb3IgbmV2ZW50LlxuICAgKi9cbiAgZW5jb2RlID0gZW5jb2RlLmJpbmQodGhpcyk7XG4gIGVuY3J5cHQgPSBlbmNyeXB0LmJpbmQodGhpcyk7XG4gIGRlY3J5cHQgPSBkZWNyeXB0LmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBHZXQgYWxsIHRhZ3Mgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKiBAcGFyYW0gdGFnTmFtZSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgdGFnIHRvIHNlYXJjaCBmb3JcbiAgICogQHJldHVybnMge05ES1RhZ1tdfSBBbiBhcnJheSBvZiB0aGUgbWF0Y2hpbmcgdGFnc1xuICAgKi9cbiAgZ2V0TWF0Y2hpbmdUYWdzKHRhZ05hbWUsIG1hcmtlcikge1xuICAgIGNvbnN0IHQgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gdGFnTmFtZSk7XG4gICAgaWYgKG1hcmtlciA9PT0gdm9pZCAwKSByZXR1cm4gdDtcbiAgICByZXR1cm4gdC5maWx0ZXIoKHRhZykgPT4gdGFnWzNdID09PSBtYXJrZXIpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZXZlbnQgaGFzIGEgdGFnIHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICogQHBhcmFtIHRhZ05hbWVcbiAgICogQHBhcmFtIG1hcmtlclxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgaGFzVGFnKHRhZ05hbWUsIG1hcmtlcikge1xuICAgIHJldHVybiB0aGlzLnRhZ3Muc29tZSgodGFnKSA9PiB0YWdbMF0gPT09IHRhZ05hbWUgJiYgKCFtYXJrZXIgfHwgdGFnWzNdID09PSBtYXJrZXIpKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBmaXJzdCB0YWcgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKiBAcGFyYW0gdGFnTmFtZSBUYWcgbmFtZSB0byBzZWFyY2ggZm9yXG4gICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgdGFnIHdpdGggdGhlIGdpdmVuIG5hbWUsIG9yIHVuZGVmaW5lZCBpZiBubyBzdWNoIHRhZyBleGlzdHNcbiAgICovXG4gIHRhZ1ZhbHVlKHRhZ05hbWUpIHtcbiAgICBjb25zdCB0YWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3ModGFnTmFtZSk7XG4gICAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiB0YWdzWzBdWzFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBOSVAtMzEgXCJhbHRcIiB0YWcgb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgZ2V0IGFsdCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImFsdFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgTklQLTMxIFwiYWx0XCIgdGFnIG9mIHRoZSBldmVudC4gVXNlIHRoaXMgdG8gc2V0IGFuIGFsdCB0YWcgc29cbiAgICogY2xpZW50cyB0aGF0IGRvbid0IGhhbmRsZSBhIHBhcnRpY3VsYXIgZXZlbnQga2luZCBjYW4gZGlzcGxheSBzb21ldGhpbmdcbiAgICogdXNlZnVsIGZvciB1c2Vycy5cbiAgICovXG4gIHNldCBhbHQoYWx0KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhbHRcIik7XG4gICAgaWYgKGFsdCkgdGhpcy50YWdzLnB1c2goW1wiYWx0XCIsIGFsdF0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBOSVAtMzMgXCJkXCIgdGFnIG9mIHRoZSBldmVudC5cbiAgICovXG4gIGdldCBkVGFnKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgTklQLTMzIFwiZFwiIHRhZyBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBzZXQgZFRhZyh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZFwiKTtcbiAgICBpZiAodmFsdWUpIHRoaXMudGFncy5wdXNoKFtcImRcIiwgdmFsdWVdKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB0YWdzIHdpdGggdGhlIGdpdmVuIG5hbWUgKGUuZy4gXCJkXCIsIFwiYVwiLCBcInBcIilcbiAgICogQHBhcmFtIHRhZ05hbWUgVGFnIG5hbWUocykgdG8gc2VhcmNoIGZvciBhbmQgcmVtb3ZlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcmVtb3ZlVGFnKHRhZ05hbWUpIHtcbiAgICBjb25zdCB0YWdOYW1lcyA9IEFycmF5LmlzQXJyYXkodGFnTmFtZSkgPyB0YWdOYW1lIDogW3RhZ05hbWVdO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gIXRhZ05hbWVzLmluY2x1ZGVzKHRhZ1swXSkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlIGEgdGFnIHdpdGggYSBuZXcgdmFsdWUuIElmIG5vdCBmb3VuZCwgaXQgd2lsbCBiZSBhZGRlZC5cbiAgICogQHBhcmFtIHRhZyBUaGUgdGFnIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgbmV3IHZhbHVlIGZvciB0aGUgdGFnLlxuICAgKi9cbiAgcmVwbGFjZVRhZyh0YWcpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyh0YWdbMF0pO1xuICAgIHRoaXMudGFncy5wdXNoKHRhZyk7XG4gIH1cbiAgLyoqXG4gICAqIFNpZ24gdGhlIGV2ZW50IGlmIGEgc2lnbmVyIGlzIHByZXNlbnQuXG4gICAqXG4gICAqIEl0IHdpbGwgZ2VuZXJhdGUgdGFncy5cbiAgICogUmVwbGVhY2FibGUgZXZlbnRzIHdpbGwgaGF2ZSB0aGVpciBjcmVhdGVkX2F0IGZpZWxkIHNldCB0byB0aGUgY3VycmVudCB0aW1lLlxuICAgKiBAcGFyYW0gc2lnbmVyIHtOREtTaWduZXJ9IFRoZSBOREtTaWduZXIgdG8gdXNlIHRvIHNpZ24gdGhlIGV2ZW50XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzaWduYXR1cmUgb2YgdGhlIHNpZ25lZCBldmVudC5cbiAgICovXG4gIGFzeW5jIHNpZ24oc2lnbmVyKSB7XG4gICAgaWYgKCFzaWduZXIpIHtcbiAgICAgIHRoaXMubmRrPy5hc3NlcnRTaWduZXIoKTtcbiAgICAgIHNpZ25lciA9IHRoaXMubmRrPy5zaWduZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXV0aG9yID0gYXdhaXQgc2lnbmVyLnVzZXIoKTtcbiAgICB9XG4gICAgY29uc3Qgbm9zdHJFdmVudCA9IGF3YWl0IHRoaXMudG9Ob3N0ckV2ZW50KCk7XG4gICAgdGhpcy5zaWcgPSBhd2FpdCBzaWduZXIuc2lnbihub3N0ckV2ZW50KTtcbiAgICByZXR1cm4gdGhpcy5zaWc7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSByZWxheVNldFxuICAgKiBAcGFyYW0gdGltZW91dE1zXG4gICAqIEBwYXJhbSByZXF1aXJlZFJlbGF5Q291bnRcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHB1Ymxpc2hSZXBsYWNlYWJsZShyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICB0aGlzLmlkID0gXCJcIjtcbiAgICB0aGlzLmNyZWF0ZWRfYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICAgIHRoaXMuc2lnID0gXCJcIjtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gc2lnbiBhbmQgdGhlbiBwdWJsaXNoIGFuIE5ES0V2ZW50IHRvIGEgZ2l2ZW4gcmVsYXlTZXQuXG4gICAqIElmIG5vIHJlbGF5U2V0IGlzIHByb3ZpZGVkLCB0aGUgcmVsYXlTZXQgd2lsbCBiZSBjYWxjdWxhdGVkIGJ5IE5ESy5cbiAgICogQHBhcmFtIHJlbGF5U2V0IHtOREtSZWxheVNldH0gVGhlIHJlbGF5U2V0IHRvIHB1Ymxpc2ggdGhlIGV2ZW4gdG8uXG4gICAqIEBwYXJhbSB0aW1lb3V0TSB7bnVtYmVyfSBUaGUgdGltZW91dCBmb3IgdGhlIHB1Ymxpc2ggb3BlcmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHJlcXVpcmVkUmVsYXlDb3VudCBUaGUgbnVtYmVyIG9mIHJlbGF5cyB0aGF0IG11c3QgcmVjZWl2ZSB0aGUgZXZlbnQgZm9yIHRoZSBwdWJsaXNoIHRvIGJlIGNvbnNpZGVyZWQgc3VjY2Vzc2Z1bC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlbGF5cyB0aGUgZXZlbnQgd2FzIHB1Ymxpc2hlZCB0by5cbiAgICovXG4gIGFzeW5jIHB1Ymxpc2gocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KSB7XG4gICAgaWYgKCF0aGlzLnNpZykgYXdhaXQgdGhpcy5zaWduKCk7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLRXZlbnQgbXVzdCBiZSBhc3NvY2lhdGVkIHdpdGggYW4gTkRLIGluc3RhbmNlIHRvIHB1Ymxpc2hcIik7XG4gICAgaWYgKCFyZWxheVNldCB8fCByZWxheVNldC5zaXplID09PSAwKSB7XG4gICAgICByZWxheVNldCA9IHRoaXMubmRrLmRldldyaXRlUmVsYXlTZXQgfHwgYXdhaXQgY2FsY3VsYXRlUmVsYXlTZXRGcm9tRXZlbnQodGhpcy5uZGssIHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSA1IC8qIEV2ZW50RGVsZXRpb24gKi8gJiYgdGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5kZWxldGVFdmVudElkcykge1xuICAgICAgY29uc3QgZVRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gICAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZGVsZXRlRXZlbnRJZHMoZVRhZ3MpO1xuICAgIH1cbiAgICBjb25zdCByYXdFdmVudCA9IHRoaXMucmF3RXZlbnQoKTtcbiAgICBpZiAodGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5hZGRVbnB1Ymxpc2hlZEV2ZW50ICYmIHNob3VsZFRyYWNrVW5wdWJsaXNoZWRFdmVudCh0aGlzKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmFkZFVucHVibGlzaGVkRXZlbnQodGhpcywgcmVsYXlTZXQucmVsYXlVcmxzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFkZGluZyB1bnB1Ymxpc2hlZCBldmVudCB0byBjYWNoZVwiLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gNSAvKiBFdmVudERlbGV0aW9uICovICYmIHRoaXMubmRrLmNhY2hlQWRhcHRlcj8uZGVsZXRlRXZlbnRJZHMpIHtcbiAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5kZWxldGVFdmVudElkcyh0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSkpO1xuICAgIH1cbiAgICB0aGlzLm5kay5zdWJNYW5hZ2VyLmRpc3BhdGNoRXZlbnQocmF3RXZlbnQsIHZvaWQgMCwgdHJ1ZSk7XG4gICAgY29uc3QgcmVsYXlzID0gYXdhaXQgcmVsYXlTZXQucHVibGlzaCh0aGlzLCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gICAgcmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB0aGlzLm5kaz8uc3ViTWFuYWdlci5zZWVuRXZlbnQodGhpcy5pZCwgcmVsYXkpKTtcbiAgICByZXR1cm4gcmVsYXlzO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGFncyBmb3IgdXNlcnMsIG5vdGVzLCBhbmQgb3RoZXIgZXZlbnRzIHRhZ2dlZCBpbiBjb250ZW50LlxuICAgKiBXaWxsIGFsc28gZ2VuZXJhdGUgcmFuZG9tIFwiZFwiIHRhZyBmb3IgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudHMgd2hlcmUgbmVlZGVkLlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gVGhlIHRhZ3MgYW5kIGNvbnRlbnQgb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVUYWdzKCkge1xuICAgIGxldCB0YWdzID0gW107XG4gICAgY29uc3QgZyA9IGF3YWl0IGdlbmVyYXRlQ29udGVudFRhZ3ModGhpcy5jb250ZW50LCB0aGlzLnRhZ3MpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBnLmNvbnRlbnQ7XG4gICAgdGFncyA9IGcudGFncztcbiAgICBpZiAodGhpcy5raW5kICYmIHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIGNvbnN0IGRUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImRcIilbMF07XG4gICAgICBpZiAoIWRUYWcpIHtcbiAgICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLnRhZ1ZhbHVlKFwidGl0bGVcIik7XG4gICAgICAgIGNvbnN0IHJhbmRMZW5ndGggPSB0aXRsZSA/IDYgOiAxNjtcbiAgICAgICAgbGV0IHN0ciA9IFsuLi5BcnJheShyYW5kTGVuZ3RoKV0ubWFwKCgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpWzJdKS5qb2luKFwiXCIpO1xuICAgICAgICBpZiAodGl0bGUgJiYgdGl0bGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0ciA9IGAke3RpdGxlLnJlcGxhY2UoL1teYS16MC05XSsvZ2ksIFwiLVwiKS5yZXBsYWNlKC9eLXwtJC9nLCBcIlwiKX0tJHtzdHJ9YDtcbiAgICAgICAgfVxuICAgICAgICB0YWdzLnB1c2goW1wiZFwiLCBzdHJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc2hvdWxkQWRkQ2xpZW50VGFnKSB7XG4gICAgICBjb25zdCBjbGllbnRUYWcgPSBbXCJjbGllbnRcIiwgdGhpcy5uZGs/LmNsaWVudE5hbWUgPz8gXCJcIl07XG4gICAgICBpZiAodGhpcy5uZGs/LmNsaWVudE5pcDg5KSBjbGllbnRUYWcucHVzaCh0aGlzLm5kaz8uY2xpZW50TmlwODkpO1xuICAgICAgdGFncy5wdXNoKGNsaWVudFRhZyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNob3VsZFN0cmlwQ2xpZW50VGFnKSB7XG4gICAgICB0YWdzID0gdGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcImNsaWVudFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29udGVudDogY29udGVudCB8fCBcIlwiLCB0YWdzIH07XG4gIH1cbiAgZ2V0IHNob3VsZEFkZENsaWVudFRhZygpIHtcbiAgICBpZiAoIXRoaXMubmRrPy5jbGllbnROYW1lICYmICF0aGlzLm5kaz8uY2xpZW50TmlwODkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoc2tpcENsaWVudFRhZ09uS2luZHMuaGFzKHRoaXMua2luZCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5pc0VwaGVtZXJhbCgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuaXNSZXBsYWNlYWJsZSgpICYmICF0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuaXNEdm0oKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLmhhc1RhZyhcImNsaWVudFwiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCBzaG91bGRTdHJpcENsaWVudFRhZygpIHtcbiAgICByZXR1cm4gc2tpcENsaWVudFRhZ09uS2luZHMuaGFzKHRoaXMua2luZCk7XG4gIH1cbiAgbXV0ZWQoKSB7XG4gICAgY29uc3QgYXV0aG9yTXV0ZWRFbnRyeSA9IHRoaXMubmRrPy5tdXRlZElkcy5nZXQodGhpcy5wdWJrZXkpO1xuICAgIGlmIChhdXRob3JNdXRlZEVudHJ5ICYmIGF1dGhvck11dGVkRW50cnkgPT09IFwicFwiKSByZXR1cm4gXCJhdXRob3JcIjtcbiAgICBjb25zdCBldmVudFRhZ1JlZmVyZW5jZSA9IHRoaXMudGFnUmVmZXJlbmNlKCk7XG4gICAgY29uc3QgZXZlbnRNdXRlZEVudHJ5ID0gdGhpcy5uZGs/Lm11dGVkSWRzLmdldChldmVudFRhZ1JlZmVyZW5jZVsxXSk7XG4gICAgaWYgKGV2ZW50TXV0ZWRFbnRyeSAmJiBldmVudE11dGVkRW50cnkgPT09IGV2ZW50VGFnUmVmZXJlbmNlWzBdKSByZXR1cm4gXCJldmVudFwiO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBcImRcIiB0YWcgb2YgYSBwYXJhbWV0ZXJpemVkIHJlcGxhY2VhYmxlIGV2ZW50IG9yIHRocm93cyBhbiBlcnJvciBpZiB0aGUgZXZlbnQgaXNuJ3RcbiAgICogYSBwYXJhbWV0ZXJpemVkIHJlcGxhY2VhYmxlIGV2ZW50LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgXCJkXCIgdGFnIG9mIHRoZSBldmVudC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBkVGFnYCBpbnN0ZWFkLlxuICAgKi9cbiAgcmVwbGFjZWFibGVEVGFnKCkge1xuICAgIGlmICh0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDNlNCAmJiB0aGlzLmtpbmQgPD0gNGU0KSB7XG4gICAgICBjb25zdCBkVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJkXCIpWzBdO1xuICAgICAgY29uc3QgZFRhZ0lkID0gZFRhZyA/IGRUYWdbMV0gOiBcIlwiO1xuICAgICAgcmV0dXJuIGRUYWdJZDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgaXMgbm90IGEgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudFwiKTtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgYSBkZWR1cGxpY2F0aW9uIGtleSBmb3IgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBGb3Iga2luZHMgMCwgMywgMTBrLTIwayB0aGlzIHdpbGwgYmUgdGhlIGV2ZW50IDxraW5kPjo8cHVia2V5PlxuICAgKiBGb3Iga2luZHMgMzBrLTQwayB0aGlzIHdpbGwgYmUgdGhlIGV2ZW50IDxraW5kPjo8cHVia2V5Pjo8ZC10YWc+XG4gICAqIEZvciBhbGwgb3RoZXIga2luZHMgdGhpcyB3aWxsIGJlIHRoZSBldmVudCBpZFxuICAgKi9cbiAgZGVkdXBsaWNhdGlvbktleSgpIHtcbiAgICBpZiAodGhpcy5raW5kID09PSAwIHx8IHRoaXMua2luZCA9PT0gMyB8fCB0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDFlNCAmJiB0aGlzLmtpbmQgPCAyZTQpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLmtpbmR9OiR7dGhpcy5wdWJrZXl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGFnSWQoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaWQgb2YgdGhlIGV2ZW50IG9yLCBpZiBpdCdzIGEgcGFyYW1ldGVyaXplZCBldmVudCwgdGhlIGdlbmVyYXRlZCBpZCBvZiB0aGUgZXZlbnQgdXNpbmcgXCJkXCIgdGFnLCBwdWJrZXksIGFuZCBraW5kLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaWRcbiAgICovXG4gIHRhZ0lkKCkge1xuICAgIGlmICh0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWdBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RhYmxlIHJlZmVyZW5jZSB2YWx1ZSBmb3IgYSByZXBsYWNlYWJsZSBldmVudC5cbiAgICpcbiAgICogUGFyYW0gcmVwbGFjZWFibGUgZXZlbnRzIGFyZSByZXR1cm5lZCBpbiB0aGUgZXhwZWN0ZWQgZm9ybWF0IG9mIGA8a2luZD46PHB1YmtleT46PGQtdGFnPmAuXG4gICAqIEtpbmQtcmVwbGFjZWFibGUgZXZlbnRzIGFyZSByZXR1cm5lZCBpbiB0aGUgZm9ybWF0IG9mIGA8a2luZD46PHB1YmtleT46YC5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gQSBzdGFibGUgcmVmZXJlbmNlIHZhbHVlIGZvciByZXBsYWNlYWJsZSBldmVudHNcbiAgICovXG4gIHRhZ0FkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIGNvbnN0IGRUYWdJZCA9IHRoaXMuZFRhZyA/PyBcIlwiO1xuICAgICAgcmV0dXJuIGAke3RoaXMua2luZH06JHt0aGlzLnB1YmtleX06JHtkVGFnSWR9YDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNSZXBsYWNlYWJsZSgpKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5raW5kfToke3RoaXMucHVia2V5fTpgO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBpcyBub3QgYSByZXBsYWNlYWJsZSBldmVudFwiKTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgdHlwZSBvZiB0YWcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyBldmVudCBmcm9tIGFub3RoZXIgZXZlbnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0YWcgdHlwZVxuICAgKiBAZXhhbXBsZVxuICAgKiBldmVudCA9IG5ldyBOREtFdmVudChuZGssIHsga2luZDogMzAwMDAsIHB1YmtleTogJ3B1YmtleScsIHRhZ3M6IFsgW1wiZFwiLCBcImQtY29kZVwiXSBdIH0pO1xuICAgKiBldmVudC50YWdUeXBlKCk7IC8vIFwiYVwiXG4gICAqL1xuICB0YWdUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpID8gXCJhXCIgOiBcImVcIjtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB0YWcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyBldmVudCBmcm9tIGFub3RoZXIgZXZlbnQuXG4gICAqXG4gICAqIENvbnNpZGVyIHVzaW5nIHJlZmVyZW5jZVRhZ3MoKSBpbnN0ZWFkICh1bmxlc3MgeW91IGhhdmUgYSBnb29kIHJlYXNvbiB0byB1c2UgdGhpcylcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAzMDAwMCwgcHVia2V5OiAncHVia2V5JywgdGFnczogWyBbXCJkXCIsIFwiZC1jb2RlXCJdIF0gfSk7XG4gICAqICAgICBldmVudC50YWdSZWZlcmVuY2UoKTsgLy8gW1wiYVwiLCBcIjMwMDAwOnB1YmtleTpkLWNvZGVcIl1cbiAgICpcbiAgICogICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAxLCBwdWJrZXk6ICdwdWJrZXknLCBpZDogXCJldmVudGlkXCIgfSk7XG4gICAqICAgICBldmVudC50YWdSZWZlcmVuY2UoKTsgLy8gW1wiZVwiLCBcImV2ZW50aWRcIl1cbiAgICogQHJldHVybnMge05ES1RhZ30gVGhlIE5ES1RhZyBvYmplY3QgcmVmZXJlbmNpbmcgdGhpcyBldmVudFxuICAgKi9cbiAgdGFnUmVmZXJlbmNlKG1hcmtlcikge1xuICAgIGxldCB0YWc7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHRhZyA9IFtcImFcIiwgdGhpcy50YWdBZGRyZXNzKCldO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWcgPSBbXCJlXCIsIHRoaXMudGFnSWQoKV07XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbGF5KSB7XG4gICAgICB0YWcucHVzaCh0aGlzLnJlbGF5LnVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZy5wdXNoKFwiXCIpO1xuICAgIH1cbiAgICB0YWcucHVzaChtYXJrZXIgPz8gXCJcIik7XG4gICAgaWYgKCF0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgICB0YWcucHVzaCh0aGlzLnB1YmtleSk7XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdGFncyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIGV2ZW50IGZyb20gYW5vdGhlciBldmVudFxuICAgKiBAcGFyYW0gbWFya2VyIFRoZSBtYXJrZXIgdG8gdXNlIGluIHRoZSB0YWdcbiAgICogQHBhcmFtIHNraXBBdXRob3JUYWcgV2hldGhlciB0byBleHBsaWNpdGx5IHNraXAgYWRkaW5nIHRoZSBhdXRob3IgdGFnIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0gZm9yY2VUYWcgRm9yY2UgYSBzcGVjaWZpYyB0YWcgdG8gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IFwiZVwiIG9yIFwiYVwiIHRhZ1xuICAgKiBAZXhhbXBsZVxuICAgKiAgICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDMwMDAwLCBwdWJrZXk6ICdwdWJrZXknLCB0YWdzOiBbIFtcImRcIiwgXCJkLWNvZGVcIl0gXSB9KTtcbiAgICogICAgIGV2ZW50LnJlZmVyZW5jZVRhZ3MoKTsgLy8gW1tcImFcIiwgXCIzMDAwMDpwdWJrZXk6ZC1jb2RlXCJdLCBbXCJlXCIsIFwicGFyZW50LWlkXCJdXVxuICAgKlxuICAgKiAgICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDEsIHB1YmtleTogJ3B1YmtleScsIGlkOiBcImV2ZW50aWRcIiB9KTtcbiAgICogICAgIGV2ZW50LnJlZmVyZW5jZVRhZ3MoKTsgLy8gW1tcImVcIiwgXCJwYXJlbnQtaWRcIl1dXG4gICAqIEByZXR1cm5zIHtOREtUYWd9IFRoZSBOREtUYWcgb2JqZWN0IHJlZmVyZW5jaW5nIHRoaXMgZXZlbnRcbiAgICovXG4gIHJlZmVyZW5jZVRhZ3MobWFya2VyLCBza2lwQXV0aG9yVGFnLCBmb3JjZVRhZykge1xuICAgIGxldCB0YWdzID0gW107XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHRhZ3MgPSBbXG4gICAgICAgIFtmb3JjZVRhZyA/PyBcImFcIiwgdGhpcy50YWdBZGRyZXNzKCldLFxuICAgICAgICBbZm9yY2VUYWcgPz8gXCJlXCIsIHRoaXMuaWRdXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWdzID0gW1tmb3JjZVRhZyA/PyBcImVcIiwgdGhpcy5pZF1dO1xuICAgIH1cbiAgICB0YWdzID0gdGFncy5tYXAoKHRhZykgPT4ge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgfHwgbWFya2VyKSB7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucmVsYXk/LnVybCA/PyBcIlwiKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZWxheT8udXJsKSB7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucmVsYXk/LnVybCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH0pO1xuICAgIHRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIikge1xuICAgICAgICB0YWcucHVzaChtYXJrZXIgPz8gXCJcIik7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucHVia2V5KTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyKSB7XG4gICAgICAgIHRhZy5wdXNoKG1hcmtlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFncyA9IFsuLi50YWdzLCAuLi50aGlzLmdldE1hdGNoaW5nVGFncyhcImhcIildO1xuICAgIGlmICghc2tpcEF1dGhvclRhZykgdGFncy5wdXNoKC4uLnRoaXMuYXV0aG9yLnJlZmVyZW5jZVRhZ3MoKSk7XG4gICAgcmV0dXJuIHRhZ3M7XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIHRoZSBmaWx0ZXIgdGhhdCB3aWxsIHJldHVybiBtYXRjaGluZyBldmVudHMgZm9yIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAzMDAwMCwgcHVia2V5OiAncHVia2V5JywgdGFnczogWyBbXCJkXCIsIFwiZC1jb2RlXCJdIF0gfSk7XG4gICAqICAgIGV2ZW50LmZpbHRlcigpOyAvLyB7IFwiI2FcIjogW1wiMzAwMDA6cHVia2V5OmQtY29kZVwiXSB9XG4gICAqIEBleGFtcGxlXG4gICAqICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAxLCBwdWJrZXk6ICdwdWJrZXknLCBpZDogXCJldmVudGlkXCIgfSk7XG4gICAqICAgIGV2ZW50LmZpbHRlcigpOyAvLyB7IFwiI2VcIjogW1wiZXZlbnRpZFwiXSB9XG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBmaWx0ZXIgdGhhdCB3aWxsIHJldHVybiBtYXRjaGluZyBldmVudHMgZm9yIHRoaXMgZXZlbnRcbiAgICovXG4gIGZpbHRlcigpIHtcbiAgICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgcmV0dXJuIHsgXCIjYVwiOiBbdGhpcy50YWdJZCgpXSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBcIiNlXCI6IFt0aGlzLnRhZ0lkKCldIH07XG4gIH1cbiAgbmlwMjJGaWx0ZXIoKSB7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHJldHVybiB7IFwiI0FcIjogW3RoaXMudGFnSWQoKV0gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgXCIjRVwiOiBbdGhpcy50YWdJZCgpXSB9O1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBkZWxldGlvbiBldmVudCBvZiB0aGUgY3VycmVudCBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gcmVhc29uIFRoZSByZWFzb24gZm9yIHRoZSBkZWxldGlvblxuICAgKiBAcGFyYW0gcHVibGlzaCBXaGV0aGVyIHRvIHB1Ymxpc2ggdGhlIGRlbGV0aW9uIGV2ZW50IGF1dG9tYXRpY2FsbHlcbiAgICogQHJldHVybnMgVGhlIGRlbGV0aW9uIGV2ZW50XG4gICAqL1xuICBhc3luYyBkZWxldGUocmVhc29uLCBwdWJsaXNoID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBjb25zdCBlID0gbmV3IF9OREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZDogNSAvKiBFdmVudERlbGV0aW9uICovLFxuICAgICAgY29udGVudDogcmVhc29uIHx8IFwiXCJcbiAgICB9KTtcbiAgICBlLnRhZyh0aGlzLCB2b2lkIDAsIHRydWUpO1xuICAgIGUudGFncy5wdXNoKFtcImtcIiwgdGhpcy5raW5kPy50b1N0cmluZygpXSk7XG4gICAgaWYgKHB1Ymxpc2gpIHtcbiAgICAgIHRoaXMuZW1pdChcImRlbGV0ZWRcIik7XG4gICAgICBhd2FpdCBlLnB1Ymxpc2goKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgLyoqXG4gICAqIEVzdGFibGlzaGVzIHdoZXRoZXIgdGhpcyBpcyBhIE5JUC03MC1wcm90ZWN0ZWRlIGV2ZW50LlxuICAgKiBAQHNhdGlzZmllcyBOSVAtNzBcbiAgICovXG4gIHNldCBpc1Byb3RlY3RlZCh2YWwpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcIi1cIik7XG4gICAgaWYgKHZhbCkgdGhpcy50YWdzLnB1c2goW1wiLVwiXSk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBpcyBhIE5JUC03MC1wcm90ZWN0ZWQgZXZlbnQuXG4gICAqIEBAc2F0aXNmaWVzIE5JUC03MFxuICAgKi9cbiAgZ2V0IGlzUHJvdGVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc1RhZyhcIi1cIik7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGFuIGV2ZW50IHRhZ2dlZCB3aXRoIHRoZSBnaXZlbiB0YWcgZm9sbG93aW5nIHJlbGF5IGhpbnRzIGlmIHByb3ZpZGVkLlxuICAgKiBAcGFyYW0gdGFnIFRoZSB0YWcgdG8gc2VhcmNoIGZvclxuICAgKiBAcGFyYW0gbWFya2VyIFRoZSBtYXJrZXIgdG8gdXNlIGluIHRoZSB0YWcgKGUuZy4gXCJyb290XCIpXG4gICAqIEByZXR1cm5zIFRoZSBmZXRjaGVkIGV2ZW50IG9yIG51bGwgaWYgbm8gZXZlbnQgd2FzIGZvdW5kLCB1bmRlZmluZWQgaWYgbm8gbWF0Y2hpbmcgdGFnIHdhcyBmb3VuZCBpbiB0aGUgZXZlbnRcbiAgICogKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZXBseUV2ZW50ID0gYXdhaXQgbmRrLmZldGNoRXZlbnQoXCJuZXZlbnQxcXFzOHg4dm55Y3loYTczZ3J2MzgwZ212bHVyeTR3dG14MG5yOWE1ZHMyZG5ncXdndTg3d242Z3B6ZW1oeHVlNjl1aGh5ZXR2djl1anV1cmpkOWtrem1wd2RlamhncTNxbDJ2eWg0N21rMnAwcWxza3U3aGcwdm4yOWZhZWh5OWh5MzR5Z2FjbHBuNjZ1a3FwM2FmcXo0Y3dqZFwiKVxuICAgKiBjb25zdCBvcmlnaW5hbEV2ZW50ID0gYXdhaXQgcmVwbHlFdmVudC5mZXRjaFRhZ2dlZEV2ZW50KFwiZVwiLCBcInJlcGx5XCIpO1xuICAgKiBjb25zb2xlLmxvZyhyZXBseUV2ZW50LmVuY29kZSgpICsgXCIgaXMgYSByZXBseSB0byBldmVudCBcIiArIG9yaWdpbmFsRXZlbnQ/LmVuY29kZSgpKTtcbiAgICovXG4gIGZldGNoVGFnZ2VkRXZlbnQgPSBmZXRjaFRhZ2dlZEV2ZW50LmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgcm9vdCBldmVudCBvZiB0aGUgY3VycmVudCBldmVudC5cbiAgICogQHJldHVybnMgVGhlIGZldGNoZWQgcm9vdCBldmVudCBvciBudWxsIGlmIG5vIGV2ZW50IHdhcyBmb3VuZFxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZXBseUV2ZW50ID0gYXdhaXQgbmRrLmZldGNoRXZlbnQoXCJuZXZlbnQxcXFzOHg4dm55Y3loYTczZ3J2MzgwZ212bHVyeTR3dG14MG5yOWE1ZHMyZG5ncXdndTg3d242Z3B6ZW1oeHVlNjl1aGh5ZXR2djl1anV1cmpkOWtrem1wd2RlamhncTNxbDJ2eWg0N21rMnAwcWxza3U3aGcwdm4yOWZhZWh5OWh5MzR5Z2FjbHBuNjZ1a3FwM2FmcXo0Y3dqZFwiKVxuICAgKiBjb25zdCByb290RXZlbnQgPSBhd2FpdCByZXBseUV2ZW50LmZldGNoUm9vdEV2ZW50KCk7XG4gICAqIGNvbnNvbGUubG9nKHJlcGx5RXZlbnQuZW5jb2RlKCkgKyBcIiBpcyBhIHJlcGx5IGluIHRoZSB0aHJlYWQgXCIgKyByb290RXZlbnQ/LmVuY29kZSgpKTtcbiAgICovXG4gIGZldGNoUm9vdEV2ZW50ID0gZmV0Y2hSb290RXZlbnQuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIEZldGNoIHRoZSBldmVudCB0aGUgY3VycmVudCBldmVudCBpcyByZXBseWluZyB0by5cbiAgICogQHJldHVybnMgVGhlIGZldGNoZWQgcmVwbHkgZXZlbnQgb3IgbnVsbCBpZiBubyBldmVudCB3YXMgZm91bmRcbiAgICovXG4gIGZldGNoUmVwbHlFdmVudCA9IGZldGNoUmVwbHlFdmVudC5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogTklQLTE4IHJlcG9zdGluZyBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHB1Ymxpc2ggV2hldGhlciB0byBwdWJsaXNoIHRoZSByZXBvc3RlZCBldmVudCBhdXRvbWF0aWNhbGx5IEBkZWZhdWx0IHRydWVcbiAgICogQHBhcmFtIHNpZ25lciBUaGUgc2lnbmVyIHRvIHVzZSBmb3Igc2lnbmluZyB0aGUgcmVwb3N0ZWQgZXZlbnRcbiAgICogQHJldHVybnMgVGhlIHJlcG9zdGVkIGV2ZW50XG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgcmVwb3N0ID0gcmVwb3N0LmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBSZWFjdCB0byBhbiBleGlzdGluZyBldmVudFxuICAgKlxuICAgKiBAcGFyYW0gY29udGVudCBUaGUgY29udGVudCBvZiB0aGUgcmVhY3Rpb25cbiAgICovXG4gIGFzeW5jIHJlYWN0KGNvbnRlbnQsIHB1Ymxpc2ggPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGNvbnN0IGUgPSBuZXcgX05ES0V2ZW50KHRoaXMubmRrLCB7XG4gICAgICBraW5kOiA3IC8qIFJlYWN0aW9uICovLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICAgIGUudGFnKHRoaXMpO1xuICAgIGlmIChwdWJsaXNoKSBhd2FpdCBlLnB1Ymxpc2goKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGV2ZW50IGlzIHZhbGlkIHBlciB1bmRlcmx5aW5nIE5JUHMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3NlcyB0aGF0IGltcGxlbWVudCBzcGVjaWZpYyBOSVBzXG4gICAqIHRvIGFsbG93IHRoZSBlbmZvcmNlbWVudCBvZiBOSVAtc3BlY2lmaWMgdmFsaWRhdGlvbiBydWxlcy5cbiAgICpcbiAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIG9ubHkgY2hlY2sgZm9yIGJhc2ljIGV2ZW50IHByb3BlcnRpZXMuXG4gICAqXG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZSgpO1xuICB9XG4gIGdldCBpbnNwZWN0KCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnJhd0V2ZW50KCksIG51bGwsIDQpO1xuICB9XG4gIC8qKlxuICAgKiBEdW1wIHRoZSBldmVudCB0byBjb25zb2xlIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG4gICAqIFByaW50cyBhIEpTT04gc3RyaW5naWZpZWQgdmVyc2lvbiBvZiByYXdFdmVudCgpIHdpdGggaW5kZW50YXRpb25cbiAgICogYW5kIGFsc28gbGlzdHMgYWxsIHJlbGF5IFVSTHMgZm9yIG9uUmVsYXlzLlxuICAgKi9cbiAgZHVtcCgpIHtcbiAgICBjb25zb2xlLmRlYnVnKEpTT04uc3RyaW5naWZ5KHRoaXMucmF3RXZlbnQoKSwgbnVsbCwgNCkpO1xuICAgIGNvbnNvbGUuZGVidWcoXCJFdmVudCBvbiByZWxheXM6XCIsIHRoaXMub25SZWxheXMubWFwKChyZWxheSkgPT4gcmVsYXkudXJsKS5qb2luKFwiLCBcIikpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVwbHkgZXZlbnQgZm9yIHRoZSBjdXJyZW50IGV2ZW50LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdXNlIE5JUC0yMiB3aGVuIGFwcHJvcHJpYXRlIChpLmUuIHJlcGxpZXMgdG8gbm9uLWtpbmQ6MSBldmVudHMpLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGhhdmUgc2lkZS1lZmZlY3RzOyBpdCB3aWxsIGp1c3QgcmV0dXJuIGFuIGV2ZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIHRhZ3NcbiAgICogdG8gZ2VuZXJhdGUgdGhlIHJlcGx5IGV2ZW50OyB0aGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAgICovXG4gIHJlcGx5KCkge1xuICAgIGNvbnN0IHJlcGx5ID0gbmV3IF9OREtFdmVudCh0aGlzLm5kayk7XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMSkge1xuICAgICAgcmVwbHkua2luZCA9IDE7XG4gICAgICBjb25zdCBvcEhhc0VUYWcgPSB0aGlzLmhhc1RhZyhcImVcIik7XG4gICAgICBpZiAob3BIYXNFVGFnKSB7XG4gICAgICAgIHJlcGx5LnRhZ3MgPSBbXG4gICAgICAgICAgLi4ucmVwbHkudGFncyxcbiAgICAgICAgICAuLi50aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIiksXG4gICAgICAgICAgLi4udGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpLFxuICAgICAgICAgIC4uLnRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiYVwiKSxcbiAgICAgICAgICAuLi50aGlzLnJlZmVyZW5jZVRhZ3MoXCJyZXBseVwiKVxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwbHkudGFnKHRoaXMsIFwicm9vdFwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbHkua2luZCA9IDExMTEgLyogR2VuZXJpY1JlcGx5ICovO1xuICAgICAgY29uc3QgY2FycnlPdmVyVGFncyA9IFtcIkFcIiwgXCJFXCIsIFwiSVwiLCBcIlBcIl07XG4gICAgICBjb25zdCByb290VGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gY2FycnlPdmVyVGFncy5pbmNsdWRlcyh0YWdbMF0pKTtcbiAgICAgIGlmIChyb290VGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJvb3RLaW5kID0gdGhpcy50YWdWYWx1ZShcIktcIik7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaCguLi5yb290VGFncyk7XG4gICAgICAgIGlmIChyb290S2luZCkgcmVwbHkudGFncy5wdXNoKFtcIktcIiwgcm9vdEtpbmRdKTtcbiAgICAgICAgY29uc3QgW3R5cGUsIGlkLCBfLCAuLi5leHRyYV0gPSB0aGlzLnRhZ1JlZmVyZW5jZSgpO1xuICAgICAgICBjb25zdCB0YWcgPSBbdHlwZSwgaWQsIC4uLmV4dHJhXTtcbiAgICAgICAgcmVwbHkudGFncy5wdXNoKHRhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBbdHlwZSwgaWQsIF8sIHJlbGF5SGludF0gPSB0aGlzLnRhZ1JlZmVyZW5jZSgpO1xuICAgICAgICBjb25zdCB0YWcgPSBbdHlwZSwgaWQsIHJlbGF5SGludCA/PyBcIlwiXTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZVwiKSB0YWcucHVzaCh0aGlzLnB1YmtleSk7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaCh0YWcpO1xuICAgICAgICBjb25zdCB1cHBlcmNhc2VUYWcgPSBbLi4udGFnXTtcbiAgICAgICAgdXBwZXJjYXNlVGFnWzBdID0gdXBwZXJjYXNlVGFnWzBdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaCh1cHBlcmNhc2VUYWcpO1xuICAgICAgICByZXBseS50YWdzLnB1c2goW1wiS1wiLCB0aGlzLmtpbmQ/LnRvU3RyaW5nKCldKTtcbiAgICAgICAgcmVwbHkudGFncy5wdXNoKFtcIlBcIiwgdGhpcy5wdWJrZXldKTtcbiAgICAgIH1cbiAgICAgIHJlcGx5LnRhZ3MucHVzaChbXCJrXCIsIHRoaXMua2luZD8udG9TdHJpbmcoKV0pO1xuICAgICAgcmVwbHkudGFncy5wdXNoKC4uLnRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKSk7XG4gICAgICByZXBseS50YWdzLnB1c2goW1wicFwiLCB0aGlzLnB1YmtleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbHk7XG4gIH1cbn07XG52YXIgdW50cmFja2VkVW5wdWJsaXNoZWRFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIDI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqLyxcbiAgMTMxOTQgLyogTm9zdHJXYWxldENvbm5lY3RJbmZvICovLFxuICAyMzE5NCAvKiBOb3N0cldhbGxldENvbm5lY3RSZXEgKi8sXG4gIDIzMTk1IC8qIE5vc3RyV2FsbGV0Q29ubmVjdFJlcyAqL1xuXSk7XG5mdW5jdGlvbiBzaG91bGRUcmFja1VucHVibGlzaGVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICF1bnRyYWNrZWRVbnB1Ymxpc2hlZEV2ZW50cy5oYXMoZXZlbnQua2luZCk7XG59XG5cbi8vIHNyYy9yZWxheS9wb29sL2luZGV4LnRzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyMyB9IGZyb20gXCJ0c2VlcFwiO1xudmFyIE5ES1Bvb2wgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjMge1xuICAvLyBUT0RPOiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBhbiBMUlUgY2FjaGVcbiAgX3JlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHN0YXR1cyA9IFwiaWRsZVwiO1xuICBhdXRvQ29ubmVjdFJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHBvb2xCbGFja2xpc3RSZWxheVVybHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBkZWJ1ZztcbiAgdGVtcG9yYXJ5UmVsYXlUaW1lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmbGFwcGluZ1JlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIC8vIEEgbWFwIHRvIHN0b3JlIHRpbWVvdXRzIGZvciBlYWNoIGZsYXBwaW5nIHJlbGF5LlxuICBiYWNrb2ZmVGltZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBuZGs7XG4gIGdldCBibGFja2xpc3RSZWxheVVybHMoKSB7XG4gICAgY29uc3QgdmFsID0gbmV3IFNldCh0aGlzLm5kay5ibGFja2xpc3RSZWxheVVybHMpO1xuICAgIHRoaXMucG9vbEJsYWNrbGlzdFJlbGF5VXJscy5mb3JFYWNoKCh1cmwpID0+IHZhbC5hZGQodXJsKSk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHJlbGF5VXJscyAtIFRoZSBVUkxzIG9mIHRoZSByZWxheXMgdG8gY29ubmVjdCB0by5cbiAgICogQHBhcmFtIGJsYWNrbGlzdGVkUmVsYXlVcmxzIC0gVVJMcyB0byBibGFja2xpc3QgZm9yIHRoaXMgcG9vbCBJTiBBRERJVElPTiB0byB0aG9zZSBibGFja2xpc3RlZCBhdCB0aGUgbmRrLWxldmVsXG4gICAqIEBwYXJhbSBuZGsgLSBUaGUgTkRLIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgZm9yIHRoZSBwb29sLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVsYXlVcmxzLCBibGFja2xpc3RlZFJlbGF5VXJscywgbmRrLCB7XG4gICAgZGVidWc6IGRlYnVnOCxcbiAgICBuYW1lXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnOCA/PyBuZGsuZGVidWcuZXh0ZW5kKFwicG9vbFwiKTtcbiAgICBpZiAobmFtZSkgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5yZWxheVVybHMgPSByZWxheVVybHM7XG4gICAgdGhpcy5wb29sQmxhY2tsaXN0UmVsYXlVcmxzID0gbmV3IFNldChibGFja2xpc3RlZFJlbGF5VXJscyk7XG4gICAgdGhpcy5uZGsucG9vbHMucHVzaCh0aGlzKTtcbiAgfVxuICBnZXQgcmVsYXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWxheXM7XG4gIH1cbiAgc2V0IHJlbGF5VXJscyh1cmxzKSB7XG4gICAgdGhpcy5fcmVsYXlzLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCByZWxheVVybCBvZiB1cmxzKSB7XG4gICAgICBjb25zdCByZWxheSA9IG5ldyBOREtSZWxheShyZWxheVVybCwgdm9pZCAwLCB0aGlzLm5kayk7XG4gICAgICByZWxheS5jb25uZWN0aXZpdHkubmV0RGVidWcgPSB0aGlzLm5kay5uZXREZWJ1ZztcbiAgICAgIHRoaXMuYWRkUmVsYXkocmVsYXkpO1xuICAgIH1cbiAgfVxuICBfbmFtZSA9IFwidW5uYW1lZFwiO1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfVxuICBzZXQgbmFtZShuYW1lKSB7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kZWJ1ZyA9IHRoaXMuZGVidWcuZXh0ZW5kKG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcmVsYXkgdG8gdGhlIHBvb2wsIGFuZCBzZXRzIGEgdGltZXIgdG8gcmVtb3ZlIGl0IGlmIGl0IGlzIG5vdCB1c2VkIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHRpbWUuXG4gICAqIEBwYXJhbSByZWxheSAtIFRoZSByZWxheSB0byBhZGQgdG8gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSByZW1vdmVJZlVudXNlZEFmdGVyIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJlbW92aW5nIHRoZSByZWxheSBmcm9tIHRoZSBwb29sIGFmdGVyIGl0IGlzIG5vIGxvbmdlciB1c2VkLlxuICAgKi9cbiAgdXNlVGVtcG9yYXJ5UmVsYXkocmVsYXksIHJlbW92ZUlmVW51c2VkQWZ0ZXIgPSAzZTQsIGZpbHRlcnMpIHtcbiAgICBjb25zdCByZWxheUFscmVhZHlJblBvb2wgPSB0aGlzLnJlbGF5cy5oYXMocmVsYXkudXJsKTtcbiAgICBpZiAoIXJlbGF5QWxyZWFkeUluUG9vbCkge1xuICAgICAgdGhpcy5hZGRSZWxheShyZWxheSk7XG4gICAgICB0aGlzLmRlYnVnKFwiQWRkaW5nIHRlbXBvcmFyeSByZWxheSAlcyBmb3IgZmlsdGVycyAlb1wiLCByZWxheS51cmwsIGZpbHRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ1RpbWVyID0gdGhpcy50ZW1wb3JhcnlSZWxheVRpbWVycy5nZXQocmVsYXkudXJsKTtcbiAgICBpZiAoZXhpc3RpbmdUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KGV4aXN0aW5nVGltZXIpO1xuICAgIH1cbiAgICBpZiAoIXJlbGF5QWxyZWFkeUluUG9vbCB8fCBleGlzdGluZ1RpbWVyKSB7XG4gICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5uZGsuZXhwbGljaXRSZWxheVVybHM/LmluY2x1ZGVzKHJlbGF5LnVybCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5yZW1vdmVSZWxheShyZWxheS51cmwpO1xuICAgICAgfSwgcmVtb3ZlSWZVbnVzZWRBZnRlcik7XG4gICAgICB0aGlzLnRlbXBvcmFyeVJlbGF5VGltZXJzLnNldChyZWxheS51cmwsIHRpbWVyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSByZWxheSB0byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHBhcmFtIHJlbGF5IC0gVGhlIHJlbGF5IHRvIGFkZCB0byB0aGUgcG9vbC5cbiAgICogQHBhcmFtIGNvbm5lY3QgLSBXaGV0aGVyIG9yIG5vdCB0byBjb25uZWN0IHRvIHRoZSByZWxheS5cbiAgICovXG4gIGFkZFJlbGF5KHJlbGF5LCBjb25uZWN0ID0gdHJ1ZSkge1xuICAgIGNvbnN0IGlzQWxyZWFkeUluUG9vbCA9IHRoaXMucmVsYXlzLmhhcyhyZWxheS51cmwpO1xuICAgIGNvbnN0IGlzQmxhY2tsaXN0ZWQgPSB0aGlzLmJsYWNrbGlzdFJlbGF5VXJscz8uaGFzKHJlbGF5LnVybCk7XG4gICAgY29uc3QgaXNDdXN0b21SZWxheVVybCA9IHJlbGF5LnVybC5pbmNsdWRlcyhcIi9ucHViMVwiKTtcbiAgICBsZXQgcmVjb25uZWN0ID0gdHJ1ZTtcbiAgICBjb25zdCByZWxheVVybCA9IHJlbGF5LnVybDtcbiAgICBpZiAoaXNBbHJlYWR5SW5Qb29sKSByZXR1cm47XG4gICAgaWYgKGlzQmxhY2tsaXN0ZWQpIHtcbiAgICAgIHRoaXMuZGVidWcoYFJlZnVzaW5nIHRvIGFkZCByZWxheSAke3JlbGF5VXJsfTogYmxhY2tsaXN0ZWRgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzQ3VzdG9tUmVsYXlVcmwpIHtcbiAgICAgIHRoaXMuZGVidWcoYFJlZnVzaW5nIHRvIGFkZCByZWxheSAke3JlbGF5VXJsfTogaXMgYSBmaWx0ZXIgcmVsYXlgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlcj8uZ2V0UmVsYXlTdGF0dXMpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZ2V0UmVsYXlTdGF0dXMocmVsYXlVcmwpO1xuICAgICAgaWYgKGluZm8/LmRvbnRDb25uZWN0QmVmb3JlKSB7XG4gICAgICAgIGlmIChpbmZvLmRvbnRDb25uZWN0QmVmb3JlID4gRGF0ZS5ub3coKSkge1xuICAgICAgICAgIGNvbnN0IGRlbGF5ID0gaW5mby5kb250Q29ubmVjdEJlZm9yZSAtIERhdGUubm93KCk7XG4gICAgICAgICAgdGhpcy5kZWJ1ZyhgUmVmdXNpbmcgdG8gYWRkIHJlbGF5ICR7cmVsYXlVcmx9OiBkZWxheWVkIGNvbm5lY3QgZm9yICR7ZGVsYXl9bXNgKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkUmVsYXkocmVsYXksIGNvbm5lY3QpO1xuICAgICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vdGljZUhhbmRsZXIgPSAobm90aWNlKSA9PiB0aGlzLmVtaXQoXCJub3RpY2VcIiwgcmVsYXksIG5vdGljZSk7XG4gICAgY29uc3QgY29ubmVjdEhhbmRsZXIgPSAoKSA9PiB0aGlzLmhhbmRsZVJlbGF5Q29ubmVjdChyZWxheVVybCk7XG4gICAgY29uc3QgcmVhZHlIYW5kbGVyID0gKCkgPT4gdGhpcy5oYW5kbGVSZWxheVJlYWR5KHJlbGF5KTtcbiAgICBjb25zdCBkaXNjb25uZWN0SGFuZGxlciA9ICgpID0+IHRoaXMuZW1pdChcInJlbGF5OmRpc2Nvbm5lY3RcIiwgcmVsYXkpO1xuICAgIGNvbnN0IGZsYXBwaW5nSGFuZGxlciA9ICgpID0+IHRoaXMuaGFuZGxlRmxhcHBpbmcocmVsYXkpO1xuICAgIGNvbnN0IGF1dGhIYW5kbGVyID0gKGNoYWxsZW5nZSkgPT4gdGhpcy5lbWl0KFwicmVsYXk6YXV0aFwiLCByZWxheSwgY2hhbGxlbmdlKTtcbiAgICBjb25zdCBhdXRoZWRIYW5kbGVyID0gKCkgPT4gdGhpcy5lbWl0KFwicmVsYXk6YXV0aGVkXCIsIHJlbGF5KTtcbiAgICByZWxheS5vZmYoXCJub3RpY2VcIiwgbm90aWNlSGFuZGxlcik7XG4gICAgcmVsYXkub2ZmKFwiY29ubmVjdFwiLCBjb25uZWN0SGFuZGxlcik7XG4gICAgcmVsYXkub2ZmKFwicmVhZHlcIiwgcmVhZHlIYW5kbGVyKTtcbiAgICByZWxheS5vZmYoXCJkaXNjb25uZWN0XCIsIGRpc2Nvbm5lY3RIYW5kbGVyKTtcbiAgICByZWxheS5vZmYoXCJmbGFwcGluZ1wiLCBmbGFwcGluZ0hhbmRsZXIpO1xuICAgIHJlbGF5Lm9mZihcImF1dGhcIiwgYXV0aEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9mZihcImF1dGhlZFwiLCBhdXRoZWRIYW5kbGVyKTtcbiAgICByZWxheS5vbihcIm5vdGljZVwiLCBub3RpY2VIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImNvbm5lY3RcIiwgY29ubmVjdEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwicmVhZHlcIiwgcmVhZHlIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImRpc2Nvbm5lY3RcIiwgZGlzY29ubmVjdEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwiZmxhcHBpbmdcIiwgZmxhcHBpbmdIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImF1dGhcIiwgYXV0aEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwiYXV0aGVkXCIsIGF1dGhlZEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwiZGVsYXllZC1jb25uZWN0XCIsIChkZWxheSkgPT4ge1xuICAgICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlcj8udXBkYXRlUmVsYXlTdGF0dXMpIHtcbiAgICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLnVwZGF0ZVJlbGF5U3RhdHVzKHJlbGF5LnVybCwge1xuICAgICAgICAgIGRvbnRDb25uZWN0QmVmb3JlOiBEYXRlLm5vdygpICsgZGVsYXlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fcmVsYXlzLnNldChyZWxheVVybCwgcmVsYXkpO1xuICAgIGlmIChjb25uZWN0KSB0aGlzLmF1dG9Db25uZWN0UmVsYXlzLmFkZChyZWxheVVybCk7XG4gICAgaWYgKGNvbm5lY3QgJiYgdGhpcy5zdGF0dXMgPT09IFwiYWN0aXZlXCIpIHtcbiAgICAgIHRoaXMuZW1pdChcInJlbGF5OmNvbm5lY3RpbmdcIiwgcmVsYXkpO1xuICAgICAgcmVsYXkuY29ubmVjdCh2b2lkIDAsIHJlY29ubmVjdCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhgRmFpbGVkIHRvIGNvbm5lY3QgdG8gcmVsYXkgJHtyZWxheVVybH1gLCBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIHJlbGF5IGZyb20gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSByZWxheVVybCAtIFRoZSBVUkwgb2YgdGhlIHJlbGF5IHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHJlbGF5IHdhcyByZW1vdmVkLCBmYWxzZSBpZiBpdCB3YXMgbm90IGZvdW5kLlxuICAgKi9cbiAgcmVtb3ZlUmVsYXkocmVsYXlVcmwpIHtcbiAgICBjb25zdCByZWxheSA9IHRoaXMucmVsYXlzLmdldChyZWxheVVybCk7XG4gICAgaWYgKHJlbGF5KSB7XG4gICAgICByZWxheS5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLnJlbGF5cy5kZWxldGUocmVsYXlVcmwpO1xuICAgICAgdGhpcy5hdXRvQ29ubmVjdFJlbGF5cy5kZWxldGUocmVsYXlVcmwpO1xuICAgICAgdGhpcy5lbWl0KFwicmVsYXk6ZGlzY29ubmVjdFwiLCByZWxheSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdUaW1lciA9IHRoaXMudGVtcG9yYXJ5UmVsYXlUaW1lcnMuZ2V0KHJlbGF5VXJsKTtcbiAgICBpZiAoZXhpc3RpbmdUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KGV4aXN0aW5nVGltZXIpO1xuICAgICAgdGhpcy50ZW1wb3JhcnlSZWxheVRpbWVycy5kZWxldGUocmVsYXlVcmwpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgcmVsYXkgaXMgYWxyZWFkeSBjb25uZWN0ZWQgaW4gdGhlIHBvb2wuXG4gICAqL1xuICBpc1JlbGF5Q29ubmVjdGVkKHVybCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRVcmwgPSBub3JtYWxpemVSZWxheVVybCh1cmwpO1xuICAgIGNvbnN0IHJlbGF5ID0gdGhpcy5yZWxheXMuZ2V0KG5vcm1hbGl6ZWRVcmwpO1xuICAgIGlmICghcmVsYXkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcmVsYXkuc3RhdHVzID09PSA1IC8qIENPTk5FQ1RFRCAqLztcbiAgfVxuICAvKipcbiAgICogRmV0Y2hlcyBhIHJlbGF5IGZyb20gdGhlIHBvb2wsIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBOZXcgcmVsYXlzIHdpbGwgYmUgYXR0ZW1wdGVkIHRvIGJlIGNvbm5lY3RlZC5cbiAgICovXG4gIGdldFJlbGF5KHVybCwgY29ubmVjdCA9IHRydWUsIHRlbXBvcmFyeSA9IGZhbHNlLCBmaWx0ZXJzKSB7XG4gICAgbGV0IHJlbGF5ID0gdGhpcy5yZWxheXMuZ2V0KG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkpO1xuICAgIGlmICghcmVsYXkpIHtcbiAgICAgIHJlbGF5ID0gbmV3IE5ES1JlbGF5KHVybCwgdm9pZCAwLCB0aGlzLm5kayk7XG4gICAgICByZWxheS5jb25uZWN0aXZpdHkubmV0RGVidWcgPSB0aGlzLm5kay5uZXREZWJ1ZztcbiAgICAgIGlmICh0ZW1wb3JhcnkpIHtcbiAgICAgICAgdGhpcy51c2VUZW1wb3JhcnlSZWxheShyZWxheSwgM2U0LCBmaWx0ZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkUmVsYXkocmVsYXksIGNvbm5lY3QpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbiAgaGFuZGxlUmVsYXlDb25uZWN0KHJlbGF5VXJsKSB7XG4gICAgY29uc3QgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQocmVsYXlVcmwpO1xuICAgIGlmICghcmVsYXkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJOREsgQlVHOiByZWxheSBub3QgZm91bmQgaW4gcG9vbFwiLCB7IHJlbGF5VXJsIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJyZWxheTpjb25uZWN0XCIsIHJlbGF5KTtcbiAgICBpZiAodGhpcy5zdGF0cygpLmNvbm5lY3RlZCA9PT0gdGhpcy5yZWxheXMuc2l6ZSkge1xuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdFwiKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlUmVsYXlSZWFkeShyZWxheSkge1xuICAgIHRoaXMuZW1pdChcInJlbGF5OnJlYWR5XCIsIHJlbGF5KTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB0byBlYWNoIHJlbGF5IGluIHRoZSBwb29sLlxuICAgKlxuICAgKiBAYXN5bmNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0TXNdIC0gT3B0aW9uYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIGVhY2ggY29ubmVjdGlvbiBhdHRlbXB0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgY29ubmVjdGlvbiBhdHRlbXB0cyBoYXZlIGNvbXBsZXRlZC5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIGFueSBvZiB0aGUgY29ubmVjdGlvbiBhdHRlbXB0cyByZXN1bHQgaW4gYW4gZXJyb3Igb3IgdGltZW91dC5cbiAgICovXG4gIGFzeW5jIGNvbm5lY3QodGltZW91dE1zKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICB0aGlzLnN0YXR1cyA9IFwiYWN0aXZlXCI7XG4gICAgdGhpcy5kZWJ1ZyhgQ29ubmVjdGluZyB0byAke3RoaXMucmVsYXlzLnNpemV9IHJlbGF5cyR7dGltZW91dE1zID8gYCwgdGltZW91dCAke3RpbWVvdXRNc30uLi5gIDogXCJcIn1gKTtcbiAgICBjb25zdCByZWxheXNUb0Nvbm5lY3QgPSBuZXcgU2V0KHRoaXMuYXV0b0Nvbm5lY3RSZWxheXMua2V5cygpKTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIHJlbGF5c1RvQ29ubmVjdCkge1xuICAgICAgY29uc3QgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQocmVsYXlVcmwpO1xuICAgICAgaWYgKCFyZWxheSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbm5lY3RQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoXCJyZWxheTpjb25uZWN0aW5nXCIsIHJlbGF5KTtcbiAgICAgICAgcmV0dXJuIHJlbGF5LmNvbm5lY3QodGltZW91dE1zKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aW1lb3V0TXMpIHtcbiAgICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QoYFRpbWVkIG91dCBhZnRlciAke3RpbWVvdXRNc31tc2ApLCB0aW1lb3V0TXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICBQcm9taXNlLnJhY2UoW2Nvbm5lY3RQcm9taXNlLCB0aW1lb3V0UHJvbWlzZV0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKGBGYWlsZWQgdG8gY29ubmVjdCB0byByZWxheSAke3JlbGF5LnVybH06ICR7ZSA/PyBcIk5vIHJlYXNvbiBzcGVjaWZpZWRcIn1gKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChjb25uZWN0UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1heWJlRW1pdENvbm5lY3QgPSAoKSA9PiB7XG4gICAgICBjb25zdCBhbGxDb25uZWN0ZWQgPSB0aGlzLnN0YXRzKCkuY29ubmVjdGVkID09PSB0aGlzLnJlbGF5cy5zaXplO1xuICAgICAgY29uc3Qgc29tZUNvbm5lY3RlZCA9IHRoaXMuc3RhdHMoKS5jb25uZWN0ZWQgPiAwO1xuICAgICAgaWYgKCFhbGxDb25uZWN0ZWQgJiYgc29tZUNvbm5lY3RlZCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0XCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHRpbWVvdXRNcykgc2V0VGltZW91dChtYXliZUVtaXRDb25uZWN0LCB0aW1lb3V0TXMpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICBtYXliZUVtaXRDb25uZWN0KCk7XG4gIH1cbiAgY2hlY2tPbkZsYXBwaW5nUmVsYXlzKCkge1xuICAgIGNvbnN0IGZsYXBwaW5nUmVsYXlzQ291bnQgPSB0aGlzLmZsYXBwaW5nUmVsYXlzLnNpemU7XG4gICAgY29uc3QgdG90YWxSZWxheXMgPSB0aGlzLnJlbGF5cy5zaXplO1xuICAgIGlmIChmbGFwcGluZ1JlbGF5c0NvdW50IC8gdG90YWxSZWxheXMgPj0gMC44KSB7XG4gICAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIHRoaXMuZmxhcHBpbmdSZWxheXMpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZXMuc2V0KHJlbGF5VXJsLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlRmxhcHBpbmcocmVsYXkpIHtcbiAgICB0aGlzLmRlYnVnKGBSZWxheSAke3JlbGF5LnVybH0gaXMgZmxhcHBpbmdgKTtcbiAgICBsZXQgY3VycmVudEJhY2tvZmYgPSB0aGlzLmJhY2tvZmZUaW1lcy5nZXQocmVsYXkudXJsKSB8fCA1ZTM7XG4gICAgY3VycmVudEJhY2tvZmYgPSBjdXJyZW50QmFja29mZiAqIDI7XG4gICAgdGhpcy5iYWNrb2ZmVGltZXMuc2V0KHJlbGF5LnVybCwgY3VycmVudEJhY2tvZmYpO1xuICAgIHRoaXMuZGVidWcoYEJhY2tvZmYgdGltZSBmb3IgJHtyZWxheS51cmx9IGlzICR7Y3VycmVudEJhY2tvZmZ9bXNgKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZGVidWcoYEF0dGVtcHRpbmcgdG8gcmVjb25uZWN0IHRvICR7cmVsYXkudXJsfWApO1xuICAgICAgdGhpcy5lbWl0KFwicmVsYXk6Y29ubmVjdGluZ1wiLCByZWxheSk7XG4gICAgICByZWxheS5jb25uZWN0KCk7XG4gICAgICB0aGlzLmNoZWNrT25GbGFwcGluZ1JlbGF5cygpO1xuICAgIH0sIGN1cnJlbnRCYWNrb2ZmKTtcbiAgICByZWxheS5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5lbWl0KFwiZmxhcHBpbmdcIiwgcmVsYXkpO1xuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlzLnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXR1cyBvZiBlYWNoIHJlbGF5IGluIHRoZSBwb29sLlxuICAgKiBAcmV0dXJucyB7TkRLUG9vbFN0YXRzfSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbnVtYmVyIG9mIHJlbGF5cyBpbiBlYWNoIHN0YXR1cy5cbiAgICovXG4gIHN0YXRzKCkge1xuICAgIGNvbnN0IHN0YXRzID0ge1xuICAgICAgdG90YWw6IDAsXG4gICAgICBjb25uZWN0ZWQ6IDAsXG4gICAgICBkaXNjb25uZWN0ZWQ6IDAsXG4gICAgICBjb25uZWN0aW5nOiAwXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHRoaXMucmVsYXlzLnZhbHVlcygpKSB7XG4gICAgICBzdGF0cy50b3RhbCsrO1xuICAgICAgaWYgKHJlbGF5LnN0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgICAgc3RhdHMuY29ubmVjdGVkKys7XG4gICAgICB9IGVsc2UgaWYgKHJlbGF5LnN0YXR1cyA9PT0gMSAvKiBESVNDT05ORUNURUQgKi8pIHtcbiAgICAgICAgc3RhdHMuZGlzY29ubmVjdGVkKys7XG4gICAgICB9IGVsc2UgaWYgKHJlbGF5LnN0YXR1cyA9PT0gNCAvKiBDT05ORUNUSU5HICovKSB7XG4gICAgICAgIHN0YXRzLmNvbm5lY3RpbmcrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRzO1xuICB9XG4gIGNvbm5lY3RlZFJlbGF5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cy52YWx1ZXMoKSkuZmlsdGVyKChyZWxheSkgPT4gcmVsYXkuc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovKTtcbiAgfVxuICBwZXJtYW5lbnRBbmRDb25uZWN0ZWRSZWxheXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWxheXMudmFsdWVzKCkpLmZpbHRlcihcbiAgICAgIChyZWxheSkgPT4gcmVsYXkuc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovICYmICF0aGlzLnRlbXBvcmFyeVJlbGF5VGltZXJzLmhhcyhyZWxheS51cmwpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBhbGwgcmVsYXkgdXJscyBpbiB0aGUgcG9vbC5cbiAgICovXG4gIHVybHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWxheXMua2V5cygpKTtcbiAgfVxufTtcblxuLy8gc3JjL3VzZXIvaW5kZXgudHNcbmltcG9ydCB7IG5pcDE5IGFzIG5pcDE5NSB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL251dHphcC9taW50LWxpc3QudHNcbnZhciBOREtDYXNodU1pbnRMaXN0ID0gY2xhc3MgX05ES0Nhc2h1TWludExpc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMTAwMTkgLyogQ2FzaHVNaW50TGlzdCAqLztcbiAgc3RhdGljIGtpbmRzID0gWzEwMDE5IC8qIENhc2h1TWludExpc3QgKi9dO1xuICBfcDJwaztcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMTAwMTkgLyogQ2FzaHVNaW50TGlzdCAqLztcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0Nhc2h1TWludExpc3QoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgc2V0IHJlbGF5cyh1cmxzKSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJyZWxheVwiKTtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiB1cmxzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJyZWxheVwiLCB1cmxdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlbGF5cygpIHtcbiAgICBjb25zdCByID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcInJlbGF5XCIpIHtcbiAgICAgICAgci5wdXNoKHRhZ1sxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHNldCBtaW50cyh1cmxzKSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJtaW50XCIpO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIHVybHMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcIm1pbnRcIiwgdXJsXSk7XG4gICAgfVxuICB9XG4gIGdldCBtaW50cygpIHtcbiAgICBjb25zdCByID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcIm1pbnRcIikge1xuICAgICAgICByLnB1c2godGFnWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChyKSk7XG4gIH1cbiAgZ2V0IHAycGsoKSB7XG4gICAgaWYgKHRoaXMuX3AycGspIHtcbiAgICAgIHJldHVybiB0aGlzLl9wMnBrO1xuICAgIH1cbiAgICB0aGlzLl9wMnBrID0gdGhpcy50YWdWYWx1ZShcInB1YmtleVwiKSA/PyB0aGlzLnB1YmtleTtcbiAgICByZXR1cm4gdGhpcy5fcDJwaztcbiAgfVxuICBzZXQgcDJwayhwdWJrZXkpIHtcbiAgICB0aGlzLl9wMnBrID0gcHVia2V5O1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicHVia2V5XCIpO1xuICAgIGlmIChwdWJrZXkpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInB1YmtleVwiLCBwdWJrZXldKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlbGF5U2V0KCkge1xuICAgIHJldHVybiBOREtSZWxheVNldC5mcm9tUmVsYXlVcmxzKHRoaXMucmVsYXlzLCB0aGlzLm5kayk7XG4gIH1cbn07XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vaW5kZXgudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI0IH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy9ldmVudHMva2luZHMvYXJ0aWNsZS50c1xudmFyIE5ES0FydGljbGUgPSBjbGFzcyBfTkRLQXJ0aWNsZSBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmQgPSAzMDAyMyAvKiBBcnRpY2xlICovO1xuICBzdGF0aWMga2luZHMgPSBbMzAwMjMgLyogQXJ0aWNsZSAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMwMDIzIC8qIEFydGljbGUgKi87XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOREtBcnRpY2xlIGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES0FydGljbGUgZnJvbS5cbiAgICogQHJldHVybnMgTkRLQXJ0aWNsZVxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtBcnRpY2xlKGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlIHRpdGxlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gdGl0bGUgLSBUaGUgdGl0bGUgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIGltYWdlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlIGltYWdlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBpbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImltYWdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIGltYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gaW1hZ2UgLSBUaGUgaW1hZ2UgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCBpbWFnZShpbWFnZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiaW1hZ2VcIik7XG4gICAgaWYgKGltYWdlKSB0aGlzLnRhZ3MucHVzaChbXCJpbWFnZVwiLCBpbWFnZV0pO1xuICB9XG4gIGdldCBzdW1tYXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwic3VtbWFyeVwiKTtcbiAgfVxuICBzZXQgc3VtbWFyeShzdW1tYXJ5KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJzdW1tYXJ5XCIpO1xuICAgIGlmIChzdW1tYXJ5KSB0aGlzLnRhZ3MucHVzaChbXCJzdW1tYXJ5XCIsIHN1bW1hcnldKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH0gLSBUaGUgVW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgYXJ0aWNsZSB3YXMgcHVibGlzaGVkIG9yIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBwdWJsaXNoZWRfYXQoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdWYWx1ZShcInB1Ymxpc2hlZF9hdFwiKTtcbiAgICBpZiAodGFnKSB7XG4gICAgICBsZXQgdmFsID0gTnVtYmVyLnBhcnNlSW50KHRhZyk7XG4gICAgICBpZiAodmFsID4gMWUxMikge1xuICAgICAgICB2YWwgPSBNYXRoLmZsb29yKHZhbCAvIDFlMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlJ3MgcHVibGljYXRpb24gdGltZXN0YW1wLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gdGltZXN0YW1wIC0gVGhlIFVuaXggdGltZXN0YW1wIHRvIHNldCBmb3IgdGhlIGFydGljbGUncyBwdWJsaWNhdGlvbiBkYXRlLlxuICAgKi9cbiAgc2V0IHB1Ymxpc2hlZF9hdCh0aW1lc3RhbXApIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInB1Ymxpc2hlZF9hdFwiKTtcbiAgICBpZiAodGltZXN0YW1wICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInB1Ymxpc2hlZF9hdFwiLCB0aW1lc3RhbXAudG9TdHJpbmcoKV0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvbnRlbnQgdGFncyBmb3IgdGhlIGFydGljbGUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZpcnN0IGNoZWNrcyBhbmQgc2V0cyB0aGUgcHVibGljYXRpb24gZGF0ZSBpZiBub3QgYXZhaWxhYmxlLFxuICAgKiBhbmQgdGhlbiBnZW5lcmF0ZXMgY29udGVudCB0YWdzIGJhc2VkIG9uIHRoZSBiYXNlIE5ES0V2ZW50IGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gLSBUaGUgZ2VuZXJhdGVkIGNvbnRlbnQgdGFncy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlVGFncygpIHtcbiAgICBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgICBpZiAoIXRoaXMucHVibGlzaGVkX2F0KSB7XG4gICAgICB0aGlzLnB1Ymxpc2hlZF9hdCA9IHRoaXMuY3JlYXRlZF9hdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlJ3MgVVJMLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlJ3MgVVJMIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ1cmxcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGFydGljbGUncyBVUkwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSB1cmwgLSBUaGUgVVJMIHRvIHNldCBmb3IgdGhlIGFydGljbGUuXG4gICAqL1xuICBzZXQgdXJsKHVybCkge1xuICAgIGlmICh1cmwpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInVybFwiLCB1cmxdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVUYWcoXCJ1cmxcIik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2Nhc2h1L3Rva2VuLnRzXG5mdW5jdGlvbiBwcm9vZnNUb3RhbEJhbGFuY2UocHJvb2ZzKSB7XG4gIHJldHVybiBwcm9vZnMucmVkdWNlKChhY2MsIHByb29mKSA9PiB7XG4gICAgaWYgKHByb29mLmFtb3VudCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInByb29mIGFtb3VudCBpcyBuZWdhdGl2ZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYyArIHByb29mLmFtb3VudDtcbiAgfSwgMCk7XG59XG52YXIgTkRLQ2FzaHVUb2tlbiA9IGNsYXNzIF9OREtDYXNodVRva2VuIGV4dGVuZHMgTkRLRXZlbnQge1xuICBfcHJvb2ZzID0gW107XG4gIF9taW50O1xuICBzdGF0aWMga2luZCA9IDczNzUgLyogQ2FzaHVUb2tlbiAqLztcbiAgc3RhdGljIGtpbmRzID0gWzczNzUgLyogQ2FzaHVUb2tlbiAqL107XG4gIC8qKlxuICAgKiBUb2tlbnMgdGhhdCB0aGlzIHRva2VuIHN1cGVyc2VlZHNcbiAgICovXG4gIF9kZWxldGVzID0gW107XG4gIG9yaWdpbmFsO1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA3Mzc1IC8qIENhc2h1VG9rZW4gKi87XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb20oZXZlbnQpIHtcbiAgICBjb25zdCB0b2tlbiA9IG5ldyBfTkRLQ2FzaHVUb2tlbihldmVudC5uZGssIGV2ZW50KTtcbiAgICB0b2tlbi5vcmlnaW5hbCA9IGV2ZW50O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0b2tlbi5kZWNyeXB0KCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4ub3JpZ2luYWwuY29udGVudDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnBhcnNlKHRva2VuLmNvbnRlbnQpO1xuICAgICAgdG9rZW4ucHJvb2ZzID0gY29udGVudC5wcm9vZnM7XG4gICAgICB0b2tlbi5taW50ID0gY29udGVudC5taW50ID8/IHRva2VuLnRhZ1ZhbHVlKFwibWludFwiKTtcbiAgICAgIHRva2VuLmRlbGV0ZWRUb2tlbnMgPSBjb250ZW50LmRlbCA/PyBbXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0b2tlbi5wcm9vZnMpKSByZXR1cm47XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG4gIGdldCBwcm9vZnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb29mcztcbiAgfVxuICBzZXQgcHJvb2ZzKHByb29mcykge1xuICAgIGNvbnN0IGNzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLl9wcm9vZnMgPSBwcm9vZnMuZmlsdGVyKChwcm9vZikgPT4ge1xuICAgICAgaWYgKGNzLmhhcyhwcm9vZi5DKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJQYXNzZWQgaW4gcHJvb2ZzIGhhZCBkdXBsaWNhdGVzLCBpZ25vcmluZ1wiLCBwcm9vZi5DKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHByb29mLmFtb3VudCA8IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCBwcm9vZiB3aXRoIG5lZ2F0aXZlIGFtb3VudFwiLCBwcm9vZik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNzLmFkZChwcm9vZi5DKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLm1hcCh0aGlzLmNsZWFuUHJvb2YpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbWluaW1hbCBwcm9vZiBvYmplY3Qgd2l0aCBvbmx5IGVzc2VudGlhbCBwcm9wZXJ0aWVzXG4gICAqL1xuICBjbGVhblByb29mKHByb29mKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBwcm9vZi5pZCxcbiAgICAgIGFtb3VudDogcHJvb2YuYW1vdW50LFxuICAgICAgQzogcHJvb2YuQyxcbiAgICAgIHNlY3JldDogcHJvb2Yuc2VjcmV0XG4gICAgfTtcbiAgfVxuICBhc3luYyB0b05vc3RyRXZlbnQocHVia2V5KSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwibm8gbmRrXCIpO1xuICAgIGlmICghdGhpcy5uZGsuc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBzaWduZXJcIik7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHByb29mczogdGhpcy5wcm9vZnMubWFwKHRoaXMuY2xlYW5Qcm9vZiksXG4gICAgICBtaW50OiB0aGlzLm1pbnQsXG4gICAgICBkZWw6IHRoaXMuZGVsZXRlZFRva2VucyA/PyBbXVxuICAgIH07XG4gICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci51c2VyKCk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIsIHZvaWQgMCwgXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gc3VwZXIudG9Ob3N0ckV2ZW50KHB1YmtleSk7XG4gIH1cbiAgc2V0IG1pbnQobWludCkge1xuICAgIHRoaXMuX21pbnQgPSBtaW50O1xuICB9XG4gIGdldCBtaW50KCkge1xuICAgIHJldHVybiB0aGlzLl9taW50O1xuICB9XG4gIC8qKlxuICAgKiBUb2tlbnMgdGhhdCB3ZXJlIGRlbGV0ZWQgYnkgdGhlIGNyZWF0aW9uIG9mIHRoaXMgdG9rZW4uXG4gICAqL1xuICBnZXQgZGVsZXRlZFRva2VucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVsZXRlcztcbiAgfVxuICAvKipcbiAgICogTWFya3MgdG9rZW5zIHRoYXQgd2VyZSBkZWxldGVkIGJ5IHRoZSBjcmVhdGlvbiBvZiB0aGlzIHRva2VuLlxuICAgKi9cbiAgc2V0IGRlbGV0ZWRUb2tlbnModG9rZW5JZHMpIHtcbiAgICB0aGlzLl9kZWxldGVzID0gdG9rZW5JZHM7XG4gIH1cbiAgZ2V0IGFtb3VudCgpIHtcbiAgICByZXR1cm4gcHJvb2ZzVG90YWxCYWxhbmNlKHRoaXMucHJvb2ZzKTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbC5wdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvaGlnaGxpZ2h0LnRzXG5pbXBvcnQgeyBuaXAxOSBhcyBuaXAxOTMgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbnZhciBOREtIaWdobGlnaHQgPSBjbGFzcyBfTkRLSGlnaGxpZ2h0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBfYXJ0aWNsZTtcbiAgc3RhdGljIGtpbmQgPSA5ODAyIC8qIEhpZ2hsaWdodCAqLztcbiAgc3RhdGljIGtpbmRzID0gWzk4MDIgLyogSGlnaGxpZ2h0ICovXTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gOTgwMiAvKiBIaWdobGlnaHQgKi87XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtIaWdobGlnaHQoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInJcIik7XG4gIH1cbiAgLyoqXG4gICAqIENvbnRleHQgdGFnLlxuICAgKi9cbiAgc2V0IGNvbnRleHQoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKFt0YWcsIF92YWx1ZV0pID0+IHRhZyAhPT0gXCJjb250ZXh0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKChbdGFnLCBfdmFsdWVdKSA9PiB0YWcgIT09IFwiY29udGV4dFwiKTtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcImNvbnRleHRcIiwgY29udGV4dF0pO1xuICAgIH1cbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbmQoKFt0YWcsIF92YWx1ZV0pID0+IHRhZyA9PT0gXCJjb250ZXh0XCIpPy5bMV0gPz8gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBXaWxsIHJldHVybiB0aGUgYXJ0aWNsZSBVUkwgb3IgTkRLRXZlbnQgaWYgdGhleSBoYXZlIGFscmVhZHkgYmVlblxuICAgKiBzZXQgKGl0IHdvbid0IGF0dGVtcHQgdG8gbG9hZCByZW1vdGUgZXZlbnRzKVxuICAgKi9cbiAgZ2V0IGFydGljbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FydGljbGU7XG4gIH1cbiAgLyoqXG4gICAqIEFydGljbGUgdGhlIGhpZ2hsaWdodCBpcyBjb21pbmcgZnJvbS5cbiAgICpcbiAgICogQHBhcmFtIGFydGljbGUgQXJ0aWNsZSBVUkwgb3IgTkRLRXZlbnQuXG4gICAqL1xuICBzZXQgYXJ0aWNsZShhcnRpY2xlKSB7XG4gICAgdGhpcy5fYXJ0aWNsZSA9IGFydGljbGU7XG4gICAgaWYgKHR5cGVvZiBhcnRpY2xlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJyXCIsIGFydGljbGVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWcoYXJ0aWNsZSk7XG4gICAgfVxuICB9XG4gIGdldEFydGljbGVUYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiYVwiKVswXSB8fCB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIilbMF0gfHwgdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJyXCIpWzBdO1xuICB9XG4gIGFzeW5jIGdldEFydGljbGUoKSB7XG4gICAgaWYgKHRoaXMuX2FydGljbGUgIT09IHZvaWQgMCkgcmV0dXJuIHRoaXMuX2FydGljbGU7XG4gICAgbGV0IHRhZ2dlZEJlY2gzMjtcbiAgICBjb25zdCBhcnRpY2xlVGFnID0gdGhpcy5nZXRBcnRpY2xlVGFnKCk7XG4gICAgaWYgKCFhcnRpY2xlVGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIHN3aXRjaCAoYXJ0aWNsZVRhZ1swXSkge1xuICAgICAgY2FzZSBcImFcIjoge1xuICAgICAgICBjb25zdCBba2luZCwgcHVia2V5LCBpZGVudGlmaWVyXSA9IGFydGljbGVUYWdbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICB0YWdnZWRCZWNoMzIgPSBuaXAxOTMubmFkZHJFbmNvZGUoe1xuICAgICAgICAgIGtpbmQ6IE51bWJlci5wYXJzZUludChraW5kKSxcbiAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgaWRlbnRpZmllclxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZVwiOlxuICAgICAgICB0YWdnZWRCZWNoMzIgPSBuaXAxOTMubm90ZUVuY29kZShhcnRpY2xlVGFnWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiclwiOlxuICAgICAgICB0aGlzLl9hcnRpY2xlID0gYXJ0aWNsZVRhZ1sxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0YWdnZWRCZWNoMzIpIHtcbiAgICAgIGxldCBhID0gYXdhaXQgdGhpcy5uZGs/LmZldGNoRXZlbnQodGFnZ2VkQmVjaDMyKTtcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIGlmIChhLmtpbmQgPT09IDMwMDIzIC8qIEFydGljbGUgKi8pIHtcbiAgICAgICAgICBhID0gTkRLQXJ0aWNsZS5mcm9tKGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FydGljbGUgPSBhO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYXJ0aWNsZTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2ltZXRhLnRzXG5mdW5jdGlvbiBtYXBJbWV0YVRhZyh0YWcpIHtcbiAgY29uc3QgZGF0YSA9IHt9O1xuICBpZiAodGFnLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHBhcnRzID0gdGFnWzFdLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCBrZXkgPSBwYXJ0c1tpXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFydHNbaSArIDFdO1xuICAgICAgaWYgKGtleSA9PT0gXCJmYWxsYmFja1wiKSB7XG4gICAgICAgIGlmICghZGF0YS5mYWxsYmFjaykgZGF0YS5mYWxsYmFjayA9IFtdO1xuICAgICAgICBkYXRhLmZhbGxiYWNrLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGNvbnN0IHRhZ3MgPSB0YWcuc2xpY2UoMSk7XG4gIGZvciAoY29uc3QgdmFsIG9mIHRhZ3MpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHZhbC5zcGxpdChcIiBcIik7XG4gICAgY29uc3Qga2V5ID0gcGFydHNbMF07XG4gICAgY29uc3QgdmFsdWUgPSBwYXJ0cy5zbGljZSgxKS5qb2luKFwiIFwiKTtcbiAgICBpZiAoa2V5ID09PSBcImZhbGxiYWNrXCIpIHtcbiAgICAgIGlmICghZGF0YS5mYWxsYmFjaykgZGF0YS5mYWxsYmFjayA9IFtdO1xuICAgICAgZGF0YS5mYWxsYmFjay5wdXNoKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gaW1ldGFUYWdUb1RhZyhpbWV0YSkge1xuICBjb25zdCB0YWcgPSBbXCJpbWV0YVwiXTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW1ldGEpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgdGFnLnB1c2goYCR7a2V5fSAke3Z9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgdGFnLnB1c2goYCR7a2V5fSAke3ZhbHVlfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFnO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2ltYWdlLnRzXG52YXIgTkRLSW1hZ2UgPSBjbGFzcyBfTkRLSW1hZ2UgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMjAgLyogSW1hZ2UgKi87XG4gIHN0YXRpYyBraW5kcyA9IFsyMCAvKiBJbWFnZSAqL107XG4gIF9pbWV0YXM7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDIwIC8qIEltYWdlICovO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTkRLSW1hZ2UgZnJvbSBhbiBleGlzdGluZyBOREtFdmVudC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IE5ES0V2ZW50IHRvIGNyZWF0ZSB0aGUgTkRLSW1hZ2UgZnJvbS5cbiAgICogQHJldHVybnMgTkRLSW1hZ2VcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLSW1hZ2UoZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWV0YXMubGVuZ3RoID4gMDtcbiAgfVxuICBnZXQgaW1ldGFzKCkge1xuICAgIGlmICh0aGlzLl9pbWV0YXMpIHJldHVybiB0aGlzLl9pbWV0YXM7XG4gICAgdGhpcy5faW1ldGFzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiaW1ldGFcIikubWFwKG1hcEltZXRhVGFnKS5maWx0ZXIoKGltZXRhKSA9PiAhIWltZXRhLnVybCk7XG4gICAgcmV0dXJuIHRoaXMuX2ltZXRhcztcbiAgfVxuICBzZXQgaW1ldGFzKHRhZ3MpIHtcbiAgICB0aGlzLl9pbWV0YXMgPSB0YWdzO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcImltZXRhXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKC4uLnRhZ3MubWFwKGltZXRhVGFnVG9UYWcpKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9saXN0cy9pbmRleC50c1xudmFyIE5ES0xpc3QgPSBjbGFzcyBfTkRLTGlzdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgX2VuY3J5cHRlZFRhZ3M7XG4gIHN0YXRpYyBraW5kcyA9IFtcbiAgICAxMDA2MyAvKiBCbG9zc29tTGlzdCAqLyxcbiAgICAzMDAwMSAvKiBDYXRlZ29yaXplZEJvb2ttYXJrTGlzdCAqLyxcbiAgICAxMDAwNCAvKiBDb21tdW5pdHlMaXN0ICovLFxuICAgIDEwMDUwIC8qIERpcmVjdE1lc3NhZ2VSZWNlaXZlUmVsYXlMaXN0ICovLFxuICAgIDEwMDMwIC8qIEVtb2ppTGlzdCAqLyxcbiAgICAxMDAxNSAvKiBJbnRlcmVzdExpc3QgKi8sXG4gICAgMTAwMDEgLyogUGluTGlzdCAqLyxcbiAgICAxMDAwMiAvKiBSZWxheUxpc3QgKi8sXG4gICAgMTAwMDcgLyogU2VhcmNoUmVsYXlMaXN0ICovLFxuICAgIDEwMDA2IC8qIEJsb2NrUmVsYXlMaXN0ICovLFxuICAgIDEwMDAzIC8qIEJvb2ttYXJrTGlzdCAqL1xuICBdO1xuICAvKipcbiAgICogU3RvcmVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGNvbnRlbnQgd2FzIGJlZm9yZSBkZWNyeXB0aW9uXG4gICAqIHRvIGV4cGlyZSB0aGUgY2FjaGUgd2hlbiB0aGUgY29udGVudCBjaGFuZ2VzLlxuICAgKi9cbiAgZW5jcnlwdGVkVGFnc0xlbmd0aDtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzAwMDEgLyogQ2F0ZWdvcml6ZWRCb29rbWFya0xpc3QgKi87XG4gIH1cbiAgLyoqXG4gICAqIFdyYXAgYSBOREtFdmVudCBpbnRvIGEgTkRLTGlzdFxuICAgKi9cbiAgc3RhdGljIGZyb20obmRrRXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtMaXN0KG5ka0V2ZW50Lm5kaywgbmRrRXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0aXRsZSBvZiB0aGUgbGlzdC4gRmFsbHMgYmFjayBvbiBmZXRjaGluZyB0aGUgbmFtZSB0YWcgdmFsdWUuXG4gICAqL1xuICBnZXQgdGl0bGUoKSB7XG4gICAgY29uc3QgdGl0bGVUYWcgPSB0aGlzLnRhZ1ZhbHVlKFwidGl0bGVcIikgfHwgdGhpcy50YWdWYWx1ZShcIm5hbWVcIik7XG4gICAgaWYgKHRpdGxlVGFnKSByZXR1cm4gdGl0bGVUYWc7XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMyAvKiBDb250YWN0cyAqLykge1xuICAgICAgcmV0dXJuIFwiQ29udGFjdHNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMWU0IC8qIE11dGVMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJNdXRlXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDAxIC8qIFBpbkxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIlBpbm5lZCBOb3Rlc1wiO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSAxMDAwMiAvKiBSZWxheUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIlJlbGF5IE1ldGFkYXRhXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDAzIC8qIEJvb2ttYXJrTGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiQm9va21hcmtzXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDA0IC8qIENvbW11bml0eUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIkNvbW11bml0aWVzXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDA1IC8qIFB1YmxpY0NoYXRMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJQdWJsaWMgQ2hhdHNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMTAwMDYgLyogQmxvY2tSZWxheUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIkJsb2NrZWQgUmVsYXlzXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDEwMDA3IC8qIFNlYXJjaFJlbGF5TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiU2VhcmNoIFJlbGF5c1wiO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSAxMDA1MCAvKiBEaXJlY3RNZXNzYWdlUmVjZWl2ZVJlbGF5TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiRGlyZWN0IE1lc3NhZ2UgUmVjZWl2ZSBSZWxheXNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMTAwMTUgLyogSW50ZXJlc3RMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJJbnRlcmVzdHNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMTAwMzAgLyogRW1vamlMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJFbW9qaXNcIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0aXRsZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFtcInRpdGxlXCIsIFwibmFtZVwiXSk7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBsaXN0LlxuICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIFwidGl0bGVcIiBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5hbWUgb2YgdGhlIGxpc3QuXG4gICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgXCJ0aXRsZVwiIGluc3RlYWQuIFRoaXMgbWV0aG9kIHdpbGwgdXNlIHRoZSBgdGl0bGVgIHRhZyBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0IG5hbWUobmFtZSkge1xuICAgIHRoaXMudGl0bGUgPSBuYW1lO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImRlc2NyaXB0aW9uXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgbGlzdC5cbiAgICovXG4gIHNldCBkZXNjcmlwdGlvbihuYW1lKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkZXNjcmlwdGlvblwiKTtcbiAgICBpZiAobmFtZSkgdGhpcy50YWdzLnB1c2goW1wiZGVzY3JpcHRpb25cIiwgbmFtZV0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbWFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGdldCBpbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImltYWdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbWFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIHNldCBpbWFnZShuYW1lKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJpbWFnZVwiKTtcbiAgICBpZiAobmFtZSkgdGhpcy50YWdzLnB1c2goW1wiaW1hZ2VcIiwgbmFtZV0pO1xuICB9XG4gIGlzRW5jcnlwdGVkVGFnc0NhY2hlVmFsaWQoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuX2VuY3J5cHRlZFRhZ3MgJiYgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID09PSB0aGlzLmNvbnRlbnQubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVjcnlwdGVkIGNvbnRlbnQgb2YgdGhlIGxpc3QuXG4gICAqL1xuICBhc3luYyBlbmNyeXB0ZWRUYWdzKHVzZUNhY2hlID0gdHJ1ZSkge1xuICAgIGlmICh1c2VDYWNoZSAmJiB0aGlzLmlzRW5jcnlwdGVkVGFnc0NhY2hlVmFsaWQoKSkgcmV0dXJuIHRoaXMuX2VuY3J5cHRlZFRhZ3M7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBzZXRcIik7XG4gICAgaWYgKCF0aGlzLm5kay5zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5ESyBzaWduZXIgbm90IHNldFwiKTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZGVjcnlwdGVkQ29udGVudCA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci5kZWNyeXB0KHVzZXIsIHRoaXMuY29udGVudCk7XG4gICAgICAgICAgY29uc3QgYSA9IEpTT04ucGFyc2UoZGVjcnlwdGVkQ29udGVudCk7XG4gICAgICAgICAgaWYgKGE/LlswXSkge1xuICAgICAgICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmNyeXB0ZWRUYWdzID0gYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGVuIHRvIHZhbGlkYXRlIHRoYXQgYSB0YWcgaXMgdmFsaWQgZm9yIHRoaXMgbGlzdC5cbiAgICpcbiAgICogKGkuZS4gdGhlIE5ES1BlcnNvbkxpc3QgY2FuIHZhbGlkYXRlIHRoYXQgaXRlbXMgYXJlIE5ES1VzZXIgaW5zdGFuY2VzKVxuICAgKi9cbiAgdmFsaWRhdGVUYWcoX3RhZ1ZhbHVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0SXRlbXModHlwZSkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gdHlwZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuZWNyeXB0ZWQgaXRlbXMgaW4gdGhpcyBsaXN0LlxuICAgKi9cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0KSA9PiB7XG4gICAgICByZXR1cm4gIVtcbiAgICAgICAgXCJkXCIsXG4gICAgICAgIFwiTFwiLFxuICAgICAgICBcImxcIixcbiAgICAgICAgXCJ0aXRsZVwiLFxuICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiLFxuICAgICAgICBcInB1Ymxpc2hlZF9hdFwiLFxuICAgICAgICBcInN1bW1hcnlcIixcbiAgICAgICAgXCJpbWFnZVwiLFxuICAgICAgICBcInRodW1iXCIsXG4gICAgICAgIFwiYWx0XCIsXG4gICAgICAgIFwiZXhwaXJhdGlvblwiLFxuICAgICAgICBcInN1YmplY3RcIixcbiAgICAgICAgXCJjbGllbnRcIlxuICAgICAgXS5pbmNsdWRlcyh0WzBdKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBpdGVtIHRvIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0gcmVsYXkgUmVsYXkgdG8gYWRkXG4gICAqIEBwYXJhbSBtYXJrIE9wdGlvbmFsIG1hcmsgdG8gYWRkIHRvIHRoZSBpdGVtXG4gICAqIEBwYXJhbSBlbmNyeXB0ZWQgV2hldGhlciB0byBlbmNyeXB0IHRoZSBpdGVtXG4gICAqIEBwYXJhbSBwb3NpdGlvbiBXaGVyZSB0byBhZGQgdGhlIGl0ZW0gaW4gdGhlIGxpc3QgKHRvcCBvciBib3R0b20pXG4gICAqL1xuICBhc3luYyBhZGRJdGVtKGl0ZW0sIG1hcmsgPSB2b2lkIDAsIGVuY3J5cHRlZCA9IGZhbHNlLCBwb3NpdGlvbiA9IFwiYm90dG9tXCIpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IHNldFwiKTtcbiAgICBpZiAoIXRoaXMubmRrLnNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwiTkRLIHNpZ25lciBub3Qgc2V0XCIpO1xuICAgIGxldCB0YWdzO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICAgIHRhZ3MgPSBbaXRlbS50YWdSZWZlcmVuY2UobWFyayldO1xuICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICAgIHRhZ3MgPSBpdGVtLnJlZmVyZW5jZVRhZ3MoKTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtSZWxheSkge1xuICAgICAgdGFncyA9IGl0ZW0ucmVmZXJlbmNlVGFncygpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgdGFncyA9IFtpdGVtXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvYmplY3QgdHlwZVwiKTtcbiAgICB9XG4gICAgaWYgKG1hcmspIHRhZ3NbMF0ucHVzaChtYXJrKTtcbiAgICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRMaXN0ID0gYXdhaXQgdGhpcy5lbmNyeXB0ZWRUYWdzKCk7XG4gICAgICBpZiAocG9zaXRpb24gPT09IFwidG9wXCIpIGN1cnJlbnRMaXN0LnVuc2hpZnQoLi4udGFncyk7XG4gICAgICBlbHNlIGN1cnJlbnRMaXN0LnB1c2goLi4udGFncyk7XG4gICAgICB0aGlzLl9lbmNyeXB0ZWRUYWdzID0gY3VycmVudExpc3Q7XG4gICAgICB0aGlzLmVuY3J5cHRlZFRhZ3NMZW5ndGggPSB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoY3VycmVudExpc3QpO1xuICAgICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09IFwidG9wXCIpIHRoaXMudGFncy51bnNoaWZ0KC4uLnRhZ3MpO1xuICAgICAgZWxzZSB0aGlzLnRhZ3MucHVzaCguLi50YWdzKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVkX2F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBsaXN0IGZyb20gYm90aCB0aGUgZW5jcnlwdGVkIGFuZCB1bmVuY3J5cHRlZCBsaXN0cy5cbiAgICogQHBhcmFtIHZhbHVlIHZhbHVlIG9mIGl0ZW0gdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3RcbiAgICogQHBhcmFtIHB1Ymxpc2ggd2hldGhlciB0byBwdWJsaXNoIHRoZSBjaGFuZ2VcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHJlbW92ZUl0ZW1CeVZhbHVlKHZhbHVlLCBwdWJsaXNoID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3Qgc2V0XCIpO1xuICAgIGlmICghdGhpcy5uZGsuc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgc2lnbmVyIG5vdCBzZXRcIik7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnRhZ3MuZmluZEluZGV4KCh0YWcpID0+IHRhZ1sxXSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLnRhZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgZW5jcnlwdGVkVGFncyA9IGF3YWl0IHRoaXMuZW5jcnlwdGVkVGFncygpO1xuICAgIGNvbnN0IGVuY3J5cHRlZEluZGV4ID0gZW5jcnlwdGVkVGFncy5maW5kSW5kZXgoKHRhZykgPT4gdGFnWzFdID09PSB2YWx1ZSk7XG4gICAgaWYgKGVuY3J5cHRlZEluZGV4ID49IDApIHtcbiAgICAgIGVuY3J5cHRlZFRhZ3Muc3BsaWNlKGVuY3J5cHRlZEluZGV4LCAxKTtcbiAgICAgIHRoaXMuX2VuY3J5cHRlZFRhZ3MgPSBlbmNyeXB0ZWRUYWdzO1xuICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGVuY3J5cHRlZFRhZ3MpO1xuICAgICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIpO1xuICAgIH1cbiAgICBpZiAocHVibGlzaCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVibGlzaFJlcGxhY2VhYmxlKCk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaXRlbSB0byByZW1vdmUuXG4gICAqIEBwYXJhbSBlbmNyeXB0ZWQgV2hldGhlciB0byByZW1vdmUgZnJvbSB0aGUgZW5jcnlwdGVkIGxpc3Qgb3Igbm90LlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlSXRlbShpbmRleCwgZW5jcnlwdGVkKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBzZXRcIik7XG4gICAgaWYgKCF0aGlzLm5kay5zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5ESyBzaWduZXIgbm90IHNldFwiKTtcbiAgICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRMaXN0ID0gYXdhaXQgdGhpcy5lbmNyeXB0ZWRUYWdzKCk7XG4gICAgICBjdXJyZW50TGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy5fZW5jcnlwdGVkVGFncyA9IGN1cnJlbnRMaXN0O1xuICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRMaXN0KTtcbiAgICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh1c2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGhhcyhpdGVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMuc29tZSgodGFnKSA9PiB0YWdbMV0gPT09IGl0ZW0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZmlsdGVyIHRoYXQgd2lsbCByZXN1bHQgaW4gZmV0Y2hpbmdcbiAgICogdGhlIGl0ZW1zIG9mIHRoaXMgbGlzdFxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBsaXN0ID0gbmV3IE5ES0xpc3QoLi4uKTtcbiAgICogY29uc3QgZmlsdGVycyA9IGxpc3QuZmlsdGVyRm9ySXRlbXMoKTtcbiAgICogY29uc3QgZXZlbnRzID0gYXdhaXQgbmRrLmZldGNoRXZlbnRzKGZpbHRlcnMpO1xuICAgKi9cbiAgZmlsdGVyRm9ySXRlbXMoKSB7XG4gICAgY29uc3QgaWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBuaXAzM1F1ZXJpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiB0YWdbMV0pIHtcbiAgICAgICAgaWRzLmFkZCh0YWdbMV0pO1xuICAgICAgfSBlbHNlIGlmICh0YWdbMF0gPT09IFwiYVwiICYmIHRhZ1sxXSkge1xuICAgICAgICBjb25zdCBba2luZCwgcHVia2V5LCBkVGFnXSA9IHRhZ1sxXS5zcGxpdChcIjpcIik7XG4gICAgICAgIGlmICgha2luZCB8fCAhcHVia2V5KSBjb250aW51ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gYCR7a2luZH06JHtwdWJrZXl9YDtcbiAgICAgICAgY29uc3QgaXRlbSA9IG5pcDMzUXVlcmllcy5nZXQoa2V5KSB8fCBbXTtcbiAgICAgICAgaXRlbS5wdXNoKGRUYWcgfHwgXCJcIik7XG4gICAgICAgIG5pcDMzUXVlcmllcy5zZXQoa2V5LCBpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlkcy5zaXplID4gMCkge1xuICAgICAgZmlsdGVycy5wdXNoKHsgaWRzOiBBcnJheS5mcm9tKGlkcykgfSk7XG4gICAgfVxuICAgIGlmIChuaXAzM1F1ZXJpZXMuc2l6ZSA+IDApIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVzXSBvZiBuaXAzM1F1ZXJpZXMuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IFtraW5kLCBwdWJrZXldID0ga2V5LnNwbGl0KFwiOlwiKTtcbiAgICAgICAgZmlsdGVycy5wdXNoKHtcbiAgICAgICAgICBraW5kczogW051bWJlci5wYXJzZUludChraW5kKV0sXG4gICAgICAgICAgYXV0aG9yczogW3B1YmtleV0sXG4gICAgICAgICAgXCIjZFwiOiB2YWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJzO1xuICB9XG59O1xudmFyIGxpc3RzX2RlZmF1bHQgPSBOREtMaXN0O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL251dHphcC9pbmRleC50c1xuaW1wb3J0IGRlYnVnMiBmcm9tIFwiZGVidWdcIjtcbnZhciBOREtOdXR6YXAgPSBjbGFzcyBfTkRLTnV0emFwIGV4dGVuZHMgTkRLRXZlbnQge1xuICBkZWJ1ZztcbiAgX3Byb29mcyA9IFtdO1xuICBzdGF0aWMga2luZCA9IDkzMjEgLyogTnV0emFwICovO1xuICBzdGF0aWMga2luZHMgPSBbX05ES051dHphcC5raW5kXTtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gOTMyMSAvKiBOdXR6YXAgKi87XG4gICAgdGhpcy5kZWJ1ZyA9IG5kaz8uZGVidWcuZXh0ZW5kKFwibnV0emFwXCIpID8/IGRlYnVnMihcIm5kazpudXR6YXBcIik7XG4gICAgaWYgKCF0aGlzLmFsdCkgdGhpcy5hbHQgPSBcIlRoaXMgaXMgYSBudXR6YXBcIjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvb2ZUYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwcm9vZlwiKTtcbiAgICAgIGlmIChwcm9vZlRhZ3MubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3Byb29mcyA9IHByb29mVGFncy5tYXAoKHRhZykgPT4gSlNPTi5wYXJzZSh0YWdbMV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Byb29mcyA9IEpTT04ucGFyc2UodGhpcy5jb250ZW50KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICBjb25zdCBlID0gbmV3IF9OREtOdXR6YXAoZXZlbnQubmRrLCBldmVudCk7XG4gICAgaWYgKCFlLl9wcm9vZnMgfHwgIWUuX3Byb29mcy5sZW5ndGgpIHJldHVybjtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBzZXQgY29tbWVudChjb21tZW50KSB7XG4gICAgdGhpcy5jb250ZW50ID0gY29tbWVudCA/PyBcIlwiO1xuICB9XG4gIGdldCBjb21tZW50KCkge1xuICAgIGNvbnN0IGMgPSB0aGlzLnRhZ1ZhbHVlKFwiY29tbWVudFwiKTtcbiAgICBpZiAoYykgcmV0dXJuIGM7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfVxuICBzZXQgcHJvb2ZzKHByb29mcykge1xuICAgIHRoaXMuX3Byb29mcyA9IHByb29mcztcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSAhPT0gXCJwcm9vZlwiKTtcbiAgICBmb3IgKGNvbnN0IHByb29mIG9mIHByb29mcykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicHJvb2ZcIiwgSlNPTi5zdHJpbmdpZnkocHJvb2YpXSk7XG4gICAgfVxuICB9XG4gIGdldCBwcm9vZnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb29mcztcbiAgfVxuICBnZXQgcmF3UDJwaygpIHtcbiAgICBjb25zdCBmaXJzdFByb29mID0gdGhpcy5wcm9vZnNbMF07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlY3JldCA9IEpTT04ucGFyc2UoZmlyc3RQcm9vZi5zZWNyZXQpO1xuICAgICAgbGV0IHBheWxvYWQ7XG4gICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShzZWNyZXQpO1xuICAgICAgICB0aGlzLmRlYnVnKFwic3RyaW5naWZpZWQgcGF5bG9hZFwiLCBmaXJzdFByb29mLnNlY3JldCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWNyZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcGF5bG9hZCA9IHNlY3JldDtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpICYmIHBheWxvYWRbMF0gPT09IFwiUDJQS1wiICYmIHBheWxvYWQubGVuZ3RoID4gMSAmJiB0eXBlb2YgcGF5bG9hZFsxXSA9PT0gXCJvYmplY3RcIiAmJiBwYXlsb2FkWzFdICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkWzFdLmRhdGE7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09IFwib2JqZWN0XCIgJiYgcGF5bG9hZCAhPT0gbnVsbCAmJiB0eXBlb2YgcGF5bG9hZFsxXT8uZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gcGF5bG9hZFsxXS5kYXRhO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJlcnJvciBwYXJzaW5nIHAycGsgcHVia2V5XCIsIGUsIHRoaXMucHJvb2ZzWzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcDJwayBwdWJrZXkgdGhhdCBpcyBlbWJlZGRlZCBpbiB0aGUgZmlyc3QgcHJvb2YuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgYSBub3N0ciBwdWJrZXksIG5vdCBhIGNhc2h1IHB1YmtleSAobm8gXCIwMlwiIHByZWZpeClcbiAgICovXG4gIGdldCBwMnBrKCkge1xuICAgIGNvbnN0IHJhd1AycGsgPSB0aGlzLnJhd1AycGs7XG4gICAgaWYgKCFyYXdQMnBrKSByZXR1cm47XG4gICAgcmV0dXJuIHJhd1AycGsuc3RhcnRzV2l0aChcIjAyXCIpID8gcmF3UDJway5zbGljZSgyKSA6IHJhd1AycGs7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludCB3aGVyZSB0aGlzIG51dHphcCBwcm9vZnMgZXhpc3RcbiAgICovXG4gIGdldCBtaW50KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidVwiKTtcbiAgfVxuICBzZXQgbWludCh2YWx1ZSkge1xuICAgIHRoaXMucmVwbGFjZVRhZyhbXCJ1XCIsIHZhbHVlXSk7XG4gIH1cbiAgZ2V0IHVuaXQoKSB7XG4gICAgbGV0IF91bml0ID0gdGhpcy50YWdWYWx1ZShcInVuaXRcIikgPz8gXCJzYXRcIjtcbiAgICBpZiAoX3VuaXQ/LnN0YXJ0c1dpdGgoXCJtc2F0XCIpKSBfdW5pdCA9IFwic2F0XCI7XG4gICAgcmV0dXJuIF91bml0O1xuICB9XG4gIHNldCB1bml0KHZhbHVlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJ1bml0XCIpO1xuICAgIGlmICh2YWx1ZT8uc3RhcnRzV2l0aChcIm1zYXRcIikpIHRocm93IG5ldyBFcnJvcihcIm1zYXQgaXMgbm90IGFsbG93ZWQsIHVzZSBzYXQgZGVub21pbmF0aW9uIGluc3RlYWRcIik7XG4gICAgaWYgKHZhbHVlKSB0aGlzLnRhZyhbXCJ1bml0XCIsIHZhbHVlXSk7XG4gIH1cbiAgZ2V0IGFtb3VudCgpIHtcbiAgICBjb25zdCBhbW91bnQgPSB0aGlzLnByb29mcy5yZWR1Y2UoKHRvdGFsLCBwcm9vZikgPT4gdG90YWwgKyBwcm9vZi5hbW91bnQsIDApO1xuICAgIHJldHVybiBhbW91bnQ7XG4gIH1cbiAgc2VuZGVyID0gdGhpcy5hdXRob3I7XG4gIC8qKlxuICAgKiBTZXQgdGhlIHRhcmdldCBvZiB0aGUgbnV0emFwXG4gICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgbnV0emFwIChhIHVzZXIgb3IgYW4gZXZlbnQpXG4gICAqL1xuICBzZXQgdGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+IHRbMF0gIT09IFwicFwiKTtcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKHRhcmdldC50YWdSZWZlcmVuY2UoKSk7XG4gICAgfVxuICB9XG4gIHNldCByZWNpcGllbnRQdWJrZXkocHVia2V5KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIHRoaXMudGFnKFtcInBcIiwgcHVia2V5XSk7XG4gIH1cbiAgZ2V0IHJlY2lwaWVudFB1YmtleSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInBcIik7XG4gIH1cbiAgZ2V0IHJlY2lwaWVudCgpIHtcbiAgICBjb25zdCBwdWJrZXkgPSB0aGlzLnJlY2lwaWVudFB1YmtleTtcbiAgICBpZiAodGhpcy5uZGspIHJldHVybiB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5IH0pO1xuICAgIHJldHVybiBuZXcgTkRLVXNlcih7IHB1YmtleSB9KTtcbiAgfVxuICBhc3luYyB0b05vc3RyRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMudW5pdCA9PT0gXCJtc2F0XCIpIHtcbiAgICAgIHRoaXMudW5pdCA9IFwic2F0XCI7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlVGFnKFwiYW1vdW50XCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImFtb3VudFwiLCB0aGlzLmFtb3VudC50b1N0cmluZygpXSk7XG4gICAgY29uc3QgZXZlbnQgPSBhd2FpdCBzdXBlci50b05vc3RyRXZlbnQoKTtcbiAgICBldmVudC5jb250ZW50ID0gdGhpcy5jb21tZW50O1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIG51dHphcCBjb25mb3JtcyB0byBOSVAtNjFcbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIGxldCBlVGFnQ291bnQgPSAwO1xuICAgIGxldCBwVGFnQ291bnQgPSAwO1xuICAgIGxldCBtaW50VGFnQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIpIGVUYWdDb3VudCsrO1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIpIHBUYWdDb3VudCsrO1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJ1XCIpIG1pbnRUYWdDb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgLy8gZXhhY3RseSBvbmUgcmVjaXBpZW50IGFuZCBtaW50XG4gICAgICBwVGFnQ291bnQgPT09IDEgJiYgbWludFRhZ0NvdW50ID09PSAxICYmIC8vIG11c3QgaGF2ZSBhdCBtb3N0IG9uZSBlIHRhZ1xuICAgICAgZVRhZ0NvdW50IDw9IDEgJiYgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBwcm9vZlxuICAgICAgdGhpcy5wcm9vZnMubGVuZ3RoID4gMFxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBwcm9vZlAycGsocHJvb2YpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZWNyZXQgPSBKU09OLnBhcnNlKHByb29mLnNlY3JldCk7XG4gICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2Uoc2VjcmV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWNyZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHBheWxvYWQgPSBzZWNyZXQ7XG4gICAgfVxuICAgIGNvbnN0IGlzUDJQS0xvY2tlZCA9IHBheWxvYWRbMF0gPT09IFwiUDJQS1wiICYmIHBheWxvYWRbMV0/LmRhdGE7XG4gICAgaWYgKGlzUDJQS0xvY2tlZCkge1xuICAgICAgcmV0dXJuIHBheWxvYWRbMV0uZGF0YTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiZXJyb3IgcGFyc2luZyBwMnBrIHB1YmtleVwiLCBlLCBwcm9vZik7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb29mUDJwa05vc3RyKHByb29mKSB7XG4gIGNvbnN0IHAycGsgPSBwcm9vZlAycGsocHJvb2YpO1xuICBpZiAoIXAycGspIHJldHVybjtcbiAgaWYgKHAycGsuc3RhcnRzV2l0aChcIjAyXCIpICYmIHAycGsubGVuZ3RoID09PSA2NikgcmV0dXJuIHAycGsuc2xpY2UoMik7XG4gIHJldHVybiBwMnBrO1xufVxuZnVuY3Rpb24gY2FzaHVQdWJrZXlUb05vc3RyUHVia2V5KGNhc2h1UHVia2V5KSB7XG4gIGlmIChjYXNodVB1YmtleS5zdGFydHNXaXRoKFwiMDJcIikgJiYgY2FzaHVQdWJrZXkubGVuZ3RoID09PSA2NikgcmV0dXJuIGNhc2h1UHVia2V5LnNsaWNlKDIpO1xuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3NpbXBsZS1ncm91cC9tZW1iZXItbGlzdC50c1xudmFyIE5ES1NpbXBsZUdyb3VwTWVtYmVyTGlzdCA9IGNsYXNzIF9OREtTaW1wbGVHcm91cE1lbWJlckxpc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHJlbGF5U2V0O1xuICBtZW1iZXJTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBzdGF0aWMga2luZCA9IDM5MDAyIC8qIEdyb3VwTWVtYmVycyAqLztcbiAgc3RhdGljIGtpbmRzID0gWzM5MDAyIC8qIEdyb3VwTWVtYmVycyAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDM5MDAyIC8qIEdyb3VwTWVtYmVycyAqLztcbiAgICB0aGlzLm1lbWJlclNldCA9IG5ldyBTZXQodGhpcy5tZW1iZXJzKTtcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1NpbXBsZUdyb3VwTWVtYmVyTGlzdChldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICBnZXQgbWVtYmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICB9XG4gIGhhc01lbWJlcihtZW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1iZXJTZXQuaGFzKG1lbWJlcik7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICByZWxheVNldCA/Pz0gdGhpcy5yZWxheVNldDtcbiAgICByZXR1cm4gc3VwZXIucHVibGlzaFJlcGxhY2VhYmxlKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc2ltcGxlLWdyb3VwL21ldGFkYXRhLnRzXG52YXIgTkRLU2ltcGxlR3JvdXBNZXRhZGF0YSA9IGNsYXNzIF9OREtTaW1wbGVHcm91cE1ldGFkYXRhIGV4dGVuZHMgTkRLRXZlbnQge1xuICBzdGF0aWMga2luZCA9IDM5ZTMgLyogR3JvdXBNZXRhZGF0YSAqLztcbiAgc3RhdGljIGtpbmRzID0gWzM5ZTMgLyogR3JvdXBNZXRhZGF0YSAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDM5ZTMgLyogR3JvdXBNZXRhZGF0YSAqLztcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1NpbXBsZUdyb3VwTWV0YWRhdGEoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJuYW1lXCIpO1xuICB9XG4gIGdldCBwaWN0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwicGljdHVyZVwiKTtcbiAgfVxuICBnZXQgYWJvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJhYm91dFwiKTtcbiAgfVxuICBnZXQgc2NvcGUoKSB7XG4gICAgaWYgKHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicHVibGljXCIpLmxlbmd0aCA+IDApIHJldHVybiBcInB1YmxpY1wiO1xuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcInB1YmxpY1wiKS5sZW5ndGggPiAwKSByZXR1cm4gXCJwcml2YXRlXCI7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBzZXQgc2NvcGUoc2NvcGUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInB1YmxpY1wiKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInByaXZhdGVcIik7XG4gICAgaWYgKHNjb3BlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwdWJsaWNcIiwgXCJcIl0pO1xuICAgIH0gZWxzZSBpZiAoc2NvcGUgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwcml2YXRlXCIsIFwiXCJdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFjY2VzcygpIHtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJvcGVuXCIpLmxlbmd0aCA+IDApIHJldHVybiBcIm9wZW5cIjtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJjbG9zZWRcIikubGVuZ3RoID4gMCkgcmV0dXJuIFwiY2xvc2VkXCI7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBzZXQgYWNjZXNzKGFjY2Vzcykge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwib3BlblwiKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImNsb3NlZFwiKTtcbiAgICBpZiAoYWNjZXNzID09PSBcIm9wZW5cIikge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wib3BlblwiLCBcIlwiXSk7XG4gICAgfSBlbHNlIGlmIChhY2Nlc3MgPT09IFwiY2xvc2VkXCIpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcImNsb3NlZFwiLCBcIlwiXSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3N0b3J5LnRzXG52YXIgTkRLU3RvcnlTdGlja2VyVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ES1N0b3J5U3RpY2tlclR5cGUyKSA9PiB7XG4gIE5ES1N0b3J5U3RpY2tlclR5cGUyW1wiUHVia2V5XCJdID0gXCJwdWJrZXlcIjtcbiAgTkRLU3RvcnlTdGlja2VyVHlwZTJbXCJFdmVudFwiXSA9IFwiZXZlbnRcIjtcbiAgTkRLU3RvcnlTdGlja2VyVHlwZTJbXCJQcm9tcHRcIl0gPSBcInByb21wdFwiO1xuICBOREtTdG9yeVN0aWNrZXJUeXBlMltcIlRleHRcIl0gPSBcInRleHRcIjtcbiAgTkRLU3RvcnlTdGlja2VyVHlwZTJbXCJDb3VudGRvd25cIl0gPSBcImNvdW50ZG93blwiO1xuICByZXR1cm4gTkRLU3RvcnlTdGlja2VyVHlwZTI7XG59KShOREtTdG9yeVN0aWNrZXJUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIHN0clRvUG9zaXRpb24ocG9zaXRpb25TdHIpIHtcbiAgY29uc3QgW3gsIHldID0gcG9zaXRpb25TdHIuc3BsaXQoXCIsXCIpLm1hcChOdW1iZXIpO1xuICByZXR1cm4geyB4LCB5IH07XG59XG5mdW5jdGlvbiBzdHJUb0RpbWVuc2lvbihkaW1lbnNpb25TdHIpIHtcbiAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gZGltZW5zaW9uU3RyLnNwbGl0KFwieFwiKS5tYXAoTnVtYmVyKTtcbiAgcmV0dXJuIHsgd2lkdGgsIGhlaWdodCB9O1xufVxudmFyIE5ES1N0b3J5U3RpY2tlciA9IGNsYXNzIF9OREtTdG9yeVN0aWNrZXIge1xuICBzdGF0aWMgVGV4dCA9IFwidGV4dFwiIC8qIFRleHQgKi87XG4gIHN0YXRpYyBQdWJrZXkgPSBcInB1YmtleVwiIC8qIFB1YmtleSAqLztcbiAgc3RhdGljIEV2ZW50ID0gXCJldmVudFwiIC8qIEV2ZW50ICovO1xuICBzdGF0aWMgUHJvbXB0ID0gXCJwcm9tcHRcIiAvKiBQcm9tcHQgKi87XG4gIHN0YXRpYyBDb3VudGRvd24gPSBcImNvdW50ZG93blwiIC8qIENvdW50ZG93biAqLztcbiAgdHlwZTtcbiAgdmFsdWU7XG4gIHBvc2l0aW9uO1xuICBkaW1lbnNpb247XG4gIHByb3BlcnRpZXM7XG4gIGNvbnN0cnVjdG9yKGFyZykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgIGNvbnN0IHRhZyA9IGFyZztcbiAgICAgIGlmICh0YWdbMF0gIT09IFwic3RpY2tlclwiIHx8IHRhZy5sZW5ndGggPCA1KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RpY2tlciB0YWdcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnR5cGUgPSB0YWdbMV07XG4gICAgICB0aGlzLnZhbHVlID0gdGFnWzJdO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHN0clRvUG9zaXRpb24odGFnWzNdKTtcbiAgICAgIHRoaXMuZGltZW5zaW9uID0gc3RyVG9EaW1lbnNpb24odGFnWzRdKTtcbiAgICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgICBmb3IgKGxldCBpID0gNTsgaSA8IHRhZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHRhZ1tpXS5zcGxpdChcIiBcIik7XG4gICAgICAgIHByb3BzW2tleV0gPSByZXN0LmpvaW4oXCIgXCIpO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnR5cGUgPSBhcmc7XG4gICAgICB0aGlzLnZhbHVlID0gdm9pZCAwO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgdGhpcy5kaW1lbnNpb24gPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb21UYWcodGFnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgX05ES1N0b3J5U3RpY2tlcih0YWcpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGdldCBzdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzPy5zdHlsZTtcbiAgfVxuICBzZXQgc3R5bGUoc3R5bGUpIHtcbiAgICBpZiAoc3R5bGUpIHRoaXMucHJvcGVydGllcyA9IHsgLi4udGhpcy5wcm9wZXJ0aWVzLCBzdHlsZSB9O1xuICAgIGVsc2UgZGVsZXRlIHRoaXMucHJvcGVydGllcz8uc3R5bGU7XG4gIH1cbiAgZ2V0IHJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXM/LnJvdCA/IE51bWJlci5wYXJzZUZsb2F0KHRoaXMucHJvcGVydGllcy5yb3QpIDogdm9pZCAwO1xuICB9XG4gIHNldCByb3RhdGlvbihyb3RhdGlvbikge1xuICAgIGlmIChyb3RhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMgPSB7IC4uLnRoaXMucHJvcGVydGllcywgcm90OiByb3RhdGlvbi50b1N0cmluZygpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnByb3BlcnRpZXM/LnJvdDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgc3RpY2tlciBpcyB2YWxpZC5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgc3RpY2tlciBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzVmFsaWREaW1lbnNpb25zKCkgJiYgdGhpcy5oYXNWYWxpZFBvc2l0aW9uKCk7XG4gIH1cbiAgaGFzVmFsaWREaW1lbnNpb25zID0gKCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5kaW1lbnNpb24ud2lkdGggPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHRoaXMuZGltZW5zaW9uLmhlaWdodCA9PT0gXCJudW1iZXJcIiAmJiAhTnVtYmVyLmlzTmFOKHRoaXMuZGltZW5zaW9uLndpZHRoKSAmJiAhTnVtYmVyLmlzTmFOKHRoaXMuZGltZW5zaW9uLmhlaWdodCk7XG4gIH07XG4gIGhhc1ZhbGlkUG9zaXRpb24gPSAoKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLnBvc2l0aW9uLnggPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHRoaXMucG9zaXRpb24ueSA9PT0gXCJudW1iZXJcIiAmJiAhTnVtYmVyLmlzTmFOKHRoaXMucG9zaXRpb24ueCkgJiYgIU51bWJlci5pc05hTih0aGlzLnBvc2l0aW9uLnkpO1xuICB9O1xuICB0b1RhZygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgY29uc3QgZXJyb3JzID0gW1xuICAgICAgICAhdGhpcy5oYXNWYWxpZERpbWVuc2lvbnMoKSA/IFwiZGltZW5zaW9ucyBpcyBpbnZhbGlkXCIgOiB2b2lkIDAsXG4gICAgICAgICF0aGlzLmhhc1ZhbGlkUG9zaXRpb24oKSA/IFwicG9zaXRpb24gaXMgaW52YWxpZFwiIDogdm9pZCAwXG4gICAgICBdLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGlja2VyOiAke2Vycm9ycy5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxuICAgIGxldCB2YWx1ZTtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBcImV2ZW50XCIgLyogRXZlbnQgKi86XG4gICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZS50YWdJZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwdWJrZXlcIiAvKiBQdWJrZXkgKi86XG4gICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZS5wdWJrZXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICBjb25zdCB0YWcgPSBbXCJzdGlja2VyXCIsIHRoaXMudHlwZSwgdmFsdWUsIGNvb3JkaW5hdGVzKHRoaXMucG9zaXRpb24pLCBkaW1lbnNpb24odGhpcy5kaW1lbnNpb24pXTtcbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHByb3BWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5wcm9wZXJ0aWVzKSkge1xuICAgICAgICB0YWcucHVzaChgJHtrZXl9ICR7cHJvcFZhbHVlfWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFnO1xuICB9XG59O1xudmFyIE5ES1N0b3J5ID0gY2xhc3MgX05ES1N0b3J5IGV4dGVuZHMgTkRLRXZlbnQge1xuICBzdGF0aWMga2luZCA9IDIzIC8qIFN0b3J5ICovO1xuICBzdGF0aWMga2luZHMgPSBbMjMgLyogU3RvcnkgKi9dO1xuICBfaW1ldGE7XG4gIF9kaW1lbnNpb25zO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAyMyAvKiBTdG9yeSAqLztcbiAgICBpZiAocmF3RXZlbnQpIHtcbiAgICAgIGZvciAoY29uc3QgdGFnIG9mIHJhd0V2ZW50LnRhZ3MpIHtcbiAgICAgICAgc3dpdGNoICh0YWdbMF0pIHtcbiAgICAgICAgICBjYXNlIFwiaW1ldGFcIjpcbiAgICAgICAgICAgIHRoaXMuX2ltZXRhID0gbWFwSW1ldGFUYWcodGFnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJkaW1cIjpcbiAgICAgICAgICAgIHRoaXMuZGltZW5zaW9ucyA9IHN0clRvRGltZW5zaW9uKHRhZ1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIE5ES1N0b3J5IGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES1N0b3J5IGZyb20uXG4gICAqIEByZXR1cm5zIE5ES1N0b3J5XG4gICAqL1xuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1N0b3J5KGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHN0b3J5IGlzIHZhbGlkIChoYXMgZXhhY3RseSBvbmUgaW1ldGEgdGFnKS5cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiAhIXRoaXMuaW1ldGE7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGZpcnN0IGltZXRhIHRhZyAodGhlcmUgc2hvdWxkIG9ubHkgYmUgb25lKS5cbiAgICovXG4gIGdldCBpbWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW1ldGE7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYSBzaW5nbGUgaW1ldGEgdGFnLCByZXBsYWNpbmcgYW55IGV4aXN0aW5nIG9uZXMuXG4gICAqL1xuICBzZXQgaW1ldGEodGFnKSB7XG4gICAgdGhpcy5faW1ldGEgPSB0YWc7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJpbWV0YVwiKTtcbiAgICBpZiAodGFnKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChpbWV0YVRhZ1RvVGFnKHRhZykpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgc3RvcnkgZGltZW5zaW9ucy5cbiAgICpcbiAgICogQHJldHVybnMge05ES1N0b3J5RGltZW5zaW9uIHwgdW5kZWZpbmVkfSAtIFRoZSBzdG9yeSBkaW1lbnNpb25zIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBkaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IGRpbVRhZyA9IHRoaXMudGFnVmFsdWUoXCJkaW1cIik7XG4gICAgaWYgKCFkaW1UYWcpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIHN0clRvRGltZW5zaW9uKGRpbVRhZyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIHN0b3J5IGRpbWVuc2lvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7TkRLU3RvcnlEaW1lbnNpb24gfCB1bmRlZmluZWR9IGRpbWVuc2lvbnMgLSBUaGUgZGltZW5zaW9ucyB0byBzZXQgZm9yIHRoZSBzdG9yeS5cbiAgICovXG4gIHNldCBkaW1lbnNpb25zKGRpbWVuc2lvbnMpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImRpbVwiKTtcbiAgICBpZiAoZGltZW5zaW9ucykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZGltXCIsIGAke2RpbWVuc2lvbnMud2lkdGh9eCR7ZGltZW5zaW9ucy5oZWlnaHR9YF0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgc3RvcnkgZHVyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9IC0gVGhlIHN0b3J5IGR1cmF0aW9uIGluIHNlY29uZHMgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIGNvbnN0IGR1clRhZyA9IHRoaXMudGFnVmFsdWUoXCJkdXJcIik7XG4gICAgaWYgKCFkdXJUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIE51bWJlci5wYXJzZUludChkdXJUYWcpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBzdG9yeSBkdXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGR1cmF0aW9uIC0gVGhlIGR1cmF0aW9uIGluIHNlY29uZHMgdG8gc2V0IGZvciB0aGUgc3RvcnkuXG4gICAqL1xuICBzZXQgZHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImR1clwiKTtcbiAgICBpZiAoZHVyYXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZHVyXCIsIGR1cmF0aW9uLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYWxsIHN0aWNrZXJzIGZyb20gdGhlIHN0b3J5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7TkRLU3RvcnlTdGlja2VyW119IC0gQXJyYXkgb2Ygc3RpY2tlcnMgaW4gdGhlIHN0b3J5LlxuICAgKi9cbiAgZ2V0IHN0aWNrZXJzKCkge1xuICAgIGNvbnN0IHN0aWNrZXJzID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAodGFnWzBdICE9PSBcInN0aWNrZXJcIiB8fCB0YWcubGVuZ3RoIDwgNSkgY29udGludWU7XG4gICAgICBjb25zdCBzdGlja2VyID0gTkRLU3RvcnlTdGlja2VyLmZyb21UYWcodGFnKTtcbiAgICAgIGlmIChzdGlja2VyKSBzdGlja2Vycy5wdXNoKHN0aWNrZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RpY2tlcnM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBzdGlja2VyIHRvIHRoZSBzdG9yeS5cbiAgICpcbiAgICogQHBhcmFtIHtOREtTdG9yeVN0aWNrZXJ8U3RvcnlTdGlja2VyfSBzdGlja2VyIC0gVGhlIHN0aWNrZXIgdG8gYWRkLlxuICAgKi9cbiAgYWRkU3RpY2tlcihzdGlja2VyKSB7XG4gICAgbGV0IHN0aWNrZXJUb0FkZDtcbiAgICBpZiAoc3RpY2tlciBpbnN0YW5jZW9mIE5ES1N0b3J5U3RpY2tlcikge1xuICAgICAgc3RpY2tlclRvQWRkID0gc3RpY2tlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFnID0gW1xuICAgICAgICBcInN0aWNrZXJcIixcbiAgICAgICAgc3RpY2tlci50eXBlLFxuICAgICAgICB0eXBlb2Ygc3RpY2tlci52YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHN0aWNrZXIudmFsdWUgOiBcIlwiLFxuICAgICAgICBjb29yZGluYXRlcyhzdGlja2VyLnBvc2l0aW9uKSxcbiAgICAgICAgZGltZW5zaW9uKHN0aWNrZXIuZGltZW5zaW9uKVxuICAgICAgXTtcbiAgICAgIGlmIChzdGlja2VyLnByb3BlcnRpZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc3RpY2tlci5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgIHRhZy5wdXNoKGAke2tleX0gJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RpY2tlclRvQWRkID0gbmV3IE5ES1N0b3J5U3RpY2tlcih0YWcpO1xuICAgICAgc3RpY2tlclRvQWRkLnZhbHVlID0gc3RpY2tlci52YWx1ZTtcbiAgICB9XG4gICAgaWYgKHN0aWNrZXJUb0FkZC50eXBlID09PSBcInB1YmtleVwiIC8qIFB1YmtleSAqLykge1xuICAgICAgdGhpcy50YWcoc3RpY2tlclRvQWRkLnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHN0aWNrZXJUb0FkZC50eXBlID09PSBcImV2ZW50XCIgLyogRXZlbnQgKi8pIHtcbiAgICAgIHRoaXMudGFnKHN0aWNrZXJUb0FkZC52YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMudGFncy5wdXNoKHN0aWNrZXJUb0FkZC50b1RhZygpKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIHN0aWNrZXIgZnJvbSB0aGUgc3RvcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgc3RpY2tlciB0byByZW1vdmUuXG4gICAqL1xuICByZW1vdmVTdGlja2VyKGluZGV4KSB7XG4gICAgY29uc3Qgc3RpY2tlcnMgPSB0aGlzLnN0aWNrZXJzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc3RpY2tlcnMubGVuZ3RoKSByZXR1cm47XG4gICAgbGV0IHN0aWNrZXJDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLnRhZ3NbaV1bMF0gPT09IFwic3RpY2tlclwiKSB7XG4gICAgICAgIGlmIChzdGlja2VyQ291bnQgPT09IGluZGV4KSB7XG4gICAgICAgICAgdGhpcy50YWdzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGlja2VyQ291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgY29vcmRpbmF0ZXMgPSAocG9zaXRpb24pID0+IGAke3Bvc2l0aW9uLnh9LCR7cG9zaXRpb24ueX1gO1xudmFyIGRpbWVuc2lvbiA9IChkaW1lbnNpb24yKSA9PiBgJHtkaW1lbnNpb24yLndpZHRofXgke2RpbWVuc2lvbjIuaGVpZ2h0fWA7XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc3Vic2NyaXB0aW9ucy9hbW91bnQudHNcbnZhciBwb3NzaWJsZUludGVydmFsRnJlcXVlbmNpZXMgPSBbXG4gIFwiZGFpbHlcIixcbiAgXCJ3ZWVrbHlcIixcbiAgXCJtb250aGx5XCIsXG4gIFwicXVhcnRlcmx5XCIsXG4gIFwieWVhcmx5XCJcbl07XG5mdW5jdGlvbiBjYWxjdWxhdGVUZXJtRHVyYXRpb25JblNlY29uZHModGVybSkge1xuICBzd2l0Y2ggKHRlcm0pIHtcbiAgICBjYXNlIFwiZGFpbHlcIjpcbiAgICAgIHJldHVybiAyNCAqIDYwICogNjA7XG4gICAgY2FzZSBcIndlZWtseVwiOlxuICAgICAgcmV0dXJuIDcgKiAyNCAqIDYwICogNjA7XG4gICAgY2FzZSBcIm1vbnRobHlcIjpcbiAgICAgIHJldHVybiAzMCAqIDI0ICogNjAgKiA2MDtcbiAgICBjYXNlIFwicXVhcnRlcmx5XCI6XG4gICAgICByZXR1cm4gMyAqIDMwICogMjQgKiA2MCAqIDYwO1xuICAgIGNhc2UgXCJ5ZWFybHlcIjpcbiAgICAgIHJldHVybiAzNjUgKiAyNCAqIDYwICogNjA7XG4gIH1cbn1cbmZ1bmN0aW9uIG5ld0Ftb3VudChhbW91bnQsIGN1cnJlbmN5LCB0ZXJtKSB7XG4gIHJldHVybiBbXCJhbW91bnRcIiwgYW1vdW50LnRvU3RyaW5nKCksIGN1cnJlbmN5LCB0ZXJtXTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGFnVG9TdWJzY3JpcHRpb25BbW91bnQodGFnKSB7XG4gIGNvbnN0IGFtb3VudCA9IE51bWJlci5wYXJzZUludCh0YWdbMV0pO1xuICBpZiAoTnVtYmVyLmlzTmFOKGFtb3VudCkgfHwgYW1vdW50ID09PSB2b2lkIDAgfHwgYW1vdW50ID09PSBudWxsIHx8IGFtb3VudCA8PSAwKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBjdXJyZW5jeSA9IHRhZ1syXTtcbiAgaWYgKGN1cnJlbmN5ID09PSB2b2lkIDAgfHwgY3VycmVuY3kgPT09IFwiXCIpIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IHRlcm0gPSB0YWdbM107XG4gIGlmICh0ZXJtID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gIGlmICghcG9zc2libGVJbnRlcnZhbEZyZXF1ZW5jaWVzLmluY2x1ZGVzKHRlcm0pKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4ge1xuICAgIGFtb3VudCxcbiAgICBjdXJyZW5jeSxcbiAgICB0ZXJtXG4gIH07XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc3Vic2NyaXB0aW9ucy90aWVyLnRzXG52YXIgTkRLU3Vic2NyaXB0aW9uVGllciA9IGNsYXNzIF9OREtTdWJzY3JpcHRpb25UaWVyIGV4dGVuZHMgTkRLQXJ0aWNsZSB7XG4gIHN0YXRpYyBraW5kID0gMzcwMDEgLyogU3Vic2NyaXB0aW9uVGllciAqLztcbiAgc3RhdGljIGtpbmRzID0gWzM3MDAxIC8qIFN1YnNjcmlwdGlvblRpZXIgKi9dO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgY29uc3QgayA9IHJhd0V2ZW50Py5raW5kID8/IDM3MDAxIC8qIFN1YnNjcmlwdGlvblRpZXIgKi87XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID0gaztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBOREtTdWJzY3JpcHRpb25UaWVyIGZyb20gYW4gZXZlbnRcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEByZXR1cm5zIE5ES1N1YnNjcmlwdGlvblRpZXJcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLU3Vic2NyaXB0aW9uVGllcihldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwZXJrcyBmb3IgdGhpcyB0aWVyXG4gICAqL1xuICBnZXQgcGVya3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicGVya1wiKS5tYXAoKHRhZykgPT4gdGFnWzFdKS5maWx0ZXIoKHBlcmspID0+IHBlcmsgIT09IHZvaWQgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBwZXJrIHRvIHRoaXMgdGllclxuICAgKi9cbiAgYWRkUGVyayhwZXJrKSB7XG4gICAgdGhpcy50YWdzLnB1c2goW1wicGVya1wiLCBwZXJrXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFtb3VudCBmb3IgdGhpcyB0aWVyXG4gICAqL1xuICBnZXQgYW1vdW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIikubWFwKCh0YWcpID0+IHBhcnNlVGFnVG9TdWJzY3JpcHRpb25BbW91bnQodGFnKSkuZmlsdGVyKChhKSA9PiBhICE9PSB2b2lkIDApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIGFtb3VudCB0byB0aGlzIHRpZXJcbiAgICogQHBhcmFtIGFtb3VudCBBbW91bnQgaW4gdGhlIHNtYWxsZXN0IHVuaXQgb2YgdGhlIGN1cnJlbmN5IChlLmcuIGNlbnRzLCBtc2F0cylcbiAgICogQHBhcmFtIGN1cnJlbmN5IEN1cnJlbmN5IGNvZGUuIFVzZSBtc2F0IGZvciBtaWxsaXNhdG9zaGlzXG4gICAqIEBwYXJhbSB0ZXJtIE9uZSBvZiBkYWlseSwgd2Vla2x5LCBtb250aGx5LCBxdWFydGVybHksIHllYXJseVxuICAgKi9cbiAgYWRkQW1vdW50KGFtb3VudCwgY3VycmVuY3ksIHRlcm0pIHtcbiAgICB0aGlzLnRhZ3MucHVzaChuZXdBbW91bnQoYW1vdW50LCBjdXJyZW5jeSwgdGVybSkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgcmVsYXkgd2hlcmUgY29udGVudCByZWxhdGVkIHRvIHRoaXMgdGllciBjYW4gYmUgZm91bmRcbiAgICogQHBhcmFtIHJlbGF5VXJsIFVSTCBvZiB0aGUgcmVsYXlcbiAgICovXG4gIHNldCByZWxheVVybChyZWxheVVybCkge1xuICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgcmVsYXlVcmxdKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVsYXkgVVJMcyBmb3IgdGhpcyB0aWVyXG4gICAqL1xuICBnZXQgcmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcInJcIikubWFwKCh0YWcpID0+IHRhZ1sxXSkuZmlsdGVyKChyZWxheSkgPT4gcmVsYXkgIT09IHZvaWQgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZlcmlmaWVyIHB1YmtleSBmb3IgdGhpcyB0aWVyLiBUaGlzIGlzIHRoZSBwdWJrZXkgdGhhdCB3aWxsIGdlbmVyYXRlXG4gICAqIHN1YnNjcmlwdGlvbiBwYXltZW50IHJlY2VpcHRzXG4gICAqL1xuICBnZXQgdmVyaWZpZXJQdWJrZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJwXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2ZXJpZmllciBwdWJrZXkgZm9yIHRoaXMgdGllci5cbiAgICovXG4gIHNldCB2ZXJpZmllclB1YmtleShwdWJrZXkpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgaWYgKHB1YmtleSkgdGhpcy50YWdzLnB1c2goW1wicFwiLCBwdWJrZXldKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgdGllciBpcyB2YWxpZFxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGl0bGUgIT09IHZvaWQgMCAmJiAvLyBNdXN0IGhhdmUgYSB0aXRsZVxuICAgIHRoaXMuYW1vdW50cy5sZW5ndGggPiAwO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3ZpZGVvLnRzXG52YXIgTkRLVmlkZW8gPSBjbGFzcyBfTkRLVmlkZW8gZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMjEgLyogVmlkZW8gKi87XG4gIHN0YXRpYyBraW5kcyA9IFszNDIzNSAvKiBIb3Jpem9udGFsVmlkZW8gKi8sIDM0MjM2IC8qIFZlcnRpY2FsVmlkZW8gKi8sIDIyIC8qIFNob3J0VmlkZW8gKi8sIDIxIC8qIFZpZGVvICovXTtcbiAgX2ltZXRhcztcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOREtBcnRpY2xlIGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES0FydGljbGUgZnJvbS5cbiAgICogQHJldHVybnMgTkRLQXJ0aWNsZVxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtWaWRlbyhldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlIHRpdGxlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gdGl0bGUgLSBUaGUgdGl0bGUgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRodW1ibmFpbC5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgYXJ0aWNsZSB0aHVtYm5haWwgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHRodW1ibmFpbCgpIHtcbiAgICBsZXQgdGh1bWJuYWlsO1xuICAgIGlmICh0aGlzLmltZXRhcyAmJiB0aGlzLmltZXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHVtYm5haWwgPSB0aGlzLmltZXRhc1swXS5pbWFnZT8uWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdGh1bWJuYWlsID8/IHRoaXMudGFnVmFsdWUoXCJ0aHVtYlwiKTtcbiAgfVxuICBnZXQgaW1ldGFzKCkge1xuICAgIGlmICh0aGlzLl9pbWV0YXMpIHJldHVybiB0aGlzLl9pbWV0YXM7XG4gICAgdGhpcy5faW1ldGFzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiaW1ldGFcIikubWFwKG1hcEltZXRhVGFnKTtcbiAgICByZXR1cm4gdGhpcy5faW1ldGFzO1xuICB9XG4gIHNldCBpbWV0YXModGFncykge1xuICAgIHRoaXMuX2ltZXRhcyA9IHRhZ3M7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwiaW1ldGFcIik7XG4gICAgdGhpcy50YWdzLnB1c2goLi4udGFncy5tYXAoaW1ldGFUYWdUb1RhZykpO1xuICB9XG4gIGdldCB1cmwoKSB7XG4gICAgaWYgKHRoaXMuaW1ldGFzICYmIHRoaXMuaW1ldGFzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmltZXRhc1swXS51cmw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidXJsXCIpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlJ3MgcHVibGljYXRpb24gdGltZXN0YW1wLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfSAtIFRoZSBVbml4IHRpbWVzdGFtcCBvZiB3aGVuIHRoZSBhcnRpY2xlIHdhcyBwdWJsaXNoZWQgb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHB1Ymxpc2hlZF9hdCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwicHVibGlzaGVkX2F0XCIpO1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQodGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvbnRlbnQgdGFncyBmb3IgdGhlIGFydGljbGUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZpcnN0IGNoZWNrcyBhbmQgc2V0cyB0aGUgcHVibGljYXRpb24gZGF0ZSBpZiBub3QgYXZhaWxhYmxlLFxuICAgKiBhbmQgdGhlbiBnZW5lcmF0ZXMgY29udGVudCB0YWdzIGJhc2VkIG9uIHRoZSBiYXNlIE5ES0V2ZW50IGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gLSBUaGUgZ2VuZXJhdGVkIGNvbnRlbnQgdGFncy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlVGFncygpIHtcbiAgICBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgICBpZiAoIXRoaXMua2luZCkge1xuICAgICAgaWYgKHRoaXMuaW1ldGFzPy5bMF0/LmRpbSkge1xuICAgICAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLmltZXRhc1swXS5kaW0uc3BsaXQoXCJ4XCIpO1xuICAgICAgICBjb25zdCBpc1BvcnRyYWl0ID0gd2lkdGggJiYgaGVpZ2h0ICYmIE51bWJlci5wYXJzZUludCh3aWR0aCkgPCBOdW1iZXIucGFyc2VJbnQoaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgaXNTaG9ydCA9IHRoaXMuZHVyYXRpb24gJiYgdGhpcy5kdXJhdGlvbiA8IDEyMDtcbiAgICAgICAgaWYgKGlzU2hvcnQgJiYgaXNQb3J0cmFpdCkgdGhpcy5raW5kID0gMjIgLyogU2hvcnRWaWRlbyAqLztcbiAgICAgICAgZWxzZSB0aGlzLmtpbmQgPSAyMSAvKiBWaWRlbyAqLztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICB9XG4gIGdldCBkdXJhdGlvbigpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwiZHVyYXRpb25cIik7XG4gICAgaWYgKHRhZykge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludCh0YWcpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSB2aWRlbydzIGR1cmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBkdXJhdGlvbiAtIFRoZSBkdXJhdGlvbiB0byBzZXQgZm9yIHRoZSB2aWRlbyAoaW4gc2Vjb25kcylcbiAgICovXG4gIHNldCBkdXJhdGlvbihkdXIpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImR1cmF0aW9uXCIpO1xuICAgIGlmIChkdXIgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZHVyYXRpb25cIiwgTWF0aC5mbG9vcihkdXIpLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvd2lraS50c1xudmFyIE5ES1dpa2kgPSBjbGFzcyBleHRlbmRzIE5ES0FydGljbGUge1xuICBzdGF0aWMga2luZCA9IDMwODE4IC8qIFdpa2kgKi87XG4gIHN0YXRpYyBraW5kcyA9IFszMDgxOCAvKiBXaWtpICovXTtcbn07XG5cbi8vIHNyYy9ldmVudHMvd3JhcC50c1xuZnVuY3Rpb24gd3JhcEV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IGV2ZW50V3JhcHBpbmdNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IGtsYXNzMiBvZiBbXG4gICAgTkRLSW1hZ2UsXG4gICAgTkRLVmlkZW8sXG4gICAgTkRLQ2FzaHVNaW50TGlzdCxcbiAgICBOREtBcnRpY2xlLFxuICAgIE5ES0hpZ2hsaWdodCxcbiAgICBOREtXaWtpLFxuICAgIE5ES051dHphcCxcbiAgICBOREtTaW1wbGVHcm91cE1lbWJlckxpc3QsXG4gICAgTkRLU2ltcGxlR3JvdXBNZXRhZGF0YSxcbiAgICBOREtTdWJzY3JpcHRpb25UaWVyLFxuICAgIE5ES0Nhc2h1VG9rZW4sXG4gICAgTkRLTGlzdCxcbiAgICBOREtTdG9yeVxuICBdKSB7XG4gICAgZm9yIChjb25zdCBraW5kIG9mIGtsYXNzMi5raW5kcykge1xuICAgICAgZXZlbnRXcmFwcGluZ01hcC5zZXQoa2luZCwga2xhc3MyKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qga2xhc3MgPSBldmVudFdyYXBwaW5nTWFwLmdldChldmVudC5raW5kKTtcbiAgaWYgKGtsYXNzKSByZXR1cm4ga2xhc3MuZnJvbShldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gc3JjL3N1YnNjcmlwdGlvbi91dGlscy50c1xuaW1wb3J0IHsgbmlwMTkgYXMgbmlwMTk0IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG52YXIgTUFYX1NVQklEX0xFTkdUSCA9IDIwO1xuZnVuY3Rpb24gcXVlcnlGdWxseUZpbGxlZChzdWJzY3JpcHRpb24pIHtcbiAgaWYgKGZpbHRlckluY2x1ZGVzSWRzKHN1YnNjcmlwdGlvbi5maWx0ZXIpKSB7XG4gICAgaWYgKHJlc3VsdEhhc0FsbFJlcXVlc3RlZElkcyhzdWJzY3JpcHRpb24pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29tcGFyZUZpbHRlcihmaWx0ZXIxLCBmaWx0ZXIyKSB7XG4gIGlmIChPYmplY3Qua2V5cyhmaWx0ZXIxKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGZpbHRlcjIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWx0ZXIxKSkge1xuICAgIGNvbnN0IHZhbHVlc0luRmlsdGVyMiA9IGZpbHRlcjJba2V5XTtcbiAgICBpZiAoIXZhbHVlc0luRmlsdGVyMikgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlc0luRmlsdGVyMikpIHtcbiAgICAgIGNvbnN0IHYgPSB2YWx1ZTtcbiAgICAgIGZvciAoY29uc3QgdmFsdWVJbkZpbHRlcjIgb2YgdmFsdWVzSW5GaWx0ZXIyKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHZhbHVlSW5GaWx0ZXIyO1xuICAgICAgICBpZiAoIXYuaW5jbHVkZXModmFsKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWVzSW5GaWx0ZXIyICE9PSB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGZpbHRlckluY2x1ZGVzSWRzKGZpbHRlcikge1xuICByZXR1cm4gISFmaWx0ZXIuaWRzO1xufVxuZnVuY3Rpb24gcmVzdWx0SGFzQWxsUmVxdWVzdGVkSWRzKHN1YnNjcmlwdGlvbikge1xuICBjb25zdCBpZHMgPSBzdWJzY3JpcHRpb24uZmlsdGVyLmlkcztcbiAgcmV0dXJuICEhaWRzICYmIGlkcy5sZW5ndGggPT09IHN1YnNjcmlwdGlvbi5ldmVudEZpcnN0U2Vlbi5zaXplO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVTdWJJZChzdWJzY3JpcHRpb25zLCBmaWx0ZXJzKSB7XG4gIGNvbnN0IHN1YklkcyA9IHN1YnNjcmlwdGlvbnMubWFwKChzdWIpID0+IHN1Yi5zdWJJZCkuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBzdWJJZFBhcnRzID0gW107XG4gIGNvbnN0IGZpbHRlck5vbktpbmRLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgZmlsdGVyS2luZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBpZiAoc3ViSWRzLmxlbmd0aCA+IDApIHtcbiAgICBzdWJJZFBhcnRzLnB1c2goQXJyYXkuZnJvbShuZXcgU2V0KHN1YklkcykpLmpvaW4oXCIsXCIpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBmaWx0ZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhmaWx0ZXIpKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwia2luZHNcIikge1xuICAgICAgICAgIGZpbHRlci5raW5kcz8uZm9yRWFjaCgoaykgPT4gZmlsdGVyS2luZHMuYWRkKGspKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWx0ZXJOb25LaW5kS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmlsdGVyS2luZHMuc2l6ZSA+IDApIHtcbiAgICAgIHN1YklkUGFydHMucHVzaChga2luZHM6JHtBcnJheS5mcm9tKGZpbHRlcktpbmRzKS5qb2luKFwiLFwiKX1gKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlck5vbktpbmRLZXlzLnNpemUgPiAwKSB7XG4gICAgICBzdWJJZFBhcnRzLnB1c2goQXJyYXkuZnJvbShmaWx0ZXJOb25LaW5kS2V5cykuam9pbihcIixcIikpO1xuICAgIH1cbiAgfVxuICBsZXQgc3ViSWQgPSBzdWJJZFBhcnRzLmpvaW4oXCItXCIpO1xuICBpZiAoc3ViSWQubGVuZ3RoID4gTUFYX1NVQklEX0xFTkdUSCkgc3ViSWQgPSBzdWJJZC5zdWJzdHJpbmcoMCwgTUFYX1NVQklEX0xFTkdUSCk7XG4gIHN1YklkICs9IGAtJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA5OTkpLnRvU3RyaW5nKCl9YDtcbiAgcmV0dXJuIHN1YklkO1xufVxuZnVuY3Rpb24gZmlsdGVyRm9yRXZlbnRzVGFnZ2luZ0lkKGlkKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IG5pcDE5NC5kZWNvZGUoaWQpO1xuICAgIHN3aXRjaCAoZGVjb2RlZC50eXBlKSB7XG4gICAgICBjYXNlIFwibmFkZHJcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBcIiNhXCI6IFtgJHtkZWNvZGVkLmRhdGEua2luZH06JHtkZWNvZGVkLmRhdGEucHVia2V5fToke2RlY29kZWQuZGF0YS5pZGVudGlmaWVyfWBdXG4gICAgICAgIH07XG4gICAgICBjYXNlIFwibmV2ZW50XCI6XG4gICAgICAgIHJldHVybiB7IFwiI2VcIjogW2RlY29kZWQuZGF0YS5pZF0gfTtcbiAgICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICAgIHJldHVybiB7IFwiI2VcIjogW2RlY29kZWQuZGF0YV0gfTtcbiAgICAgIGNhc2UgXCJucHJvZmlsZVwiOlxuICAgICAgICByZXR1cm4geyBcIiNwXCI6IFtkZWNvZGVkLmRhdGEucHVia2V5XSB9O1xuICAgICAgY2FzZSBcIm5wdWJcIjpcbiAgICAgICAgcmV0dXJuIHsgXCIjcFwiOiBbZGVjb2RlZC5kYXRhXSB9O1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbHRlckFuZFJlbGF5U2V0RnJvbUJlY2gzMihiZWNoZTIsIG5kaykge1xuICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJGcm9tSWQoYmVjaGUyKTtcbiAgY29uc3QgcmVsYXlzID0gcmVsYXlzRnJvbUJlY2gzMihiZWNoZTIsIG5kayk7XG4gIGlmIChyZWxheXMubGVuZ3RoID09PSAwKSByZXR1cm4geyBmaWx0ZXIgfTtcbiAgcmV0dXJuIHtcbiAgICBmaWx0ZXIsXG4gICAgcmVsYXlTZXQ6IG5ldyBOREtSZWxheVNldChuZXcgU2V0KHJlbGF5cyksIG5kaylcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlckZyb21JZChpZCkge1xuICBsZXQgZGVjb2RlZDtcbiAgaWYgKGlkLm1hdGNoKE5JUDMzX0FfUkVHRVgpKSB7XG4gICAgY29uc3QgW2tpbmQsIHB1YmtleSwgaWRlbnRpZmllcl0gPSBpZC5zcGxpdChcIjpcIik7XG4gICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgYXV0aG9yczogW3B1YmtleV0sXG4gICAgICBraW5kczogW051bWJlci5wYXJzZUludChraW5kKV1cbiAgICB9O1xuICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICBmaWx0ZXJbXCIjZFwiXSA9IFtpZGVudGlmaWVyXTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcjtcbiAgfVxuICBpZiAoaWQubWF0Y2goQkVDSDMyX1JFR0VYKSkge1xuICAgIHRyeSB7XG4gICAgICBkZWNvZGVkID0gbmlwMTk0LmRlY29kZShpZCk7XG4gICAgICBzd2l0Y2ggKGRlY29kZWQudHlwZSkge1xuICAgICAgICBjYXNlIFwibmV2ZW50XCI6IHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB7IGlkczogW2RlY29kZWQuZGF0YS5pZF0gfTtcbiAgICAgICAgICBpZiAoZGVjb2RlZC5kYXRhLmF1dGhvcikgZmlsdGVyLmF1dGhvcnMgPSBbZGVjb2RlZC5kYXRhLmF1dGhvcl07XG4gICAgICAgICAgaWYgKGRlY29kZWQuZGF0YS5raW5kKSBmaWx0ZXIua2luZHMgPSBbZGVjb2RlZC5kYXRhLmtpbmRdO1xuICAgICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm5vdGVcIjpcbiAgICAgICAgICByZXR1cm4geyBpZHM6IFtkZWNvZGVkLmRhdGFdIH07XG4gICAgICAgIGNhc2UgXCJuYWRkclwiOiB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgICAgYXV0aG9yczogW2RlY29kZWQuZGF0YS5wdWJrZXldLFxuICAgICAgICAgICAga2luZHM6IFtkZWNvZGVkLmRhdGEua2luZF1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChkZWNvZGVkLmRhdGEuaWRlbnRpZmllcikgZmlsdGVyW1wiI2RcIl0gPSBbZGVjb2RlZC5kYXRhLmlkZW50aWZpZXJdO1xuICAgICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGVjb2RpbmdcIiwgaWQsIGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBpZHM6IFtpZF0gfTtcbn1cbmZ1bmN0aW9uIGlzTmlwMzNBVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLm1hdGNoKE5JUDMzX0FfUkVHRVgpICE9PSBudWxsO1xufVxudmFyIE5JUDMzX0FfUkVHRVggPSAvXihcXGQrKTooWzAtOUEtRmEtZl0rKSg/OjooLiopKT8kLztcbnZhciBCRUNIMzJfUkVHRVggPSAvXm4oZXZlbnR8b3RlfHByb2ZpbGV8cHVifGFkZHIpMVtcXGRcXHddKyQvO1xuZnVuY3Rpb24gcmVsYXlzRnJvbUJlY2gzMihiZWNoMzIyLCBuZGspIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkZWNvZGVkID0gbmlwMTk0LmRlY29kZShiZWNoMzIyKTtcbiAgICBpZiAoW1wibmFkZHJcIiwgXCJuZXZlbnRcIl0uaW5jbHVkZXMoZGVjb2RlZD8udHlwZSkpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBkZWNvZGVkLmRhdGE7XG4gICAgICBpZiAoZGF0YT8ucmVsYXlzKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnJlbGF5cy5tYXAoKHIpID0+IG5ldyBOREtSZWxheShyLCBuZGsucmVsYXlBdXRoRGVmYXVsdFBvbGljeSwgbmRrKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChfZSkge1xuICB9XG4gIHJldHVybiBbXTtcbn1cblxuLy8gc3JjL3N1YnNjcmlwdGlvbi9pbmRleC50c1xudmFyIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UgPSAvKiBAX19QVVJFX18gKi8gKChOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlMikgPT4ge1xuICBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlMltcIk9OTFlfQ0FDSEVcIl0gPSBcIk9OTFlfQ0FDSEVcIjtcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTJbXCJDQUNIRV9GSVJTVFwiXSA9IFwiQ0FDSEVfRklSU1RcIjtcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTJbXCJQQVJBTExFTFwiXSA9IFwiUEFSQUxMRUxcIjtcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTJbXCJPTkxZX1JFTEFZXCJdID0gXCJPTkxZX1JFTEFZXCI7XG4gIHJldHVybiBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlMjtcbn0pKE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UgfHwge30pO1xudmFyIGRlZmF1bHRPcHRzID0ge1xuICBjbG9zZU9uRW9zZTogZmFsc2UsXG4gIGNhY2hlVXNhZ2U6IFwiQ0FDSEVfRklSU1RcIiAvKiBDQUNIRV9GSVJTVCAqLyxcbiAgZG9udFNhdmVUb0NhY2hlOiBmYWxzZSxcbiAgZ3JvdXBhYmxlOiB0cnVlLFxuICBncm91cGFibGVEZWxheTogMTAwLFxuICBncm91cGFibGVEZWxheVR5cGU6IFwiYXQtbW9zdFwiLFxuICBjYWNoZVVuY29uc3RyYWluRmlsdGVyOiBbXCJsaW1pdFwiLCBcInNpbmNlXCIsIFwidW50aWxcIl1cbn07XG52YXIgTkRLU3Vic2NyaXB0aW9uID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXI0IHtcbiAgc3ViSWQ7XG4gIGZpbHRlcnM7XG4gIG9wdHM7XG4gIHBvb2w7XG4gIHNraXBWZXJpZmljYXRpb24gPSBmYWxzZTtcbiAgc2tpcFZhbGlkYXRpb24gPSBmYWxzZTtcbiAgLyoqXG4gICAqIFRyYWNrcyB0aGUgZmlsdGVycyBhcyB0aGV5IGFyZSBleGVjdXRlZCBvbiBlYWNoIHJlbGF5XG4gICAqL1xuICByZWxheUZpbHRlcnM7XG4gIHJlbGF5U2V0O1xuICBuZGs7XG4gIGRlYnVnO1xuICAvKipcbiAgICogRXZlbnRzIHRoYXQgaGF2ZSBiZWVuIHNlZW4gYnkgdGhlIHN1YnNjcmlwdGlvbiwgd2l0aCB0aGUgdGltZSB0aGV5IHdlcmUgZmlyc3Qgc2Vlbi5cbiAgICovXG4gIGV2ZW50Rmlyc3RTZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLyoqXG4gICAqIFJlbGF5cyB0aGF0IGhhdmUgc2VudCBhbiBFT1NFLlxuICAgKi9cbiAgZW9zZXNTZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgLyoqXG4gICAqIFRoZSB0aW1lIHRoZSBsYXN0IGV2ZW50IHdhcyByZWNlaXZlZCBieSB0aGUgc3Vic2NyaXB0aW9uLlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHdoZW4gRU9TRSBzaG91bGQgYmUgZW1pdHRlZC5cbiAgICovXG4gIGxhc3RFdmVudFJlY2VpdmVkQXQ7XG4gIC8qKlxuICAgKiBUaGUgbW9zdCByZWNlbnQgZXZlbnQgdGltZXN0YW1wIGZyb20gY2FjaGUgcmVzdWx0cy5cbiAgICogVGhpcyBpcyB1c2VkIGZvciBhZGRTaW5jZUZyb21DYWNoZSBmdW5jdGlvbmFsaXR5LlxuICAgKi9cbiAgbW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXA7XG4gIGludGVybmFsSWQ7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdWJzY3JpcHRpb24gc2hvdWxkIGNsb3NlIHdoZW4gYWxsIHJlbGF5cyBoYXZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgc3RyZWFtLlxuICAgKi9cbiAgY2xvc2VPbkVvc2U7XG4gIC8qKlxuICAgKiBQb29sIG1vbml0b3IgY2FsbGJhY2tcbiAgICovXG4gIHBvb2xNb25pdG9yO1xuICBza2lwT3B0aW1pc3RpY1B1Ymxpc2hFdmVudCA9IGZhbHNlO1xuICAvKipcbiAgICogRmlsdGVycyB0byByZW1vdmUgd2hlbiBxdWVyeWluZyB0aGUgY2FjaGUuXG4gICAqL1xuICBjYWNoZVVuY29uc3RyYWluRmlsdGVyO1xuICBjb25zdHJ1Y3RvcihuZGssIGZpbHRlcnMsIG9wdHMsIHN1YklkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRzLCAuLi5vcHRzIHx8IHt9IH07XG4gICAgdGhpcy5wb29sID0gdGhpcy5vcHRzLnBvb2wgfHwgbmRrLnBvb2w7XG4gICAgdGhpcy5maWx0ZXJzID0gQXJyYXkuaXNBcnJheShmaWx0ZXJzKSA/IGZpbHRlcnMgOiBbZmlsdGVyc107XG4gICAgdGhpcy5zdWJJZCA9IHN1YklkIHx8IHRoaXMub3B0cy5zdWJJZDtcbiAgICB0aGlzLmludGVybmFsSWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyk7XG4gICAgdGhpcy5kZWJ1ZyA9IG5kay5kZWJ1Zy5leHRlbmQoYHN1YnNjcmlwdGlvblske3RoaXMub3B0cy5zdWJJZCA/PyB0aGlzLmludGVybmFsSWR9XWApO1xuICAgIGlmICh0aGlzLm9wdHMucmVsYXlTZXQpIHtcbiAgICAgIHRoaXMucmVsYXlTZXQgPSB0aGlzLm9wdHMucmVsYXlTZXQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdHMucmVsYXlVcmxzKSB7XG4gICAgICB0aGlzLnJlbGF5U2V0ID0gTkRLUmVsYXlTZXQuZnJvbVJlbGF5VXJscyh0aGlzLm9wdHMucmVsYXlVcmxzLCB0aGlzLm5kayk7XG4gICAgfVxuICAgIHRoaXMuc2tpcFZlcmlmaWNhdGlvbiA9IHRoaXMub3B0cy5za2lwVmVyaWZpY2F0aW9uIHx8IGZhbHNlO1xuICAgIHRoaXMuc2tpcFZhbGlkYXRpb24gPSB0aGlzLm9wdHMuc2tpcFZhbGlkYXRpb24gfHwgZmFsc2U7XG4gICAgdGhpcy5jbG9zZU9uRW9zZSA9IHRoaXMub3B0cy5jbG9zZU9uRW9zZSB8fCBmYWxzZTtcbiAgICB0aGlzLnNraXBPcHRpbWlzdGljUHVibGlzaEV2ZW50ID0gdGhpcy5vcHRzLnNraXBPcHRpbWlzdGljUHVibGlzaEV2ZW50IHx8IGZhbHNlO1xuICAgIHRoaXMuY2FjaGVVbmNvbnN0cmFpbkZpbHRlciA9IHRoaXMub3B0cy5jYWNoZVVuY29uc3RyYWluRmlsdGVyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZWxheXMgdGhhdCBoYXZlIG5vdCB5ZXQgc2VudCBhbiBFT1NFLlxuICAgKi9cbiAgcmVsYXlzTWlzc2luZ0Vvc2UoKSB7XG4gICAgaWYgKCF0aGlzLnJlbGF5RmlsdGVycykgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHJlbGF5c01pc3NpbmdFb3NlID0gQXJyYXkuZnJvbSh0aGlzLnJlbGF5RmlsdGVycz8ua2V5cygpKS5maWx0ZXIoXG4gICAgICAodXJsKSA9PiAhdGhpcy5lb3Nlc1NlZW4uaGFzKHRoaXMucG9vbC5nZXRSZWxheSh1cmwsIGZhbHNlLCBmYWxzZSkpXG4gICAgKTtcbiAgICByZXR1cm4gcmVsYXlzTWlzc2luZ0Vvc2U7XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGFjY2VzcyB0byB0aGUgZmlyc3QgZmlsdGVyIG9mIHRoZSBzdWJzY3JpcHRpb24gZm9yXG4gICAqIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgKi9cbiAgZ2V0IGZpbHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXJzWzBdO1xuICB9XG4gIGdldCBncm91cGFibGVEZWxheSgpIHtcbiAgICBpZiAoIXRoaXMuaXNHcm91cGFibGUoKSkgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy5vcHRzPy5ncm91cGFibGVEZWxheTtcbiAgfVxuICBnZXQgZ3JvdXBhYmxlRGVsYXlUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLm9wdHM/Lmdyb3VwYWJsZURlbGF5VHlwZSB8fCBcImF0LW1vc3RcIjtcbiAgfVxuICBpc0dyb3VwYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRzPy5ncm91cGFibGUgfHwgZmFsc2U7XG4gIH1cbiAgc2hvdWxkUXVlcnlDYWNoZSgpIHtcbiAgICBpZiAodGhpcy5vcHRzLmFkZFNpbmNlRnJvbUNhY2hlKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5vcHRzPy5jYWNoZVVzYWdlID09PSBcIk9OTFlfUkVMQVlcIiAvKiBPTkxZX1JFTEFZICovKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgaGFzTm9uRXBoZW1lcmFsS2luZCA9IHRoaXMuZmlsdGVycy5zb21lKChmKSA9PiBmLmtpbmRzPy5zb21lKChrKSA9PiBraW5kSXNFcGhlbWVyYWwoaykpKTtcbiAgICBpZiAoaGFzTm9uRXBoZW1lcmFsS2luZCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2hvdWxkUXVlcnlSZWxheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0cz8uY2FjaGVVc2FnZSAhPT0gXCJPTkxZX0NBQ0hFXCIgLyogT05MWV9DQUNIRSAqLztcbiAgfVxuICBzaG91bGRXYWl0Rm9yQ2FjaGUoKSB7XG4gICAgaWYgKHRoaXMub3B0cy5hZGRTaW5jZUZyb21DYWNoZSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIChcbiAgICAgIC8vIE11c3Qgd2FudCB0byBjbG9zZSBvbiBFT1NFOyBzdWJzY3JpcHRpb25zXG4gICAgICAvLyB0aGF0IHdhbnQgdG8gcmVjZWl2ZSBmdXJ0aGVyIHVwZGF0ZXMgbXVzdFxuICAgICAgLy8gYWx3YXlzIGhpdCB0aGUgcmVsYXlcbiAgICAgIHRoaXMub3B0cy5jbG9zZU9uRW9zZSAmJiAvLyBDYWNoZSBhZGFwdGVyIG11c3QgY2xhaW0gdG8gYmUgZmFzdFxuICAgICAgISF0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LmxvY2tpbmcgJiYgLy8gSWYgZXhwbGljaXRseSB0b2xkIHRvIHJ1biBpbiBwYXJhbGxlbCwgdGhlblxuICAgICAgLy8gd2Ugc2hvdWxkIG5vdCB3YWl0IGZvciB0aGUgY2FjaGVcbiAgICAgIHRoaXMub3B0cy5jYWNoZVVzYWdlICE9PSBcIlBBUkFMTEVMXCIgLyogUEFSQUxMRUwgKi9cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBTdGFydCB0aGUgc3Vic2NyaXB0aW9uLiBUaGlzIGlzIHRoZSBtYWluIG1ldGhvZCB0aGF0IHNob3VsZCBiZSBjYWxsZWRcbiAgICogYWZ0ZXIgY3JlYXRpbmcgYSBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBlbWl0Q2FjaGVkRXZlbnRzIC0gV2hldGhlciB0byBlbWl0IGV2ZW50cyBjb21pbmcgZnJvbSBhIHN5bmNocm9ub3VzIGNhY2hlXG4gICAqXG4gICAqIFdoZW4gdXNpbmcgYSBzeW5jaHJvbm91cyBjYWNoZSwgdGhlIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkIGltbWVkaWF0ZWx5XG4gICAqIGJ5IHRoaXMgZnVuY3Rpb24uIElmIHlvdSB3aWxsIHVzZSB0aG9zZSByZXR1cm5lZCBldmVudHMsIHlvdSBzaG91bGRcbiAgICogc2V0IGVtaXRDYWNoZWRFdmVudHMgdG8gZmFsc2UgdG8gcHJldmVudCBzZWVpbmcgdGhlbSBhcyBkdXBsaWNhdGUgZXZlbnRzLlxuICAgKi9cbiAgc3RhcnQoZW1pdENhY2hlZEV2ZW50cyA9IHRydWUpIHtcbiAgICBsZXQgY2FjaGVSZXN1bHQ7XG4gICAgY29uc3QgdXBkYXRlU3RhdGVGcm9tQ2FjaGVSZXN1bHRzID0gKGV2ZW50cykgPT4ge1xuICAgICAgaWYgKGVtaXRDYWNoZWRFdmVudHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMubW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXAgfHwgZXZlbnQuY3JlYXRlZF9hdCA+IHRoaXMubW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXApIHtcbiAgICAgICAgICAgIHRoaXMubW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXAgPSBldmVudC5jcmVhdGVkX2F0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmV2ZW50UmVjZWl2ZWQoZXZlbnQsIHZvaWQgMCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgIGlmICghdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCB8fCBldmVudC5jcmVhdGVkX2F0ID4gdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCA9IGV2ZW50LmNyZWF0ZWRfYXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2ZW50Lm5kayA9IHRoaXMubmRrO1xuICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLm9wdHMud3JhcCA/IHdyYXBFdmVudChldmVudCkgOiBldmVudDtcbiAgICAgICAgICBpZiAoIWUpIGJyZWFrO1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgZS50aGVuKCh3cmFwcGVkRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoZmFsc2UsIHdyYXBwZWRFdmVudCwgdm9pZCAwLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmV2ZW50Rmlyc3RTZWVuLnNldChlLmlkLCBEYXRlLm5vdygpKTtcbiAgICAgICAgICBjYWNoZVJlc3VsdC5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsb2FkRnJvbVJlbGF5cyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNob3VsZFF1ZXJ5UmVsYXlzKCkpIHtcbiAgICAgICAgdGhpcy5zdGFydFdpdGhSZWxheXMoKTtcbiAgICAgICAgdGhpcy5zdGFydFBvb2xNb25pdG9yKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHRoaXMuc2hvdWxkUXVlcnlDYWNoZSgpKSB7XG4gICAgICBjYWNoZVJlc3VsdCA9IHRoaXMuc3RhcnRXaXRoQ2FjaGUoKTtcbiAgICAgIGlmIChjYWNoZVJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2FpdEZvckNhY2hlKCkpIHtcbiAgICAgICAgICBjYWNoZVJlc3VsdC50aGVuKChldmVudHMpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlRnJvbUNhY2hlUmVzdWx0cyhldmVudHMpO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5RnVsbHlGaWxsZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZW9zZVwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9hZEZyb21SZWxheXMoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVJlc3VsdC50aGVuKChldmVudHMpID0+IHtcbiAgICAgICAgICB1cGRhdGVTdGF0ZUZyb21DYWNoZVJlc3VsdHMoZXZlbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxvYWRGcm9tUmVsYXlzKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdXBkYXRlU3RhdGVGcm9tQ2FjaGVSZXN1bHRzKGNhY2hlUmVzdWx0KTtcbiAgICAgIGlmIChxdWVyeUZ1bGx5RmlsbGVkKHRoaXMpKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImVvc2VcIiwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkRnJvbVJlbGF5cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlUmVzdWx0O1xuICAgIH1cbiAgICBsb2FkRnJvbVJlbGF5cygpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBXZSB3YW50IHRvIG1vbml0b3IgZm9yIG5ldyByZWxheXMgdGhhdCBhcmUgY29taW5nIG9ubGluZSwgaW4gY2FzZVxuICAgKiB0aGV5IHNob3VsZCBiZSBwYXJ0IG9mIHRoaXMgc3Vic2NyaXB0aW9uLlxuICAgKi9cbiAgc3RhcnRQb29sTW9uaXRvcigpIHtcbiAgICBjb25zdCBfZCA9IHRoaXMuZGVidWcuZXh0ZW5kKFwicG9vbC1tb25pdG9yXCIpO1xuICAgIHRoaXMucG9vbE1vbml0b3IgPSAocmVsYXkpID0+IHtcbiAgICAgIGlmICh0aGlzLnJlbGF5RmlsdGVycz8uaGFzKHJlbGF5LnVybCkpIHJldHVybjtcbiAgICAgIGNvbnN0IGNhbGMgPSBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVycyh0aGlzLm5kaywgdGhpcy5maWx0ZXJzLCB0aGlzLnBvb2wpO1xuICAgICAgaWYgKGNhbGMuZ2V0KHJlbGF5LnVybCkpIHtcbiAgICAgICAgdGhpcy5yZWxheUZpbHRlcnM/LnNldChyZWxheS51cmwsIHRoaXMuZmlsdGVycyk7XG4gICAgICAgIHJlbGF5LnN1YnNjcmliZSh0aGlzLCB0aGlzLmZpbHRlcnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5wb29sLm9uKFwicmVsYXk6Y29ubmVjdFwiLCB0aGlzLnBvb2xNb25pdG9yKTtcbiAgfVxuICBvblN0b3BwZWQ7XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5lbWl0KFwiY2xvc2VcIiwgdGhpcyk7XG4gICAgdGhpcy5wb29sTW9uaXRvciAmJiB0aGlzLnBvb2wub2ZmKFwicmVsYXk6Y29ubmVjdFwiLCB0aGlzLnBvb2xNb25pdG9yKTtcbiAgICB0aGlzLm9uU3RvcHBlZD8uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHN1YnNjcmlwdGlvbiBoYXMgYW4gYXV0aG9ycyBmaWx0ZXIuXG4gICAqL1xuICBoYXNBdXRob3JzRmlsdGVyKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcnMuc29tZSgoZikgPT4gZi5hdXRob3JzPy5sZW5ndGgpO1xuICB9XG4gIHN0YXJ0V2l0aENhY2hlKCkge1xuICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LnF1ZXJ5KSB7XG4gICAgICByZXR1cm4gdGhpcy5uZGsuY2FjaGVBZGFwdGVyLnF1ZXJ5KHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgYXZhaWxhYmxlIHJlbGF5cyB0aGF0IHNob3VsZCBiZSBwYXJ0IG9mIHRoaXMgc3Vic2NyaXB0aW9uIGFuZCBleGVjdXRlIGluIHRoZW0uXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIGlzIGV4ZWN1dGVkIGluIGFkZGl0aW9uIHRvIHVzaW5nIHRoZSBwb29sIG1vbml0b3IsIHNvIGV2ZW4gaWYgdGhlIHJlbGF5IHNldFxuICAgKiB0aGF0IGlzIGNvbXB1dGVkIChpLmUuIHdlIGRvbid0IGhhdmUgYW55IHJlbGF5cyBhdmFpbGFibGUpLCB3aGVuIHJlbGF5cyBjb21lIG9ubGluZSwgd2Ugd2lsbFxuICAgKiBjaGVjayBpZiB3ZSBuZWVkIHRvIGV4ZWN1dGUgaW4gdGhlbS5cbiAgICovXG4gIHN0YXJ0V2l0aFJlbGF5cygpIHtcbiAgICBsZXQgZmlsdGVycyA9IHRoaXMuZmlsdGVycztcbiAgICBpZiAodGhpcy5vcHRzLmFkZFNpbmNlRnJvbUNhY2hlICYmIHRoaXMubW9zdFJlY2VudENhY2hlRXZlbnRUaW1lc3RhbXApIHtcbiAgICAgIGNvbnN0IHNpbmNlVGltZXN0YW1wID0gdGhpcy5tb3N0UmVjZW50Q2FjaGVFdmVudFRpbWVzdGFtcCArIDE7XG4gICAgICBmaWx0ZXJzID0gZmlsdGVycy5tYXAoKGZpbHRlcikgPT4gKHtcbiAgICAgICAgLi4uZmlsdGVyLFxuICAgICAgICBzaW5jZTogTWF0aC5tYXgoZmlsdGVyLnNpbmNlIHx8IDAsIHNpbmNlVGltZXN0YW1wKVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVsYXlTZXQgfHwgdGhpcy5yZWxheVNldC5yZWxheXMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5yZWxheUZpbHRlcnMgPSBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVycyh0aGlzLm5kaywgZmlsdGVycywgdGhpcy5wb29sKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWxheUZpbHRlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCByZWxheSBvZiB0aGlzLnJlbGF5U2V0LnJlbGF5cykge1xuICAgICAgICB0aGlzLnJlbGF5RmlsdGVycy5zZXQocmVsYXkudXJsLCBmaWx0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbcmVsYXlVcmwsIGZpbHRlcnMyXSBvZiB0aGlzLnJlbGF5RmlsdGVycykge1xuICAgICAgY29uc3QgcmVsYXkgPSB0aGlzLnBvb2wuZ2V0UmVsYXkocmVsYXlVcmwsIHRydWUsIHRydWUsIGZpbHRlcnMyKTtcbiAgICAgIHJlbGF5LnN1YnNjcmliZSh0aGlzLCBmaWx0ZXJzMik7XG4gICAgfVxuICB9XG4gIC8vIEVWRU5UIGhhbmRsaW5nXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhbiBldmVudCBpcyByZWNlaXZlZCBmcm9tIGEgcmVsYXkgb3IgdGhlIGNhY2hlXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gcmVsYXlcbiAgICogQHBhcmFtIGZyb21DYWNoZSBXaGV0aGVyIHRoZSBldmVudCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgY2FjaGVcbiAgICogQHBhcmFtIG9wdGltaXN0aWNQdWJsaXNoIFdoZXRoZXIgdGhpcyBldmVudCBpcyBjb21pbmcgZnJvbSBhbiBvcHRpbWlzdGljIHB1Ymxpc2hcbiAgICovXG4gIGV2ZW50UmVjZWl2ZWQoZXZlbnQsIHJlbGF5LCBmcm9tQ2FjaGUgPSBmYWxzZSwgb3B0aW1pc3RpY1B1Ymxpc2ggPSBmYWxzZSkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSBldmVudC5pZDtcbiAgICBjb25zdCBldmVudEFscmVhZHlTZWVuID0gdGhpcy5ldmVudEZpcnN0U2Vlbi5oYXMoZXZlbnRJZCk7XG4gICAgbGV0IG5ka0V2ZW50O1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIE5ES0V2ZW50KSBuZGtFdmVudCA9IGV2ZW50O1xuICAgIGlmICghZXZlbnRBbHJlYWR5U2Vlbikge1xuICAgICAgbmRrRXZlbnQgPz89IG5ldyBOREtFdmVudCh0aGlzLm5kaywgZXZlbnQpO1xuICAgICAgbmRrRXZlbnQubmRrID0gdGhpcy5uZGs7XG4gICAgICBuZGtFdmVudC5yZWxheSA9IHJlbGF5O1xuICAgICAgaWYgKCFmcm9tQ2FjaGUgJiYgIW9wdGltaXN0aWNQdWJsaXNoKSB7XG4gICAgICAgIGlmICghdGhpcy5za2lwVmFsaWRhdGlvbikge1xuICAgICAgICAgIGlmICghbmRrRXZlbnQuaXNWYWxpZCkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkV2ZW50IGZhaWxlZCB2YWxpZGF0aW9uICVzIGZyb20gcmVsYXkgJXNcIiwgZXZlbnRJZCwgcmVsYXk/LnVybCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxheSkge1xuICAgICAgICAgIGlmIChyZWxheT8uc2hvdWxkVmFsaWRhdGVFdmVudCgpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNraXBWZXJpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgaWYgKCFuZGtFdmVudC52ZXJpZnlTaWduYXR1cmUodHJ1ZSkgJiYgIXRoaXMubmRrLmFzeW5jU2lnVmVyaWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkV2ZW50IGZhaWxlZCBzaWduYXR1cmUgdmFsaWRhdGlvblwiLCBldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZWxheSkge1xuICAgICAgICAgICAgICAgIHJlbGF5LmFkZFZhbGlkYXRlZEV2ZW50KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVsYXkuYWRkTm9uVmFsaWRhdGVkRXZlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlciAmJiAhdGhpcy5vcHRzLmRvbnRTYXZlVG9DYWNoZSkge1xuICAgICAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5zZXRFdmVudChuZGtFdmVudCwgdGhpcy5maWx0ZXJzLCByZWxheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW1pc3RpY1B1Ymxpc2ggfHwgdGhpcy5za2lwT3B0aW1pc3RpY1B1Ymxpc2hFdmVudCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVtaXRFdmVudCh0aGlzLm9wdHM/LndyYXAgPz8gZmFsc2UsIG5ka0V2ZW50LCByZWxheSwgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCk7XG4gICAgICAgIHRoaXMuZXZlbnRGaXJzdFNlZW4uc2V0KGV2ZW50SWQsIERhdGUubm93KCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0aW1lU2luY2VGaXJzdFNlZW4gPSBEYXRlLm5vdygpIC0gKHRoaXMuZXZlbnRGaXJzdFNlZW4uZ2V0KGV2ZW50SWQpIHx8IDApO1xuICAgICAgdGhpcy5lbWl0KFwiZXZlbnQ6ZHVwXCIsIGV2ZW50LCByZWxheSwgdGltZVNpbmNlRmlyc3RTZWVuLCB0aGlzLCBmcm9tQ2FjaGUsIG9wdGltaXN0aWNQdWJsaXNoKTtcbiAgICAgIGlmIChyZWxheSkge1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB2ZXJpZmllZFNpZ25hdHVyZXMuZ2V0KGV2ZW50SWQpO1xuICAgICAgICBpZiAoc2lnbmF0dXJlICYmIHR5cGVvZiBzaWduYXR1cmUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuc2lnID09PSBzaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHJlbGF5LmFkZFZhbGlkYXRlZEV2ZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGFzdEV2ZW50UmVjZWl2ZWRBdCA9IERhdGUubm93KCk7XG4gIH1cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgd3JhcHMsIHN5bmMgb3IgYXN5bmMsIGFuZCBlbWl0cyB0aGUgZXZlbnQgKGlmIG9uZSBjb21lcyBiYWNrIGZyb20gdGhlIHdyYXBwZXIpXG4gICAqL1xuICBlbWl0RXZlbnQod3JhcCwgZXZ0LCByZWxheSwgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCkge1xuICAgIGNvbnN0IHdyYXBwZWQgPSB3cmFwID8gd3JhcEV2ZW50KGV2dCkgOiBldnQ7XG4gICAgaWYgKHdyYXBwZWQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICB3cmFwcGVkLnRoZW4oKGUpID0+IHRoaXMuZW1pdEV2ZW50KGZhbHNlLCBlLCByZWxheSwgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCkpO1xuICAgIH0gZWxzZSBpZiAod3JhcHBlZCkge1xuICAgICAgdGhpcy5lbWl0KFwiZXZlbnRcIiwgd3JhcHBlZCwgcmVsYXksIHRoaXMsIGZyb21DYWNoZSwgb3B0aW1pc3RpY1B1Ymxpc2gpO1xuICAgIH1cbiAgfVxuICBjbG9zZWRSZWNlaXZlZChyZWxheSwgcmVhc29uKSB7XG4gICAgdGhpcy5lbWl0KFwiY2xvc2VkXCIsIHJlbGF5LCByZWFzb24pO1xuICB9XG4gIC8vIEVPU0UgaGFuZGxpbmdcbiAgZW9zZVRpbWVvdXQ7XG4gIGVvc2VkID0gZmFsc2U7XG4gIGVvc2VSZWNlaXZlZChyZWxheSkge1xuICAgIHRoaXMuZGVidWcoXCJFT1NFIHJlY2VpdmVkIGZyb20gJXNcIiwgcmVsYXkudXJsKTtcbiAgICB0aGlzLmVvc2VzU2Vlbi5hZGQocmVsYXkpO1xuICAgIGxldCBsYXN0RXZlbnRTZWVuID0gdGhpcy5sYXN0RXZlbnRSZWNlaXZlZEF0ID8gRGF0ZS5ub3coKSAtIHRoaXMubGFzdEV2ZW50UmVjZWl2ZWRBdCA6IHZvaWQgMDtcbiAgICBjb25zdCBoYXNTZWVuQWxsRW9zZXMgPSB0aGlzLmVvc2VzU2Vlbi5zaXplID09PSB0aGlzLnJlbGF5RmlsdGVycz8uc2l6ZTtcbiAgICBjb25zdCBxdWVyeUZpbGxlZCA9IHF1ZXJ5RnVsbHlGaWxsZWQodGhpcyk7XG4gICAgY29uc3QgcGVyZm9ybUVvc2UgPSAocmVhc29uKSA9PiB7XG4gICAgICB0aGlzLmRlYnVnKFwiUGVyZm9ybWluZyBFT1NFOiAlcyAlZFwiLCByZWFzb24sIHRoaXMuZW9zZWQpO1xuICAgICAgaWYgKHRoaXMuZW9zZWQpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmVvc2VUaW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy5lb3NlVGltZW91dCk7XG4gICAgICB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgdGhpcy5lb3NlZCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5vcHRzPy5jbG9zZU9uRW9zZSkgdGhpcy5zdG9wKCk7XG4gICAgfTtcbiAgICBpZiAocXVlcnlGaWxsZWQgfHwgaGFzU2VlbkFsbEVvc2VzKSB7XG4gICAgICBwZXJmb3JtRW9zZShcInF1ZXJ5IGZpbGxlZCBvciBzZWVuIGFsbFwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVsYXlGaWx0ZXJzKSB7XG4gICAgICBsZXQgdGltZVRvV2FpdEZvck5leHRFb3NlID0gMWUzO1xuICAgICAgY29uc3QgY29ubmVjdGVkUmVsYXlzID0gbmV3IFNldCh0aGlzLnBvb2wuY29ubmVjdGVkUmVsYXlzKCkubWFwKChyKSA9PiByLnVybCkpO1xuICAgICAgY29uc3QgY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMgPSBBcnJheS5mcm9tKHRoaXMucmVsYXlGaWx0ZXJzLmtleXMoKSkuZmlsdGVyKFxuICAgICAgICAodXJsKSA9PiBjb25uZWN0ZWRSZWxheXMuaGFzKHVybClcbiAgICAgICk7XG4gICAgICBpZiAoY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgICAgXCJObyBjb25uZWN0ZWQgcmVsYXlzLCB3YWl0aW5nIGZvciBhbGwgcmVsYXlzIHRvIGNvbm5lY3RcIixcbiAgICAgICAgICBBcnJheS5mcm9tKHRoaXMucmVsYXlGaWx0ZXJzLmtleXMoKSkuam9pbihcIiwgXCIpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2VPZlJlbGF5c1RoYXRIYXZlU2VudEVvc2UgPSB0aGlzLmVvc2VzU2Vlbi5zaXplIC8gY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMubGVuZ3RoO1xuICAgICAgdGhpcy5kZWJ1ZyhcIlBlcmNlbnRhZ2Ugb2YgcmVsYXlzIHRoYXQgaGF2ZSBzZW50IEVPU0VcIiwge1xuICAgICAgICBzdWJJZDogdGhpcy5zdWJJZCxcbiAgICAgICAgcGVyY2VudGFnZU9mUmVsYXlzVGhhdEhhdmVTZW50RW9zZSxcbiAgICAgICAgc2VlbjogdGhpcy5lb3Nlc1NlZW4uc2l6ZSxcbiAgICAgICAgdG90YWw6IGNvbm5lY3RlZFJlbGF5c1dpdGhGaWx0ZXJzLmxlbmd0aFxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5lb3Nlc1NlZW4uc2l6ZSA+PSAyICYmIHBlcmNlbnRhZ2VPZlJlbGF5c1RoYXRIYXZlU2VudEVvc2UgPj0gMC41KSB7XG4gICAgICAgIHRpbWVUb1dhaXRGb3JOZXh0RW9zZSA9IHRpbWVUb1dhaXRGb3JOZXh0RW9zZSAqICgxIC0gcGVyY2VudGFnZU9mUmVsYXlzVGhhdEhhdmVTZW50RW9zZSk7XG4gICAgICAgIGlmICh0aW1lVG9XYWl0Rm9yTmV4dEVvc2UgPT09IDApIHtcbiAgICAgICAgICBwZXJmb3JtRW9zZShcInRpbWUgdG8gd2FpdCB3YXMgMFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW9zZVRpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLmVvc2VUaW1lb3V0KTtcbiAgICAgICAgY29uc3Qgc2VuZEVvc2VUaW1lb3V0ID0gKCkgPT4ge1xuICAgICAgICAgIGxhc3RFdmVudFNlZW4gPSB0aGlzLmxhc3RFdmVudFJlY2VpdmVkQXQgPyBEYXRlLm5vdygpIC0gdGhpcy5sYXN0RXZlbnRSZWNlaXZlZEF0IDogdm9pZCAwO1xuICAgICAgICAgIGlmIChsYXN0RXZlbnRTZWVuICE9PSB2b2lkIDAgJiYgbGFzdEV2ZW50U2VlbiA8IDIwKSB7XG4gICAgICAgICAgICB0aGlzLmVvc2VUaW1lb3V0ID0gc2V0VGltZW91dChzZW5kRW9zZVRpbWVvdXQsIHRpbWVUb1dhaXRGb3JOZXh0RW9zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlcmZvcm1Fb3NlKGBzZW5kIGVvc2UgdGltZW91dDogJHt0aW1lVG9XYWl0Rm9yTmV4dEVvc2V9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVvc2VUaW1lb3V0ID0gc2V0VGltZW91dChzZW5kRW9zZVRpbWVvdXQsIHRpbWVUb1dhaXRGb3JOZXh0RW9zZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIGtpbmRJc0VwaGVtZXJhbCA9IChraW5kKSA9PiBraW5kID49IDJlNCAmJiBraW5kIDwgM2U0O1xuXG4vLyBzcmMvdXNlci9mb2xsb3dzLnRzXG5hc3luYyBmdW5jdGlvbiBmb2xsb3dzKG9wdHMsIG91dGJveCwga2luZCA9IDMgLyogQ29udGFjdHMgKi8pIHtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIG5vdCBzZXRcIik7XG4gIGNvbnN0IGNvbnRhY3RMaXN0RXZlbnQgPSBhd2FpdCB0aGlzLm5kay5mZXRjaEV2ZW50KFxuICAgIHsga2luZHM6IFtraW5kXSwgYXV0aG9yczogW3RoaXMucHVia2V5XSB9LFxuICAgIG9wdHMgfHwgeyBncm91cGFibGU6IGZhbHNlIH1cbiAgKTtcbiAgaWYgKGNvbnRhY3RMaXN0RXZlbnQpIHtcbiAgICBjb25zdCBwdWJrZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb250YWN0TGlzdEV2ZW50LnRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICBpZiAodGFnWzBdID09PSBcInBcIikgcHVia2V5cy5hZGQodGFnWzFdKTtcbiAgICB9KTtcbiAgICBpZiAob3V0Ym94KSB7XG4gICAgICB0aGlzLm5kaz8ub3V0Ym94VHJhY2tlcj8udHJhY2tVc2VycyhBcnJheS5mcm9tKHB1YmtleXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIFsuLi5wdWJrZXlzXS5yZWR1Y2UoKGFjYywgcHVia2V5KSA9PiB7XG4gICAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXkgfSk7XG4gICAgICB1c2VyLm5kayA9IHRoaXMubmRrO1xuICAgICAgYWNjLmFkZCh1c2VyKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG59XG5cbi8vIHNyYy91c2VyL25pcDA1LnRzXG52YXIgTklQMDVfUkVHRVggPSAvXig/OihbXFx3ListXSspQCk/KFtcXHcuLV0rKSQvO1xuYXN5bmMgZnVuY3Rpb24gZ2V0TmlwMDVGb3IobmRrLCBmdWxsbmFtZSwgX2ZldGNoID0gZmV0Y2gsIGZldGNoT3B0cyA9IHt9KSB7XG4gIHJldHVybiBhd2FpdCBuZGsucXVldWVzTmlwMDUuYWRkKHtcbiAgICBpZDogZnVsbG5hbWUsXG4gICAgZnVuYzogYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKG5kay5jYWNoZUFkYXB0ZXI/LmxvYWROaXAwNSkge1xuICAgICAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgbmRrLmNhY2hlQWRhcHRlci5sb2FkTmlwMDUoZnVsbG5hbWUpO1xuICAgICAgICBpZiAocHJvZmlsZSAhPT0gXCJtaXNzaW5nXCIpIHtcbiAgICAgICAgICBpZiAocHJvZmlsZSkge1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHtcbiAgICAgICAgICAgICAgcHVia2V5OiBwcm9maWxlLnB1YmtleSxcbiAgICAgICAgICAgICAgcmVsYXlVcmxzOiBwcm9maWxlLnJlbGF5cyxcbiAgICAgICAgICAgICAgbmlwNDZVcmxzOiBwcm9maWxlLm5pcDQ2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVzZXIubmRrID0gbmRrO1xuICAgICAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmZXRjaE9wdHMuY2FjaGUgIT09IFwibm8tY2FjaGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBtYXRjaCA9IGZ1bGxuYW1lLm1hdGNoKE5JUDA1X1JFR0VYKTtcbiAgICAgIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgW18sIG5hbWUgPSBcIl9cIiwgZG9tYWluXSA9IG1hdGNoO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgX2ZldGNoKGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9ub3N0ci5qc29uP25hbWU9JHtuYW1lfWAsIGZldGNoT3B0cyk7XG4gICAgICAgIGNvbnN0IHsgbmFtZXMsIHJlbGF5cywgbmlwNDYgfSA9IHBhcnNlTklQMDVSZXN1bHQoYXdhaXQgcmVzLmpzb24oKSk7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IG5hbWVzW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGxldCBwcm9maWxlID0gbnVsbDtcbiAgICAgICAgaWYgKHB1YmtleSkge1xuICAgICAgICAgIHByb2ZpbGUgPSB7IHB1YmtleSwgcmVsYXlzOiByZWxheXM/LltwdWJrZXldLCBuaXA0NjogbmlwNDY/LltwdWJrZXldIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5kaz8uY2FjaGVBZGFwdGVyPy5zYXZlTmlwMDUpIHtcbiAgICAgICAgICBuZGsuY2FjaGVBZGFwdGVyLnNhdmVOaXAwNShmdWxsbmFtZSwgcHJvZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2ZpbGU7XG4gICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICBpZiAobmRrPy5jYWNoZUFkYXB0ZXI/LnNhdmVOaXAwNSkge1xuICAgICAgICAgIG5kaz8uY2FjaGVBZGFwdGVyLnNhdmVOaXAwNShmdWxsbmFtZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBOSVAwNSBmb3JcIiwgZnVsbG5hbWUsIF9lKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlTklQMDVSZXN1bHQoanNvbikge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgbmFtZXM6IHt9XG4gIH07XG4gIGZvciAoY29uc3QgW25hbWUsIHB1YmtleV0gb2YgT2JqZWN0LmVudHJpZXMoanNvbi5uYW1lcykpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHB1YmtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVzdWx0Lm5hbWVzW25hbWUudG9Mb3dlckNhc2UoKV0gPSBwdWJrZXk7XG4gICAgfVxuICB9XG4gIGlmIChqc29uLnJlbGF5cykge1xuICAgIHJlc3VsdC5yZWxheXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtwdWJrZXksIHJlbGF5c10gb2YgT2JqZWN0LmVudHJpZXMoanNvbi5yZWxheXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHB1YmtleSA9PT0gXCJzdHJpbmdcIiAmJiBBcnJheS5pc0FycmF5KHJlbGF5cykpIHtcbiAgICAgICAgcmVzdWx0LnJlbGF5c1twdWJrZXldID0gcmVsYXlzLmZpbHRlcigocmVsYXkpID0+IHR5cGVvZiByZWxheSA9PT0gXCJzdHJpbmdcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChqc29uLm5pcDQ2KSB7XG4gICAgcmVzdWx0Lm5pcDQ2ID0ge307XG4gICAgZm9yIChjb25zdCBbcHVia2V5LCBuaXA0Nl0gb2YgT2JqZWN0LmVudHJpZXMoanNvbi5uaXA0NikpIHtcbiAgICAgIGlmICh0eXBlb2YgcHVia2V5ID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkobmlwNDYpKSB7XG4gICAgICAgIHJlc3VsdC5uaXA0NltwdWJrZXldID0gbmlwNDYuZmlsdGVyKChyZWxheSkgPT4gdHlwZW9mIHJlbGF5ID09PSBcInN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3VzZXIvcHJvZmlsZS50c1xuZnVuY3Rpb24gcHJvZmlsZUZyb21FdmVudChldmVudCkge1xuICBjb25zdCBwcm9maWxlID0ge307XG4gIGxldCBwYXlsb2FkO1xuICB0cnkge1xuICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGV2ZW50LmNvbnRlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHByb2ZpbGUgZXZlbnQ6ICR7ZXJyb3J9YCk7XG4gIH1cbiAgcHJvZmlsZS5jcmVhdGVkX2F0ID0gZXZlbnQuY3JlYXRlZF9hdDtcbiAgcHJvZmlsZS5wcm9maWxlRXZlbnQgPSBKU09OLnN0cmluZ2lmeShldmVudC5yYXdFdmVudCgpKTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGF5bG9hZCkpIHtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgcHJvZmlsZS5uYW1lID0gcGF5bG9hZC5uYW1lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXNwbGF5X25hbWVcIjpcbiAgICAgICAgcHJvZmlsZS5kaXNwbGF5TmFtZSA9IHBheWxvYWQuZGlzcGxheV9uYW1lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgY2FzZSBcInBpY3R1cmVcIjpcbiAgICAgICAgcHJvZmlsZS5waWN0dXJlID0gcGF5bG9hZC5waWN0dXJlIHx8IHBheWxvYWQuaW1hZ2U7XG4gICAgICAgIHByb2ZpbGUuaW1hZ2UgPSBwcm9maWxlLnBpY3R1cmU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJhbm5lclwiOlxuICAgICAgICBwcm9maWxlLmJhbm5lciA9IHBheWxvYWQuYmFubmVyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJiaW9cIjpcbiAgICAgICAgcHJvZmlsZS5iaW8gPSBwYXlsb2FkLmJpbztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibmlwMDVcIjpcbiAgICAgICAgcHJvZmlsZS5uaXAwNSA9IHBheWxvYWQubmlwMDU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImx1ZDA2XCI6XG4gICAgICAgIHByb2ZpbGUubHVkMDYgPSBwYXlsb2FkLmx1ZDA2O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsdWQxNlwiOlxuICAgICAgICBwcm9maWxlLmx1ZDE2ID0gcGF5bG9hZC5sdWQxNjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYWJvdXRcIjpcbiAgICAgICAgcHJvZmlsZS5hYm91dCA9IHBheWxvYWQuYWJvdXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIndlYnNpdGVcIjpcbiAgICAgICAgcHJvZmlsZS53ZWJzaXRlID0gcGF5bG9hZC53ZWJzaXRlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHByb2ZpbGVba2V5XSA9IHBheWxvYWRba2V5XTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9maWxlO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplUHJvZmlsZShwcm9maWxlKSB7XG4gIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHByb2ZpbGUpKSB7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgXCJ1c2VybmFtZVwiOlxuICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgcGF5bG9hZC5uYW1lID0gdmFsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXNwbGF5TmFtZVwiOlxuICAgICAgICBwYXlsb2FkLmRpc3BsYXlfbmFtZSA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgIGNhc2UgXCJwaWN0dXJlXCI6XG4gICAgICAgIHBheWxvYWQucGljdHVyZSA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmlvXCI6XG4gICAgICBjYXNlIFwiYWJvdXRcIjpcbiAgICAgICAgcGF5bG9hZC5hYm91dCA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBwYXlsb2FkW2tleV0gPSB2YWw7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG59XG5cbi8vIHNyYy91c2VyL2luZGV4LnRzXG52YXIgTkRLVXNlciA9IGNsYXNzIF9OREtVc2VyIHtcbiAgbmRrO1xuICBwcm9maWxlO1xuICBwcm9maWxlRXZlbnQ7XG4gIF9ucHViO1xuICBfcHVia2V5O1xuICByZWxheVVybHMgPSBbXTtcbiAgbmlwNDZVcmxzID0gW107XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBpZiAob3B0cy5ucHViKSB0aGlzLl9ucHViID0gb3B0cy5ucHViO1xuICAgIGlmIChvcHRzLmhleHB1YmtleSkgdGhpcy5fcHVia2V5ID0gb3B0cy5oZXhwdWJrZXk7XG4gICAgaWYgKG9wdHMucHVia2V5KSB0aGlzLl9wdWJrZXkgPSBvcHRzLnB1YmtleTtcbiAgICBpZiAob3B0cy5yZWxheVVybHMpIHRoaXMucmVsYXlVcmxzID0gb3B0cy5yZWxheVVybHM7XG4gICAgaWYgKG9wdHMubmlwNDZVcmxzKSB0aGlzLm5pcDQ2VXJscyA9IG9wdHMubmlwNDZVcmxzO1xuICAgIGlmIChvcHRzLm5wcm9maWxlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gbmlwMTk1LmRlY29kZShvcHRzLm5wcm9maWxlKTtcbiAgICAgICAgaWYgKGRlY29kZWQudHlwZSA9PT0gXCJucHJvZmlsZVwiKSB7XG4gICAgICAgICAgdGhpcy5fcHVia2V5ID0gZGVjb2RlZC5kYXRhLnB1YmtleTtcbiAgICAgICAgICBpZiAoZGVjb2RlZC5kYXRhLnJlbGF5cyAmJiBkZWNvZGVkLmRhdGEucmVsYXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVsYXlVcmxzLnB1c2goLi4uZGVjb2RlZC5kYXRhLnJlbGF5cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZGVjb2RlIG5wcm9maWxlXCIsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgbnB1YigpIHtcbiAgICBpZiAoIXRoaXMuX25wdWIpIHtcbiAgICAgIGlmICghdGhpcy5fcHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMuX25wdWIgPSBuaXAxOTUubnB1YkVuY29kZSh0aGlzLnB1YmtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ucHViO1xuICB9XG4gIGdldCBucHJvZmlsZSgpIHtcbiAgICBjb25zdCByZWxheXMgPSB0aGlzLnByb2ZpbGVFdmVudD8ub25SZWxheXM/Lm1hcCgocikgPT4gci51cmwpO1xuICAgIHJldHVybiBuaXAxOTUubnByb2ZpbGVFbmNvZGUoe1xuICAgICAgcHVia2V5OiB0aGlzLnB1YmtleSxcbiAgICAgIHJlbGF5c1xuICAgIH0pO1xuICB9XG4gIHNldCBucHViKG5wdWIyKSB7XG4gICAgdGhpcy5fbnB1YiA9IG5wdWIyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIncyBwdWJrZXlcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHVzZXIncyBwdWJrZXlcbiAgICovXG4gIGdldCBwdWJrZXkoKSB7XG4gICAgaWYgKCF0aGlzLl9wdWJrZXkpIHtcbiAgICAgIGlmICghdGhpcy5fbnB1YikgdGhyb3cgbmV3IEVycm9yKFwibnB1YiBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5fcHVia2V5ID0gbmlwMTk1LmRlY29kZSh0aGlzLm5wdWIpLmRhdGE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wdWJrZXk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgdXNlcidzIHB1YmtleVxuICAgKiBAcGFyYW0gcHVia2V5IHtzdHJpbmd9IFRoZSB1c2VyJ3MgcHVia2V5XG4gICAqL1xuICBzZXQgcHVia2V5KHB1YmtleSkge1xuICAgIHRoaXMuX3B1YmtleSA9IHB1YmtleTtcbiAgfVxuICAvKipcbiAgICogRXF1aXZhbGVudCB0byBOREtFdmVudC5maWx0ZXJzKCkuXG4gICAqIEByZXR1cm5zIHtOREtGaWx0ZXJ9XG4gICAqL1xuICBmaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHsgXCIjcFwiOiBbdGhpcy5wdWJrZXldIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgTklQLTU3IGFuZCBOSVAtNjEgaW5mb3JtYXRpb24gdGhhdCB0aGlzIHVzZXIgaGFzIHNpZ25hbGVkXG4gICAqXG4gICAqIEBwYXJhbSBnZXRBbGwge2Jvb2xlYW59IFdoZXRoZXIgdG8gZ2V0IGFsbCB6YXAgaW5mbyBvciBqdXN0IHRoZSBmaXJzdCBvbmVcbiAgICovXG4gIGFzeW5jIGdldFphcEluZm8odGltZW91dE1zKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGNvbnN0IHByb21pc2VXaXRoVGltZW91dCA9IGFzeW5jIChwcm9taXNlKSA9PiB7XG4gICAgICBpZiAoIXRpbWVvdXRNcykgcmV0dXJuIHByb21pc2U7XG4gICAgICBsZXQgdGltZW91dElkO1xuICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcihcIlRpbWVvdXRcIikpLCB0aW1lb3V0TXMpO1xuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW3Byb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSA9PT0gXCJUaW1lb3V0XCIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSBjYXRjaCAoX29yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBbdXNlclByb2ZpbGUsIG1pbnRMaXN0RXZlbnRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgcHJvbWlzZVdpdGhUaW1lb3V0KHRoaXMuZmV0Y2hQcm9maWxlKCkpLFxuICAgICAgcHJvbWlzZVdpdGhUaW1lb3V0KHRoaXMubmRrLmZldGNoRXZlbnQoeyBraW5kczogWzEwMDE5IC8qIENhc2h1TWludExpc3QgKi9dLCBhdXRob3JzOiBbdGhpcy5wdWJrZXldIH0pKVxuICAgIF0pO1xuICAgIGNvbnN0IHJlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKG1pbnRMaXN0RXZlbnQpIHtcbiAgICAgIGNvbnN0IG1pbnRMaXN0ID0gTkRLQ2FzaHVNaW50TGlzdC5mcm9tKG1pbnRMaXN0RXZlbnQpO1xuICAgICAgaWYgKG1pbnRMaXN0Lm1pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzLnNldChcIm5pcDYxXCIsIHtcbiAgICAgICAgICBtaW50czogbWludExpc3QubWludHMsXG4gICAgICAgICAgcmVsYXlzOiBtaW50TGlzdC5yZWxheXMsXG4gICAgICAgICAgcDJwazogbWludExpc3QucDJwa1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVzZXJQcm9maWxlKSB7XG4gICAgICBjb25zdCB7IGx1ZDA2LCBsdWQxNiB9ID0gdXNlclByb2ZpbGU7XG4gICAgICByZXMuc2V0KFwibmlwNTdcIiwgeyBsdWQwNiwgbHVkMTYgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIGFuIE5ES1VzZXIgZnJvbSBhIE5JUC0wNSBzdHJpbmdcbiAgICogQHBhcmFtIG5pcDA1SWQge3N0cmluZ30gVGhlIHVzZXIncyBOSVAtMDVcbiAgICogQHBhcmFtIG5kayB7TkRLfSBBbiBOREsgaW5zdGFuY2VcbiAgICogQHBhcmFtIHNraXBDYWNoZSB7Ym9vbGVhbn0gV2hldGhlciB0byBza2lwIHRoZSBjYWNoZSBvciBub3RcbiAgICogQHJldHVybnMge05ES1VzZXIgfCB1bmRlZmluZWR9IEFuIE5ES1VzZXIgaWYgb25lIGlzIGZvdW5kIGZvciB0aGUgZ2l2ZW4gTklQLTA1LCB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21OaXAwNShuaXAwNUlkLCBuZGssIHNraXBDYWNoZSA9IGZhbHNlKSB7XG4gICAgaWYgKCFuZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICBjb25zdCBvcHRzID0ge307XG4gICAgaWYgKHNraXBDYWNoZSkgb3B0cy5jYWNoZSA9IFwibm8tY2FjaGVcIjtcbiAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgZ2V0TmlwMDVGb3IobmRrLCBuaXAwNUlkLCBuZGs/Lmh0dHBGZXRjaCwgb3B0cyk7XG4gICAgaWYgKHByb2ZpbGUpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBuZXcgX05ES1VzZXIoe1xuICAgICAgICBwdWJrZXk6IHByb2ZpbGUucHVia2V5LFxuICAgICAgICByZWxheVVybHM6IHByb2ZpbGUucmVsYXlzLFxuICAgICAgICBuaXA0NlVybHM6IHByb2ZpbGUubmlwNDZcbiAgICAgIH0pO1xuICAgICAgdXNlci5uZGsgPSBuZGs7XG4gICAgICByZXR1cm4gdXNlcjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgdXNlcidzIHByb2ZpbGVcbiAgICogQHBhcmFtIG9wdHMge05ES1N1YnNjcmlwdGlvbk9wdGlvbnN9IEEgc2V0IG9mIE5ES1N1YnNjcmlwdGlvbk9wdGlvbnNcbiAgICogQHBhcmFtIHN0b3JlUHJvZmlsZUV2ZW50IHtib29sZWFufSBXaGV0aGVyIHRvIHN0b3JlIHRoZSBwcm9maWxlIGV2ZW50IG9yIG5vdFxuICAgKiBAcmV0dXJucyBVc2VyIFByb2ZpbGVcbiAgICovXG4gIGFzeW5jIGZldGNoUHJvZmlsZShvcHRzLCBzdG9yZVByb2ZpbGVFdmVudCA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIG5vdCBzZXRcIik7XG4gICAgbGV0IHNldE1ldGFkYXRhRXZlbnQgPSBudWxsO1xuICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXIgJiYgKHRoaXMubmRrLmNhY2hlQWRhcHRlci5mZXRjaFByb2ZpbGUgfHwgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmZldGNoUHJvZmlsZVN5bmMpICYmIG9wdHM/LmNhY2hlVXNhZ2UgIT09IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi8pIHtcbiAgICAgIGxldCBwcm9maWxlID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZmV0Y2hQcm9maWxlU3luYykge1xuICAgICAgICBwcm9maWxlID0gdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmZldGNoUHJvZmlsZVN5bmModGhpcy5wdWJrZXkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZmV0Y2hQcm9maWxlKSB7XG4gICAgICAgIHByb2ZpbGUgPSBhd2FpdCB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZmV0Y2hQcm9maWxlKHRoaXMucHVia2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9maWxlKSB7XG4gICAgICAgIHRoaXMucHJvZmlsZSA9IHByb2ZpbGU7XG4gICAgICAgIHJldHVybiBwcm9maWxlO1xuICAgICAgfVxuICAgIH1cbiAgICBvcHRzID8/PSB7fTtcbiAgICBvcHRzLmNhY2hlVXNhZ2UgPz89IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi87XG4gICAgb3B0cy5jbG9zZU9uRW9zZSA/Pz0gdHJ1ZTtcbiAgICBvcHRzLmdyb3VwYWJsZSA/Pz0gdHJ1ZTtcbiAgICBvcHRzLmdyb3VwYWJsZURlbGF5ID8/PSAyNTA7XG4gICAgaWYgKCFzZXRNZXRhZGF0YUV2ZW50KSB7XG4gICAgICBzZXRNZXRhZGF0YUV2ZW50ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudCh7IGtpbmRzOiBbMF0sIGF1dGhvcnM6IFt0aGlzLnB1YmtleV0gfSwgb3B0cyk7XG4gICAgfVxuICAgIGlmICghc2V0TWV0YWRhdGFFdmVudCkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5wcm9maWxlID0gcHJvZmlsZUZyb21FdmVudChzZXRNZXRhZGF0YUV2ZW50KTtcbiAgICBpZiAoc3RvcmVQcm9maWxlRXZlbnQgJiYgdGhpcy5wcm9maWxlICYmIHRoaXMubmRrLmNhY2hlQWRhcHRlciAmJiB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuc2F2ZVByb2ZpbGUpIHtcbiAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5zYXZlUHJvZmlsZSh0aGlzLnB1YmtleSwgdGhpcy5wcm9maWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNldCBvZiB1c2VycyB0aGF0IHRoaXMgdXNlciBmb2xsb3dzLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZm9sbG93U2V0IGluc3RlYWRcbiAgICovXG4gIGZvbGxvd3MgPSBmb2xsb3dzLmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2V0IG9mIHB1YmtleXMgdGhhdCB0aGlzIHVzZXIgZm9sbG93cy5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgLSBOREtTdWJzY3JpcHRpb25PcHRpb25zXG4gICAqIEBwYXJhbSBvdXRib3ggLSBib29sZWFuXG4gICAqIEBwYXJhbSBraW5kIC0gbnVtYmVyXG4gICAqL1xuICBhc3luYyBmb2xsb3dTZXQob3B0cywgb3V0Ym94LCBraW5kID0gMyAvKiBDb250YWN0cyAqLykge1xuICAgIGNvbnN0IGZvbGxvd3MyID0gYXdhaXQgdGhpcy5mb2xsb3dzKG9wdHMsIG91dGJveCwga2luZCk7XG4gICAgcmV0dXJuIG5ldyBTZXQoQXJyYXkuZnJvbShmb2xsb3dzMikubWFwKChmKSA9PiBmLnB1YmtleSkpO1xuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCBVc2UgcmVmZXJlbmNlVGFncyBpbnN0ZWFkLiAqL1xuICAvKipcbiAgICogR2V0IHRoZSB0YWcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyB1c2VyIGluIGFuIGV2ZW50XG4gICAqIEByZXR1cm5zIHtOREtUYWd9IGFuIE5ES1RhZ1xuICAgKi9cbiAgdGFnUmVmZXJlbmNlKCkge1xuICAgIHJldHVybiBbXCJwXCIsIHRoaXMucHVia2V5XTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB0YWdzIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoaXMgdXNlciBpbiBhbiBldmVudFxuICAgKiBAcmV0dXJucyB7TkRLVGFnW119IGFuIGFycmF5IG9mIE5ES1RhZ1xuICAgKi9cbiAgcmVmZXJlbmNlVGFncyhtYXJrZXIpIHtcbiAgICBjb25zdCB0YWcgPSBbW1wicFwiLCB0aGlzLnB1YmtleV1dO1xuICAgIGlmICghbWFya2VyKSByZXR1cm4gdGFnO1xuICAgIHRhZ1swXS5wdXNoKFwiXCIsIG1hcmtlcik7XG4gICAgcmV0dXJuIHRhZztcbiAgfVxuICAvKipcbiAgICogUHVibGlzaGVzIHRoZSBjdXJyZW50IHByb2ZpbGUuXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKCkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICBpZiAoIXRoaXMucHJvZmlsZSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJvZmlsZSBhdmFpbGFibGVcIik7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDAsXG4gICAgICBjb250ZW50OiBzZXJpYWxpemVQcm9maWxlKHRoaXMucHJvZmlsZSlcbiAgICB9KTtcbiAgICBhd2FpdCBldmVudC5wdWJsaXNoKCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIGZvbGxvdyB0byB0aGlzIHVzZXIncyBjb250YWN0IGxpc3RcbiAgICpcbiAgICogQHBhcmFtIG5ld0ZvbGxvdyB7TkRLVXNlcn0gVGhlIHVzZXIgdG8gZm9sbG93XG4gICAqIEBwYXJhbSBjdXJyZW50Rm9sbG93TGlzdCB7U2V0PE5ES1VzZXI+fSBUaGUgY3VycmVudCBmb2xsb3cgbGlzdFxuICAgKiBAcGFyYW0ga2luZCB7TkRLS2luZH0gVGhlIGtpbmQgdG8gdXNlIGZvciB0aGlzIGNvbnRhY3QgbGlzdCAoZGVmYXVsdHMgdG8gYDNgKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gVHJ1ZSBpZiB0aGUgZm9sbG93IHdhcyBhZGRlZCwgZmFsc2UgaWYgdGhlIGZvbGxvdyBhbHJlYWR5IGV4aXN0c1xuICAgKi9cbiAgYXN5bmMgZm9sbG93KG5ld0ZvbGxvdywgY3VycmVudEZvbGxvd0xpc3QsIGtpbmQgPSAzIC8qIENvbnRhY3RzICovKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGlmICghY3VycmVudEZvbGxvd0xpc3QpIHtcbiAgICAgIGN1cnJlbnRGb2xsb3dMaXN0ID0gYXdhaXQgdGhpcy5mb2xsb3dzKHZvaWQgMCwgdm9pZCAwLCBraW5kKTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRGb2xsb3dMaXN0LmhhcyhuZXdGb2xsb3cpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGN1cnJlbnRGb2xsb3dMaXN0LmFkZChuZXdGb2xsb3cpO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCB7IGtpbmQgfSk7XG4gICAgZm9yIChjb25zdCBmb2xsb3cgb2YgY3VycmVudEZvbGxvd0xpc3QpIHtcbiAgICAgIGV2ZW50LnRhZyhmb2xsb3cpO1xuICAgIH1cbiAgICBhd2FpdCBldmVudC5wdWJsaXNoKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZvbGxvdyBmcm9tIHRoaXMgdXNlcidzIGNvbnRhY3QgbGlzdFxuICAgKlxuICAgKiBAcGFyYW0gdXNlciB7TkRLVXNlcn0gVGhlIHVzZXIgdG8gdW5mb2xsb3dcbiAgICogQHBhcmFtIGN1cnJlbnRGb2xsb3dMaXN0IHtTZXQ8TkRLVXNlcj59IFRoZSBjdXJyZW50IGZvbGxvdyBsaXN0XG4gICAqIEBwYXJhbSBraW5kIHtOREtLaW5kfSBUaGUga2luZCB0byB1c2UgZm9yIHRoaXMgY29udGFjdCBsaXN0IChkZWZhdWx0cyB0byBgM2ApXG4gICAqIEByZXR1cm5zIFRoZSByZWxheXMgd2VyZSB0aGUgZm9sbG93IGxpc3Qgd2FzIHB1Ymxpc2hlZCBvciBmYWxzZSBpZiB0aGUgdXNlciB3YXNuJ3QgZm91bmRcbiAgICovXG4gIGFzeW5jIHVuZm9sbG93KHVzZXIsIGN1cnJlbnRGb2xsb3dMaXN0LCBraW5kID0gMyAvKiBDb250YWN0cyAqLykge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBpZiAoIWN1cnJlbnRGb2xsb3dMaXN0KSB7XG4gICAgICBjdXJyZW50Rm9sbG93TGlzdCA9IGF3YWl0IHRoaXMuZm9sbG93cyh2b2lkIDAsIHZvaWQgMCwga2luZCk7XG4gICAgfVxuICAgIGNvbnN0IG5ld1VzZXJGb2xsb3dMaXN0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBsZXQgZm91bmRVc2VyID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBmb2xsb3cgb2YgY3VycmVudEZvbGxvd0xpc3QpIHtcbiAgICAgIGlmIChmb2xsb3cucHVia2V5ICE9PSB1c2VyLnB1YmtleSkge1xuICAgICAgICBuZXdVc2VyRm9sbG93TGlzdC5hZGQoZm9sbG93KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kVXNlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm91bmRVc2VyKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHsga2luZCB9KTtcbiAgICBmb3IgKGNvbnN0IGZvbGxvdyBvZiBuZXdVc2VyRm9sbG93TGlzdCkge1xuICAgICAgZXZlbnQudGFnKGZvbGxvdyk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBldmVudC5wdWJsaXNoKCk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGEgdXNlcidzIE5JUC0wNSBpZGVudGlmaWVyICh1c3VhbGx5IGZldGNoZWQgZnJvbSB0aGVpciBraW5kOjAgcHJvZmlsZSBkYXRhKVxuICAgKlxuICAgKiBAcGFyYW0gbmlwMDVJZCBUaGUgTklQLTA1IHN0cmluZyB0byB2YWxpZGF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuIHwgbnVsbD59IFRydWUgaWYgdGhlIE5JUC0wNSBpcyBmb3VuZCBhbmQgbWF0Y2hlcyB0aGlzIHVzZXIncyBwdWJrZXksXG4gICAqIEZhbHNlIGlmIHRoZSBOSVAtMDUgaXMgZm91bmQgYnV0IGRvZXNuJ3QgbWF0Y2ggdGhpcyB1c2VyJ3MgcHVia2V5LFxuICAgKiBudWxsIGlmIHRoZSBOSVAtMDUgaXNuJ3QgZm91bmQgb24gdGhlIGRvbWFpbiBvciB3ZSdyZSB1bmFibGUgdG8gdmVyaWZ5IChiZWNhdXNlIG9mIG5ldHdvcmsgaXNzdWVzLCBldGMuKVxuICAgKi9cbiAgYXN5bmMgdmFsaWRhdGVOaXAwNShuaXAwNUlkKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGNvbnN0IHByb2ZpbGVQb2ludGVyID0gYXdhaXQgZ2V0TmlwMDVGb3IodGhpcy5uZGssIG5pcDA1SWQpO1xuICAgIGlmIChwcm9maWxlUG9pbnRlciA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHByb2ZpbGVQb2ludGVyLnB1YmtleSA9PT0gdGhpcy5wdWJrZXk7XG4gIH1cbn07XG5cbi8vIHNyYy91c2VyL3Bpbi50c1xuYXN5bmMgZnVuY3Rpb24gcGluRXZlbnQodXNlciwgZXZlbnQsIHBpbkV2ZW50MiwgcHVibGlzaCkge1xuICBjb25zdCBraW5kID0gMTAwMDEgLyogUGluTGlzdCAqLztcbiAgaWYgKCF1c2VyLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICB1c2VyLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgaWYgKCFwaW5FdmVudDIpIHtcbiAgICBjb25zdCBldmVudHMgPSBhd2FpdCB1c2VyLm5kay5mZXRjaEV2ZW50cyhcbiAgICAgIHsga2luZHM6IFtraW5kXSwgYXV0aG9yczogW3VzZXIucHVia2V5XSB9LFxuICAgICAgeyBjYWNoZVVzYWdlOiBcIk9OTFlfUkVMQVlcIiAvKiBPTkxZX1JFTEFZICovIH1cbiAgICApO1xuICAgIGlmIChldmVudHMuc2l6ZSA+IDApIHtcbiAgICAgIHBpbkV2ZW50MiA9IGxpc3RzX2RlZmF1bHQuZnJvbShBcnJheS5mcm9tKGV2ZW50cylbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwaW5FdmVudDIgPSBuZXcgTkRLRXZlbnQodXNlci5uZGssIHtcbiAgICAgICAga2luZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHBpbkV2ZW50Mi50YWcoZXZlbnQpO1xuICBpZiAocHVibGlzaCkge1xuICAgIGF3YWl0IHBpbkV2ZW50Mi5wdWJsaXNoKCk7XG4gIH1cbiAgcmV0dXJuIHBpbkV2ZW50Mjtcbn1cblxuLy8gc3JjL2V2ZW50cy9raW5kcy9jbGFzc2lmaWVkLnRzXG52YXIgTkRLQ2xhc3NpZmllZCA9IGNsYXNzIF9OREtDbGFzc2lmaWVkIGV4dGVuZHMgTkRLRXZlbnQge1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzMDQwMiAvKiBDbGFzc2lmaWVkICovO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTkRLQ2xhc3NpZmllZCBmcm9tIGFuIGV4aXN0aW5nIE5ES0V2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgTkRLRXZlbnQgdG8gY3JlYXRlIHRoZSBOREtDbGFzc2lmaWVkIGZyb20uXG4gICAqIEByZXR1cm5zIE5ES0NsYXNzaWZpZWRcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLQ2xhc3NpZmllZChldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCB0aXRsZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgY2xhc3NpZmllZCB0aXRsZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ0aXRsZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCB0aXRsZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHRpdGxlIC0gVGhlIHRpdGxlIHRvIHNldCBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqL1xuICBzZXQgdGl0bGUodGl0bGUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInRpdGxlXCIpO1xuICAgIGlmICh0aXRsZSkgdGhpcy50YWdzLnB1c2goW1widGl0bGVcIiwgdGl0bGVdKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCBzdW1tYXJ5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBjbGFzc2lmaWVkIHN1bW1hcnkgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHN1bW1hcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJzdW1tYXJ5XCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIHN1bW1hcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBzdW1tYXJ5IC0gVGhlIHN1bW1hcnkgdG8gc2V0IGZvciB0aGUgY2xhc3NpZmllZC5cbiAgICovXG4gIHNldCBzdW1tYXJ5KHN1bW1hcnkpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN1bW1hcnlcIik7XG4gICAgaWYgKHN1bW1hcnkpIHRoaXMudGFncy5wdXNoKFtcInN1bW1hcnlcIiwgc3VtbWFyeV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkJ3MgcHVibGljYXRpb24gdGltZXN0YW1wLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfSAtIFRoZSBVbml4IHRpbWVzdGFtcCBvZiB3aGVuIHRoZSBjbGFzc2lmaWVkIHdhcyBwdWJsaXNoZWQgb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHB1Ymxpc2hlZF9hdCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwicHVibGlzaGVkX2F0XCIpO1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQodGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IHRpbWVzdGFtcCAtIFRoZSBVbml4IHRpbWVzdGFtcCB0byBzZXQgZm9yIHRoZSBjbGFzc2lmaWVkJ3MgcHVibGljYXRpb24gZGF0ZS5cbiAgICovXG4gIHNldCBwdWJsaXNoZWRfYXQodGltZXN0YW1wKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwdWJsaXNoZWRfYXRcIik7XG4gICAgaWYgKHRpbWVzdGFtcCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwdWJsaXNoZWRfYXRcIiwgdGltZXN0YW1wLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgbG9jYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGNsYXNzaWZpZWQgbG9jYXRpb24gaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IGxvY2F0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwibG9jYXRpb25cIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgbG9jYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiB0byBzZXQgZm9yIHRoZSBjbGFzc2lmaWVkLlxuICAgKi9cbiAgc2V0IGxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJsb2NhdGlvblwiKTtcbiAgICBpZiAobG9jYXRpb24pIHRoaXMudGFncy5wdXNoKFtcImxvY2F0aW9uXCIsIGxvY2F0aW9uXSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgcHJpY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtOREtDbGFzc2lmaWVkUHJpY2VUYWcgfCB1bmRlZmluZWR9IC0gVGhlIGNsYXNzaWZpZWQgcHJpY2UgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHByaWNlKCkge1xuICAgIGNvbnN0IHByaWNlVGFnID0gdGhpcy50YWdzLmZpbmQoKHRhZykgPT4gdGFnWzBdID09PSBcInByaWNlXCIpO1xuICAgIGlmIChwcmljZVRhZykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYW1vdW50OiBOdW1iZXIucGFyc2VGbG9hdChwcmljZVRhZ1sxXSksXG4gICAgICAgIGN1cnJlbmN5OiBwcmljZVRhZ1syXSxcbiAgICAgICAgZnJlcXVlbmN5OiBwcmljZVRhZ1szXVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCBwcmljZS5cbiAgICpcbiAgICogQHBhcmFtIHByaWNlIC0gVGhlIHByaWNlIHRvIHNldCBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqL1xuICBzZXQgcHJpY2UocHJpY2VUYWcpIHtcbiAgICBpZiAodHlwZW9mIHByaWNlVGFnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwcmljZVRhZyA9IHtcbiAgICAgICAgYW1vdW50OiBOdW1iZXIucGFyc2VGbG9hdChwcmljZVRhZylcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwcmljZVRhZz8uYW1vdW50KSB7XG4gICAgICBjb25zdCB0YWcgPSBbXCJwcmljZVwiLCBwcmljZVRhZy5hbW91bnQudG9TdHJpbmcoKV07XG4gICAgICBpZiAocHJpY2VUYWcuY3VycmVuY3kpIHRhZy5wdXNoKHByaWNlVGFnLmN1cnJlbmN5KTtcbiAgICAgIGlmIChwcmljZVRhZy5mcmVxdWVuY3kpIHRhZy5wdXNoKHByaWNlVGFnLmZyZXF1ZW5jeSk7XG4gICAgICB0aGlzLnRhZ3MucHVzaCh0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVRhZyhcInByaWNlXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvbnRlbnQgdGFncyBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZpcnN0IGNoZWNrcyBhbmQgc2V0cyB0aGUgcHVibGljYXRpb24gZGF0ZSBpZiBub3QgYXZhaWxhYmxlLFxuICAgKiBhbmQgdGhlbiBnZW5lcmF0ZXMgY29udGVudCB0YWdzIGJhc2VkIG9uIHRoZSBiYXNlIE5ES0V2ZW50IGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gLSBUaGUgZ2VuZXJhdGVkIGNvbnRlbnQgdGFncy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlVGFncygpIHtcbiAgICBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgICBpZiAoIXRoaXMucHVibGlzaGVkX2F0KSB7XG4gICAgICB0aGlzLnB1Ymxpc2hlZF9hdCA9IHRoaXMuY3JlYXRlZF9hdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2RyYWZ0cy50c1xudmFyIE5ES0RyYWZ0ID0gY2xhc3MgX05ES0RyYWZ0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBfZXZlbnQ7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMxMjM0IC8qIERyYWZ0ICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRHJhZnQoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYW4gaWRlbnRpZmllciAoaS5lLiBkLXRhZylcbiAgICovXG4gIHNldCBpZGVudGlmaWVyKGlkKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImRcIiwgaWRdKTtcbiAgfVxuICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5kVGFnO1xuICB9XG4gIC8qKlxuICAgKiBFdmVudCB0aGF0IGlzIHRvIGJlIHNhdmVkLlxuICAgKi9cbiAgc2V0IGV2ZW50KGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIE5ES0V2ZW50KSB0aGlzLl9ldmVudCA9IGUucmF3RXZlbnQoKTtcbiAgICBlbHNlIHRoaXMuX2V2ZW50ID0gZTtcbiAgICB0aGlzLnByZXBhcmVFdmVudCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBldmVudC5cbiAgICogQHBhcmFtIHBhcmFtMFxuICAgKiBAcmV0dXJucyBOREtFdmVudCBvZiB0aGUgZHJhZnQgZXZlbnQgb3IgbnVsbCBpZiB0aGUgZHJhZnQgZXZlbnQgaGFzIGJlZW4gZGVsZXRlZCAoZW1wdGllZCkuXG4gICAqL1xuICBhc3luYyBnZXRFdmVudChzaWduZXIpIHtcbiAgICBpZiAodGhpcy5fZXZlbnQpIHJldHVybiBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHRoaXMuX2V2ZW50KTtcbiAgICBzaWduZXIgPz89IHRoaXMubmRrPy5zaWduZXI7XG4gICAgaWYgKCFzaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHNpZ25lci51c2VyKCk7XG4gICAgaWYgKHRoaXMuY29udGVudCAmJiB0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5kZWNyeXB0KHVzZXIsIHNpZ25lcik7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgICAgIHRoaXMuX2V2ZW50ID0gcGF5bG9hZDtcbiAgICAgICAgcmV0dXJuIG5ldyBOREtFdmVudCh0aGlzLm5kaywgcGF5bG9hZCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwcmVwYXJlRXZlbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXZlbnQgaGFzIGJlZW4gcHJvdmlkZWRcIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJrXCIpO1xuICAgIGlmICh0aGlzLl9ldmVudC5raW5kKSB0aGlzLnRhZ3MucHVzaChbXCJrXCIsIHRoaXMuX2V2ZW50LmtpbmQudG9TdHJpbmcoKV0pO1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHRoaXMuX2V2ZW50KTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGRyYWZ0IGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gc2lnbmVyOiBPcHRpb25hbCBzaWduZXIgdG8gZW5jcnlwdCB3aXRoXG4gICAqIEBwYXJhbSBwdWJsaXNoOiBXaGV0aGVyIHRvIHB1Ymxpc2gsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyByZWxheVNldCB0byBwdWJsaXNoIHRvXG4gICAqL1xuICBhc3luYyBzYXZlKHsgc2lnbmVyLCBwdWJsaXNoLCByZWxheVNldCB9KSB7XG4gICAgc2lnbmVyID8/PSB0aGlzLm5kaz8uc2lnbmVyO1xuICAgIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBzaWduZXIudXNlcigpO1xuICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh1c2VyLCBzaWduZXIpO1xuICAgIGlmIChwdWJsaXNoID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2gocmVsYXlTZXQpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2R2bS9mZWVkYmFjay50c1xudmFyIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMyKSA9PiB7XG4gIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzMltcIlByb2Nlc3NpbmdcIl0gPSBcInByb2Nlc3NpbmdcIjtcbiAgTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMyW1wiU3VjY2Vzc1wiXSA9IFwic3VjY2Vzc1wiO1xuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1czJbXCJTY2hlZHVsZWRcIl0gPSBcInNjaGVkdWxlZFwiO1xuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1czJbXCJQYXlSZXFcIl0gPSBcInBheW1lbnRfcmVxdWlyZWRcIjtcbiAgcmV0dXJuIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzMjtcbn0pKE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzIHx8IHt9KTtcbnZhciBOREtEVk1Kb2JGZWVkYmFjayA9IGNsYXNzIF9OREtEVk1Kb2JGZWVkYmFjayBleHRlbmRzIE5ES0V2ZW50IHtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gN2UzIC8qIERWTUpvYkZlZWRiYWNrICovO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tKGV2ZW50KSB7XG4gICAgY29uc3QgZSA9IG5ldyBfTkRLRFZNSm9iRmVlZGJhY2soZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgICBpZiAoZS5lbmNyeXB0ZWQpIGF3YWl0IGUuZHZtRGVjcnlwdCgpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJzdGF0dXNcIik7XG4gIH1cbiAgc2V0IHN0YXR1cyhzdGF0dXMpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN0YXR1c1wiKTtcbiAgICBpZiAoc3RhdHVzICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInN0YXR1c1wiLCBzdGF0dXNdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGVuY3J5cHRlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldE1hdGNoaW5nVGFncyhcImVuY3J5cHRlZFwiKVswXTtcbiAgfVxuICBhc3luYyBkdm1EZWNyeXB0KCkge1xuICAgIGF3YWl0IHRoaXMuZGVjcnlwdCgpO1xuICAgIGNvbnN0IGRlY3J5cHRlZENvbnRlbnQgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgdGhpcy50YWdzLnB1c2goLi4uZGVjcnlwdGVkQ29udGVudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZHZtL3JlcXVlc3QudHNcbnZhciBOREtEVk1SZXF1ZXN0ID0gY2xhc3MgX05ES0RWTVJlcXVlc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRFZNUmVxdWVzdChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIHNldCBiaWQobXNhdEFtb3VudCkge1xuICAgIGlmIChtc2F0QW1vdW50ID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVtb3ZlVGFnKFwiYmlkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJiaWRcIiwgbXNhdEFtb3VudC50b1N0cmluZygpXSk7XG4gICAgfVxuICB9XG4gIGdldCBiaWQoKSB7XG4gICAgY29uc3QgdiA9IHRoaXMudGFnVmFsdWUoXCJiaWRcIik7XG4gICAgaWYgKHYgPT09IHZvaWQgMCkgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHYpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGlucHV0IHRvIHRoZSBqb2JcbiAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cyB0byB0aGUgaW5wdXRcbiAgICovXG4gIGFkZElucHV0KC4uLmFyZ3MpIHtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJpXCIsIC4uLmFyZ3NdKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBwYXJhbWV0ZXIgdG8gdGhlIGpvYlxuICAgKi9cbiAgYWRkUGFyYW0oLi4uYXJncykge1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBhcmFtXCIsIC4uLmFyZ3NdKTtcbiAgfVxuICBzZXQgb3V0cHV0KG91dHB1dCkge1xuICAgIGlmIChvdXRwdXQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW1vdmVUYWcoXCJvdXRwdXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygb3V0cHV0ID09PSBcInN0cmluZ1wiKSBvdXRwdXQgPSBbb3V0cHV0XTtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcIm91dHB1dFwiLCAuLi5vdXRwdXRdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG91dHB1dCgpIHtcbiAgICBjb25zdCBvdXRwdXRUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcIm91dHB1dFwiKVswXTtcbiAgICByZXR1cm4gb3V0cHV0VGFnID8gb3V0cHV0VGFnLnNsaWNlKDEpIDogdm9pZCAwO1xuICB9XG4gIGdldCBwYXJhbXMoKSB7XG4gICAgY29uc3QgcGFyYW1UYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwYXJhbVwiKTtcbiAgICByZXR1cm4gcGFyYW1UYWdzLm1hcCgodCkgPT4gdC5zbGljZSgxKSk7XG4gIH1cbiAgZ2V0UGFyYW0obmFtZSkge1xuICAgIGNvbnN0IHBhcmFtVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwYXJhbVwiKS5maW5kKCh0KSA9PiB0WzFdID09PSBuYW1lKTtcbiAgICByZXR1cm4gcGFyYW1UYWcgPyBwYXJhbVRhZ1syXSA6IHZvaWQgMDtcbiAgfVxuICBjcmVhdGVGZWVkYmFjayhzdGF0dXMpIHtcbiAgICBjb25zdCBmZWVkYmFjayA9IG5ldyBOREtEVk1Kb2JGZWVkYmFjayh0aGlzLm5kayk7XG4gICAgZmVlZGJhY2sudGFnKHRoaXMsIFwiam9iXCIpO1xuICAgIGZlZWRiYWNrLnN0YXR1cyA9IHN0YXR1cztcbiAgICByZXR1cm4gZmVlZGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgam9iIGVuY3J5cHRpb24gZm9yIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIGR2bSBEVk0gdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBzaWduZXIgU2lnbmVyIHRvIHVzZSBmb3IgZW5jcnlwdGlvblxuICAgKi9cbiAgYXN5bmMgZW5jcnlwdGlvbihkdm0sIHNpZ25lcikge1xuICAgIGNvbnN0IGR2bVRhZ3MgPSBbXCJpXCIsIFwicGFyYW1cIiwgXCJvdXRwdXRcIiwgXCJyZWxheXNcIiwgXCJiaWRcIl07XG4gICAgY29uc3QgdGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+IGR2bVRhZ3MuaW5jbHVkZXModFswXSkpO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+ICFkdm1UYWdzLmluY2x1ZGVzKHRbMF0pKTtcbiAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0YWdzKTtcbiAgICB0aGlzLnRhZyhkdm0pO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImVuY3J5cHRlZFwiXSk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KGR2bSwgc2lnbmVyKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgRFZNIHRoYXQgd2lsbCByZWNlaXZlIHRoZSBldmVudFxuICAgKi9cbiAgc2V0IGR2bShkdm0pIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgaWYgKGR2bSkgdGhpcy50YWcoZHZtKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9kdm0vTkRLVHJhbnNjcmlwdGlvbkRWTS50c1xudmFyIE5ES1RyYW5zY3JpcHRpb25EVk0gPSBjbGFzcyBfTkRLVHJhbnNjcmlwdGlvbkRWTSBleHRlbmRzIE5ES0RWTVJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID0gNWUzIC8qIERWTVJlcVRleHRFeHRyYWN0aW9uICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLVHJhbnNjcmlwdGlvbkRWTShldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2Ugb2YgdGhlIHRyYW5zY3JpcHRpb25cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgY29uc3QgaW5wdXRUYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJpXCIpO1xuICAgIGlmIChpbnB1dFRhZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRUYWdzWzBdWzFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSB0aXRsZSB0YWdcbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSB0aXRsZSB0YWdcbiAgICovXG4gIHNldCB0aXRsZSh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB2YWx1ZV0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgaW1hZ2UgdGFnXG4gICAqL1xuICBnZXQgaW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJpbWFnZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgaW1hZ2UgdGFnXG4gICAqL1xuICBzZXQgaW1hZ2UodmFsdWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImltYWdlXCIpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiaW1hZ2VcIiwgdmFsdWVdKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZHZtL3Jlc3VsdC50c1xudmFyIE5ES0RWTUpvYlJlc3VsdCA9IGNsYXNzIF9OREtEVk1Kb2JSZXN1bHQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRFZNSm9iUmVzdWx0KGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgc2V0QW1vdW50KG1zYXQsIGludm9pY2UpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImFtb3VudFwiKTtcbiAgICBjb25zdCB0YWcgPSBbXCJhbW91bnRcIiwgbXNhdC50b1N0cmluZygpXTtcbiAgICBpZiAoaW52b2ljZSkgdGFnLnB1c2goaW52b2ljZSk7XG4gICAgdGhpcy50YWdzLnB1c2godGFnKTtcbiAgfVxuICBzZXQgcmVzdWx0KHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5jb250ZW50ID0gXCJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250ZW50ID0gcmVzdWx0O1xuICAgIH1cbiAgfVxuICBnZXQgcmVzdWx0KCkge1xuICAgIGlmICh0aGlzLmNvbnRlbnQgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gIH1cbiAgc2V0IHN0YXR1cyhzdGF0dXMpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN0YXR1c1wiKTtcbiAgICBpZiAoc3RhdHVzICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInN0YXR1c1wiLCBzdGF0dXNdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInN0YXR1c1wiKTtcbiAgfVxuICBnZXQgam9iUmVxdWVzdElkKCkge1xuICAgIGZvciAoY29uc3QgZVRhZyBvZiB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikpIHtcbiAgICAgIGlmIChlVGFnWzJdID09PSBcImpvYlwiKSByZXR1cm4gZVRhZ1sxXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuam9iUmVxdWVzdCkgcmV0dXJuIHRoaXMuam9iUmVxdWVzdC5pZDtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImVcIik7XG4gIH1cbiAgc2V0IGpvYlJlcXVlc3QoZXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInJlcXVlc3RcIik7XG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICB0aGlzLmtpbmQgPSBldmVudC5raW5kICsgMWUzO1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicmVxdWVzdFwiLCBKU09OLnN0cmluZ2lmeShldmVudC5yYXdFdmVudCgpKV0pO1xuICAgICAgdGhpcy50YWcoZXZlbnQpO1xuICAgIH1cbiAgfVxuICBnZXQgam9iUmVxdWVzdCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwicmVxdWVzdFwiKTtcbiAgICBpZiAodGFnID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTkRLRXZlbnQodGhpcy5uZGssIEpTT04ucGFyc2UodGFnKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvY2FzaHUvdHgudHNcbnZhciBNQVJLRVJTID0ge1xuICBSRURFRU1FRDogXCJyZWRlZW1lZFwiLFxuICBDUkVBVEVEOiBcImNyZWF0ZWRcIixcbiAgREVTVFJPWUVEOiBcImRlc3Ryb3llZFwiLFxuICBSRVNFUlZFRDogXCJyZXNlcnZlZFwiXG59O1xudmFyIE5ES0Nhc2h1V2FsbGV0VHggPSBjbGFzcyBfTkRLQ2FzaHVXYWxsZXRUeCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIE1BUktFUlMgPSBNQVJLRVJTO1xuICBzdGF0aWMga2luZCA9IDczNzYgLyogQ2FzaHVXYWxsZXRUeCAqLztcbiAgc3RhdGljIGtpbmRzID0gWzczNzYgLyogQ2FzaHVXYWxsZXRUeCAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDczNzYgLyogQ2FzaHVXYWxsZXRUeCAqLztcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbShldmVudCkge1xuICAgIGNvbnN0IHdhbGxldENoYW5nZSA9IG5ldyBfTkRLQ2FzaHVXYWxsZXRUeChldmVudC5uZGssIGV2ZW50KTtcbiAgICBjb25zdCBwcmV2Q29udGVudCA9IHdhbGxldENoYW5nZS5jb250ZW50O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB3YWxsZXRDaGFuZ2UuZGVjcnlwdCgpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICB3YWxsZXRDaGFuZ2UuY29udGVudCA/Pz0gcHJldkNvbnRlbnQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb250ZW50VGFncyA9IEpTT04ucGFyc2Uod2FsbGV0Q2hhbmdlLmNvbnRlbnQpO1xuICAgICAgd2FsbGV0Q2hhbmdlLnRhZ3MgPSBbLi4uY29udGVudFRhZ3MsIC4uLndhbGxldENoYW5nZS50YWdzXTtcbiAgICB9IGNhdGNoIChfZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gd2FsbGV0Q2hhbmdlO1xuICB9XG4gIHNldCBkaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkaXJlY3Rpb25cIik7XG4gICAgaWYgKGRpcmVjdGlvbikgdGhpcy50YWdzLnB1c2goW1wiZGlyZWN0aW9uXCIsIGRpcmVjdGlvbl0pO1xuICB9XG4gIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJkaXJlY3Rpb25cIik7XG4gIH1cbiAgc2V0IGFtb3VudChhbW91bnQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImFtb3VudFwiKTtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJhbW91bnRcIiwgYW1vdW50LnRvU3RyaW5nKCldKTtcbiAgfVxuICBnZXQgYW1vdW50KCkge1xuICAgIGNvbnN0IHZhbCA9IHRoaXMudGFnVmFsdWUoXCJhbW91bnRcIik7XG4gICAgaWYgKHZhbCA9PT0gdm9pZCAwKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBOdW1iZXIodmFsKTtcbiAgfVxuICBzZXQgZmVlKGZlZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZmVlXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImZlZVwiLCBmZWUudG9TdHJpbmcoKV0pO1xuICB9XG4gIGdldCBmZWUoKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy50YWdWYWx1ZShcImZlZVwiKTtcbiAgICBpZiAodmFsID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIE51bWJlcih2YWwpO1xuICB9XG4gIHNldCB1bml0KHVuaXQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInVuaXRcIik7XG4gICAgaWYgKHVuaXQpIHRoaXMudGFncy5wdXNoKFtcInVuaXRcIiwgdW5pdC50b1N0cmluZygpXSk7XG4gIH1cbiAgZ2V0IHVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ1bml0XCIpO1xuICB9XG4gIHNldCBkZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZGVzY3JpcHRpb25cIik7XG4gICAgaWYgKGRlc2NyaXB0aW9uKSB0aGlzLnRhZ3MucHVzaChbXCJkZXNjcmlwdGlvblwiLCBkZXNjcmlwdGlvbi50b1N0cmluZygpXSk7XG4gIH1cbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZGVzY3JpcHRpb25cIik7XG4gIH1cbiAgc2V0IG1pbnQobWludCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwibWludFwiKTtcbiAgICBpZiAobWludCkgdGhpcy50YWdzLnB1c2goW1wibWludFwiLCBtaW50LnRvU3RyaW5nKCldKTtcbiAgfVxuICBnZXQgbWludCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcIm1pbnRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRhZ3MgdG9rZW5zIHRoYXQgd2VyZSBjcmVhdGVkIGluIHRoaXMgaGlzdG9yeSBldmVudFxuICAgKi9cbiAgc2V0IGRlc3Ryb3llZFRva2VucyhldmVudHMpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goZXZlbnQudGFnUmVmZXJlbmNlKE1BUktFUlMuREVTVFJPWUVEKSk7XG4gICAgfVxuICB9XG4gIHNldCBkZXN0cm95ZWRUb2tlbklkcyhpZHMpIHtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZVwiLCBpZCwgXCJcIiwgTUFSS0VSUy5ERVNUUk9ZRURdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRhZ3MgdG9rZW5zIHRoYXQgd2VyZSBjcmVhdGVkIGluIHRoaXMgaGlzdG9yeSBldmVudFxuICAgKi9cbiAgc2V0IGNyZWF0ZWRUb2tlbnMoZXZlbnRzKSB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKGV2ZW50LnRhZ1JlZmVyZW5jZShNQVJLRVJTLkNSRUFURUQpKTtcbiAgICB9XG4gIH1cbiAgc2V0IHJlc2VydmVkVG9rZW5zKGV2ZW50cykge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChldmVudC50YWdSZWZlcmVuY2UoTUFSS0VSUy5SRVNFUlZFRCkpO1xuICAgIH1cbiAgfVxuICBhZGRSZWRlZW1lZE51dHphcChldmVudCkge1xuICAgIHRoaXMudGFnKGV2ZW50LCBNQVJLRVJTLlJFREVFTUVEKTtcbiAgfVxuICBhc3luYyB0b05vc3RyRXZlbnQocHVia2V5KSB7XG4gICAgY29uc3QgZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgIGNvbnN0IHVuZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKCF0aGlzLnNob3VsZEVuY3J5cHRUYWcodGFnKSkge1xuICAgICAgICB1bmVuY3J5cHRlZFRhZ3MucHVzaCh0YWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jcnlwdGVkVGFncy5wdXNoKHRhZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudGFncyA9IHVuZW5jcnlwdGVkVGFncy5maWx0ZXIoKHQpID0+IHRbMF0gIT09IFwiY2xpZW50XCIpO1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGVuY3J5cHRlZFRhZ3MpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kaz8uc2lnbmVyPy51c2VyKCk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIsIHZvaWQgMCwgXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gc3VwZXIudG9Ob3N0ckV2ZW50KHB1YmtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBlbnRyeSBpbmNsdWRlcyBhIHJlZGVtcHRpb24gb2YgYSBOdXR6YXBcbiAgICovXG4gIGdldCBoYXNOdXR6YXBSZWRlbXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIiwgTUFSS0VSUy5SRURFRU1FRCkubGVuZ3RoID4gMDtcbiAgfVxuICBzaG91bGRFbmNyeXB0VGFnKHRhZykge1xuICAgIGNvbnN0IHVuZW5jcnlwdGVkVGFnTmFtZXMgPSBbXCJjbGllbnRcIl07XG4gICAgaWYgKHVuZW5jcnlwdGVkVGFnTmFtZXMuaW5jbHVkZXModGFnWzBdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiB0YWdbM10gPT09IE1BUktFUlMuUkVERUVNRUQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9OREtSZWxheUxpc3QudHNcbnZhciBSRUFEX01BUktFUiA9IFwicmVhZFwiO1xudmFyIFdSSVRFX01BUktFUiA9IFwid3JpdGVcIjtcbnZhciBOREtSZWxheUxpc3QgPSBjbGFzcyBfTkRLUmVsYXlMaXN0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAxMDAwMiAvKiBSZWxheUxpc3QgKi87XG4gIH1cbiAgc3RhdGljIGZyb20obmRrRXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtSZWxheUxpc3QobmRrRXZlbnQubmRrLCBuZGtFdmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICBnZXQgcmVhZFJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiclwiIHx8IHRhZ1swXSA9PT0gXCJyZWxheVwiKS5maWx0ZXIoKHRhZykgPT4gIXRhZ1syXSB8fCB0YWdbMl0gJiYgdGFnWzJdID09PSBSRUFEX01BUktFUikubWFwKCh0YWcpID0+IHRyeU5vcm1hbGl6ZVJlbGF5VXJsKHRhZ1sxXSkpLmZpbHRlcigodXJsKSA9PiAhIXVybCk7XG4gIH1cbiAgc2V0IHJlYWRSZWxheVVybHMocmVsYXlzKSB7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiByZWxheXMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgcmVsYXksIFJFQURfTUFSS0VSXSk7XG4gICAgfVxuICB9XG4gIGdldCB3cml0ZVJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiclwiIHx8IHRhZ1swXSA9PT0gXCJyZWxheVwiKS5maWx0ZXIoKHRhZykgPT4gIXRhZ1syXSB8fCB0YWdbMl0gJiYgdGFnWzJdID09PSBXUklURV9NQVJLRVIpLm1hcCgodGFnKSA9PiB0cnlOb3JtYWxpemVSZWxheVVybCh0YWdbMV0pKS5maWx0ZXIoKHVybCkgPT4gISF1cmwpO1xuICB9XG4gIHNldCB3cml0ZVJlbGF5VXJscyhyZWxheXMpIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiclwiLCByZWxheSwgV1JJVEVfTUFSS0VSXSk7XG4gICAgfVxuICB9XG4gIGdldCBib3RoUmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJyXCIgfHwgdGFnWzBdID09PSBcInJlbGF5XCIpLmZpbHRlcigodGFnKSA9PiAhdGFnWzJdKS5tYXAoKHRhZykgPT4gdGFnWzFdKTtcbiAgfVxuICBzZXQgYm90aFJlbGF5VXJscyhyZWxheXMpIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiclwiLCByZWxheV0pO1xuICAgIH1cbiAgfVxuICBnZXQgcmVsYXlzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJyXCIgfHwgdGFnWzBdID09PSBcInJlbGF5XCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIHJlbGF5U2V0IGZvciB0aGUgcmVsYXlzIGluIHRoaXMgbGlzdC5cbiAgICovXG4gIGdldCByZWxheVNldCgpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREtSZWxheUxpc3QgaGFzIG5vIE5ESyBpbnN0YW5jZVwiKTtcbiAgICByZXR1cm4gbmV3IE5ES1JlbGF5U2V0KFxuICAgICAgbmV3IFNldCh0aGlzLnJlbGF5cy5tYXAoKHUpID0+IHRoaXMubmRrPy5wb29sLmdldFJlbGF5KHUpKS5maWx0ZXIoKHIpID0+ICEhcikpLFxuICAgICAgdGhpcy5uZGtcbiAgICApO1xuICB9XG59O1xuZnVuY3Rpb24gcmVsYXlMaXN0RnJvbUtpbmQzKG5kaywgY29udGFjdExpc3QpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjb250ZW50ID0gSlNPTi5wYXJzZShjb250YWN0TGlzdC5jb250ZW50KTtcbiAgICBjb25zdCByZWxheUxpc3QgPSBuZXcgTkRLUmVsYXlMaXN0KG5kayk7XG4gICAgY29uc3QgcmVhZFJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgd3JpdGVSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IFtrZXksIGNvbmZpZ10gb2YgT2JqZWN0LmVudHJpZXMoY29udGVudCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZVJlbGF5VXJsKGtleSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICByZWFkUmVsYXlzLmFkZChrZXkpO1xuICAgICAgICB3cml0ZVJlbGF5cy5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlbGF5Q29uZmlnID0gY29uZmlnO1xuICAgICAgICBpZiAocmVsYXlDb25maWcud3JpdGUpIHdyaXRlUmVsYXlzLmFkZChrZXkpO1xuICAgICAgICBpZiAocmVsYXlDb25maWcucmVhZCkgcmVhZFJlbGF5cy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVsYXlMaXN0LnJlYWRSZWxheVVybHMgPSBBcnJheS5mcm9tKHJlYWRSZWxheXMpO1xuICAgIHJlbGF5TGlzdC53cml0ZVJlbGF5VXJscyA9IEFycmF5LmZyb20od3JpdGVSZWxheXMpO1xuICAgIHJldHVybiByZWxheUxpc3Q7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvbmlwODkvYXBwLWhhbmRsZXIudHNcbnZhciBOREtBcHBIYW5kbGVyRXZlbnQgPSBjbGFzcyBfTkRLQXBwSGFuZGxlckV2ZW50IGV4dGVuZHMgTkRLRXZlbnQge1xuICBwcm9maWxlO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzMTk5MCAvKiBBcHBIYW5kbGVyICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKG5ka0V2ZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgX05ES0FwcEhhbmRsZXJFdmVudChuZGtFdmVudC5uZGssIG5ka0V2ZW50LnJhd0V2ZW50KCkpO1xuICAgIGlmIChldmVudC5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIGNvbnN0IGNvbWJpbmF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgY29tYmluYXRpb25Gcm9tVGFnID0gKHRhZykgPT4gW3RhZ1swXSwgdGFnWzJdXS5qb2luKFwiOlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHRhZ3NUb0luc3BlY3QgPSBbXCJ3ZWJcIiwgXCJhbmRyb2lkXCIsIFwiaW9zXCJdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKHRhZ3NUb0luc3BlY3QuaW5jbHVkZXModGFnWzBdKSkge1xuICAgICAgICBjb25zdCBjb21iaW5hdGlvbiA9IGNvbWJpbmF0aW9uRnJvbVRhZyh0YWcpO1xuICAgICAgICBpZiAoY29tYmluYXRpb25zLmhhcyhjb21iaW5hdGlvbikpIHtcbiAgICAgICAgICBpZiAoY29tYmluYXRpb25zLmdldChjb21iaW5hdGlvbikgIT09IHRhZ1sxXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbWJpbmF0aW9ucy5zZXQoY29tYmluYXRpb24sIHRhZ1sxXS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgYXBwIGhhbmRsZXIgaW5mb3JtYXRpb25cbiAgICogSWYgbm8gYXBwIGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZSBvbiB0aGUga2luZDozMTk5MCxcbiAgICogd2UgZmV0Y2ggdGhlIGV2ZW50J3MgYXV0aG9yJ3MgcHJvZmlsZSBhbmQgcmV0dXJuIHRoYXQgaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGZldGNoUHJvZmlsZSgpIHtcbiAgICBpZiAodGhpcy5wcm9maWxlID09PSB2b2lkIDAgJiYgdGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHByb2ZpbGUgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgICAgIGlmIChwcm9maWxlPy5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2ZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9maWxlID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICAgIHRoaXMucHJvZmlsZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBhdXRob3IgPSB0aGlzLmF1dGhvcjtcbiAgICAgIGF1dGhvci5mZXRjaFByb2ZpbGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShhdXRob3IucHJvZmlsZSk7XG4gICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3JlcG9zdC50c1xudmFyIE5ES1JlcG9zdCA9IGNsYXNzIF9OREtSZXBvc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIF9yZXBvc3RlZEV2ZW50cztcbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtSZXBvc3QoZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgcmVwb3N0ZWQgZXZlbnRzIGJ5IHRoZSBjdXJyZW50IGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ga2xhc3MgT3B0aW9uYWwgY2xhc3MgdG8gY29udmVydCB0aGUgZXZlbnRzIHRvLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgcmVwb3N0ZWRFdmVudHMoa2xhc3MsIG9wdHMpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3Qgc2V0XCIpO1xuICAgIGlmICh0aGlzLl9yZXBvc3RlZEV2ZW50cyAhPT0gdm9pZCAwKSByZXR1cm4gdGhpcy5fcmVwb3N0ZWRFdmVudHM7XG4gICAgZm9yIChjb25zdCBldmVudElkIG9mIHRoaXMucmVwb3N0ZWRFdmVudElkcygpKSB7XG4gICAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJGb3JJZChldmVudElkKTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChmaWx0ZXIsIG9wdHMpO1xuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGl0ZW1zLnB1c2goa2xhc3MgPyBrbGFzcy5mcm9tKGV2ZW50KSA6IGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXBvc3RlZCBldmVudCBJRHMuXG4gICAqL1xuICByZXBvc3RlZEV2ZW50SWRzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0KSA9PiB0WzBdID09PSBcImVcIiB8fCB0WzBdID09PSBcImFcIikubWFwKCh0KSA9PiB0WzFdKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZpbHRlckZvcklkKGlkKSB7XG4gIGlmIChpZC5tYXRjaCgvOi8pKSB7XG4gICAgY29uc3QgW2tpbmQsIHB1YmtleSwgaWRlbnRpZmllcl0gPSBpZC5zcGxpdChcIjpcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmRzOiBbTnVtYmVyLnBhcnNlSW50KGtpbmQpXSxcbiAgICAgIGF1dGhvcnM6IFtwdWJrZXldLFxuICAgICAgXCIjZFwiOiBbaWRlbnRpZmllcl1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7IGlkczogW2lkXSB9O1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3N1YnNjcmlwdGlvbnMvcmVjZWlwdC50c1xuaW1wb3J0IGRlYnVnMyBmcm9tIFwiZGVidWdcIjtcbnZhciBOREtTdWJzY3JpcHRpb25SZWNlaXB0ID0gY2xhc3MgX05ES1N1YnNjcmlwdGlvblJlY2VpcHQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGRlYnVnO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA3MDAzIC8qIFN1YnNjcmlwdGlvblJlY2VpcHQgKi87XG4gICAgdGhpcy5kZWJ1ZyA9IG5kaz8uZGVidWcuZXh0ZW5kKFwic3Vic2NyaXB0aW9uLXN0YXJ0XCIpID8/IGRlYnVnMyhcIm5kazpzdWJzY3JpcHRpb24tc3RhcnRcIik7XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTdWJzY3JpcHRpb25SZWNlaXB0KGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIHBlcnNvbiBiZWluZyBzdWJzY3JpYmVkIHRvXG4gICAqL1xuICBnZXQgcmVjaXBpZW50KCkge1xuICAgIGNvbnN0IHBUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIik/LlswXTtcbiAgICBpZiAoIXBUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBwVGFnWzFdIH0pO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIHNldCByZWNpcGllbnQodXNlcikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicFwiKTtcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHVzZXIucHVia2V5XSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgaXMgdGhlIHBlcnNvbiBzdWJzY3JpYmluZ1xuICAgKi9cbiAgZ2V0IHN1YnNjcmliZXIoKSB7XG4gICAgY29uc3QgUFRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiUFwiKT8uWzBdO1xuICAgIGlmICghUFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IFBUYWdbMV0gfSk7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgc2V0IHN1YnNjcmliZXIodXNlcikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiUFwiKTtcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJQXCIsIHVzZXIucHVia2V5XSk7XG4gIH1cbiAgc2V0IHN1YnNjcmlwdGlvblN0YXJ0KGV2ZW50KSB7XG4gICAgdGhpcy5kZWJ1ZyhgYmVmb3JlIHNldHRpbmcgc3Vic2NyaXB0aW9uIHN0YXJ0OiAke3RoaXMucmF3RXZlbnR9YCk7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJlXCIpO1xuICAgIHRoaXMudGFnKGV2ZW50LCBcInN1YnNjcmlwdGlvblwiLCB0cnVlKTtcbiAgICB0aGlzLmRlYnVnKGBhZnRlciBzZXR0aW5nIHN1YnNjcmlwdGlvbiBzdGFydDogJHt0aGlzLnJhd0V2ZW50fWApO1xuICB9XG4gIGdldCB0aWVyTmFtZSgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInRpZXJcIik/LlswXTtcbiAgICByZXR1cm4gdGFnPy5bMV07XG4gIH1cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgY29uc3QgcGVyaW9kID0gdGhpcy52YWxpZFBlcmlvZDtcbiAgICBpZiAoIXBlcmlvZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGVyaW9kLnN0YXJ0ID4gcGVyaW9kLmVuZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwVGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKTtcbiAgICBjb25zdCBQVGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiUFwiKTtcbiAgICBpZiAocFRhZ3MubGVuZ3RoICE9PSAxIHx8IFBUYWdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXQgdmFsaWRQZXJpb2QoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJ2YWxpZFwiKT8uWzBdO1xuICAgIGlmICghdGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogbmV3IERhdGUoTnVtYmVyLnBhcnNlSW50KHRhZ1sxXSkgKiAxZTMpLFxuICAgICAgICBlbmQ6IG5ldyBEYXRlKE51bWJlci5wYXJzZUludCh0YWdbMl0pICogMWUzKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHNldCB2YWxpZFBlcmlvZChwZXJpb2QpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInZhbGlkXCIpO1xuICAgIGlmICghcGVyaW9kKSByZXR1cm47XG4gICAgdGhpcy50YWdzLnB1c2goW1xuICAgICAgXCJ2YWxpZFwiLFxuICAgICAgTWF0aC5mbG9vcihwZXJpb2Quc3RhcnQuZ2V0VGltZSgpIC8gMWUzKS50b1N0cmluZygpLFxuICAgICAgTWF0aC5mbG9vcihwZXJpb2QuZW5kLmdldFRpbWUoKSAvIDFlMykudG9TdHJpbmcoKVxuICAgIF0pO1xuICB9XG4gIGdldCBzdGFydFBlcmlvZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZFBlcmlvZD8uc3RhcnQ7XG4gIH1cbiAgZ2V0IGVuZFBlcmlvZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZFBlcmlvZD8uZW5kO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdWJzY3JpcHRpb24gaXMgY3VycmVudGx5IGFjdGl2ZVxuICAgKi9cbiAgaXNBY3RpdmUodGltZSkge1xuICAgIHRpbWUgPz89IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHBlcmlvZCA9IHRoaXMudmFsaWRQZXJpb2Q7XG4gICAgaWYgKCFwZXJpb2QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGltZSA8IHBlcmlvZC5zdGFydCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aW1lID4gcGVyaW9kLmVuZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3N1YnNjcmlwdGlvbnMvc3Vic2NyaXB0aW9uLXN0YXJ0LnRzXG5pbXBvcnQgZGVidWc0IGZyb20gXCJkZWJ1Z1wiO1xudmFyIE5ES1N1YnNjcmlwdGlvblN0YXJ0ID0gY2xhc3MgX05ES1N1YnNjcmlwdGlvblN0YXJ0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBkZWJ1ZztcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gNzAwMSAvKiBTdWJzY3JpYmUgKi87XG4gICAgdGhpcy5kZWJ1ZyA9IG5kaz8uZGVidWcuZXh0ZW5kKFwic3Vic2NyaXB0aW9uLXN0YXJ0XCIpID8/IGRlYnVnNChcIm5kazpzdWJzY3JpcHRpb24tc3RhcnRcIik7XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTdWJzY3JpcHRpb25TdGFydChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWNpcGllbnQgb2YgdGhlIHN1YnNjcmlwdGlvbi4gSS5lLiBUaGUgYXV0aG9yIG9mIHRoaXMgZXZlbnQgc3Vic2NyaWJlcyB0byB0aGlzIHVzZXIuXG4gICAqL1xuICBnZXQgcmVjaXBpZW50KCkge1xuICAgIGNvbnN0IHBUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIik/LlswXTtcbiAgICBpZiAoIXBUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBwVGFnWzFdIH0pO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIHNldCByZWNpcGllbnQodXNlcikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicFwiKTtcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHVzZXIucHVia2V5XSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIGdldCBhbW91bnQoKSB7XG4gICAgY29uc3QgYW1vdW50VGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIik/LlswXTtcbiAgICBpZiAoIWFtb3VudFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gcGFyc2VUYWdUb1N1YnNjcmlwdGlvbkFtb3VudChhbW91bnRUYWcpO1xuICB9XG4gIHNldCBhbW91bnQoYW1vdW50KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhbW91bnRcIik7XG4gICAgaWYgKCFhbW91bnQpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChuZXdBbW91bnQoYW1vdW50LmFtb3VudCwgYW1vdW50LmN1cnJlbmN5LCBhbW91bnQudGVybSkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgaWQgb3IgTklQLTMzIHRhZyBpZCBvZiB0aGUgdGllciB0aGF0IHRoZSB1c2VyIGlzIHN1YnNjcmliaW5nIHRvLlxuICAgKi9cbiAgZ2V0IHRpZXJJZCgpIHtcbiAgICBjb25zdCBlVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIpPy5bMF07XG4gICAgY29uc3QgYVRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiYVwiKT8uWzBdO1xuICAgIGlmICghZVRhZyB8fCAhYVRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gZVRhZ1sxXSA/PyBhVGFnWzFdO1xuICB9XG4gIHNldCB0aWVyKHRpZXIpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImVcIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhXCIpO1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZXZlbnRcIik7XG4gICAgaWYgKCF0aWVyKSByZXR1cm47XG4gICAgdGhpcy50YWcodGllcik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBcIiwgdGllci5wdWJrZXldKTtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJldmVudFwiLCBKU09OLnN0cmluZ2lmeSh0aWVyLnJhd0V2ZW50KCkpXSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgdGhlIHRpZXIgdGhhdCB0aGUgdXNlciBpcyBzdWJzY3JpYmluZyB0by5cbiAgICovXG4gIGFzeW5jIGZldGNoVGllcigpIHtcbiAgICBjb25zdCBldmVudFRhZyA9IHRoaXMudGFnVmFsdWUoXCJldmVudFwiKTtcbiAgICBpZiAoZXZlbnRUYWcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEV2ZW50ID0gSlNPTi5wYXJzZShldmVudFRhZyk7XG4gICAgICAgIHJldHVybiBuZXcgTkRLU3Vic2NyaXB0aW9uVGllcih0aGlzLm5kaywgcGFyc2VkRXZlbnQpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJGYWlsZWQgdG8gcGFyc2UgZXZlbnQgdGFnXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0aWVySWQgPSB0aGlzLnRpZXJJZDtcbiAgICBpZiAoIXRpZXJJZCkgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5uZGs/LmZldGNoRXZlbnQodGllcklkKTtcbiAgICBpZiAoIWUpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIE5ES1N1YnNjcmlwdGlvblRpZXIuZnJvbShlKTtcbiAgfVxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIikubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCAjIG9mIGFtb3VudCB0YWdcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5hbW91bnQpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJJbnZhbGlkIGFtb3VudCB0YWdcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIikubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCAjIG9mIHAgdGFnXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVjaXBpZW50KSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCBwIHRhZ1wiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMvZ2lmdC13cmFwcGluZy50c1xuaW1wb3J0IHsgZ2V0RXZlbnRIYXNoIGFzIGdldEV2ZW50SGFzaDIgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcblxuLy8gc3JjL3NpZ25lcnMvcHJpdmF0ZS1rZXkvaW5kZXgudHNcbmltcG9ydCB7IGZpbmFsaXplRXZlbnQsIGdlbmVyYXRlU2VjcmV0S2V5LCBnZXRQdWJsaWNLZXksIG5pcDA0LCBuaXA0NCB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4MiwgaGV4VG9CeXRlcyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBuaXAxOSBhcyBuaXAxOTYgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbnZhciBOREtQcml2YXRlS2V5U2lnbmVyID0gY2xhc3MgX05ES1ByaXZhdGVLZXlTaWduZXIge1xuICBfdXNlcjtcbiAgX3ByaXZhdGVLZXk7XG4gIF9wdWJrZXk7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgc2lnbmVyIGZyb20gYSBwcml2YXRlIGtleS5cbiAgICogQHBhcmFtIHByaXZhdGVLZXkgLSBUaGUgcHJpdmF0ZSBrZXkgdG8gdXNlIGluIGhleCBmb3JtIG9yIG5zZWMuXG4gICAqIEBwYXJhbSBuZGsgLSBUaGUgTkRLIGluc3RhbmNlIHRvIHVzZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGVLZXlPck5zZWMsIG5kaykge1xuICAgIGlmICh0eXBlb2YgcHJpdmF0ZUtleU9yTnNlYyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHByaXZhdGVLZXlPck5zZWMuc3RhcnRzV2l0aChcIm5zZWMxXCIpKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgZGF0YSB9ID0gbmlwMTk2LmRlY29kZShwcml2YXRlS2V5T3JOc2VjKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwibnNlY1wiKSB0aGlzLl9wcml2YXRlS2V5ID0gZGF0YTtcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByaXZhdGUga2V5IHByb3ZpZGVkLlwiKTtcbiAgICAgIH0gZWxzZSBpZiAocHJpdmF0ZUtleU9yTnNlYy5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVLZXkgPSBoZXhUb0J5dGVzKHByaXZhdGVLZXlPck5zZWMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcml2YXRlIGtleSBwcm92aWRlZC5cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ByaXZhdGVLZXkgPSBwcml2YXRlS2V5T3JOc2VjO1xuICAgIH1cbiAgICB0aGlzLl9wdWJrZXkgPSBnZXRQdWJsaWNLZXkodGhpcy5fcHJpdmF0ZUtleSk7XG4gICAgaWYgKG5kaykgdGhpcy5fdXNlciA9IG5kay5nZXRVc2VyKHsgcHVia2V5OiB0aGlzLl9wdWJrZXkgfSk7XG4gICAgdGhpcy5fdXNlciA/Pz0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IHRoaXMuX3B1YmtleSB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBwcml2YXRlIGtleSBpbiBoZXggZm9ybS5cbiAgICovXG4gIGdldCBwcml2YXRlS2V5KCkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSkgdGhyb3cgbmV3IEVycm9yKFwiTm90IHJlYWR5XCIpO1xuICAgIHJldHVybiBieXRlc1RvSGV4Mih0aGlzLl9wcml2YXRlS2V5KTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBwdWJsaWMga2V5IGluIGhleCBmb3JtLlxuICAgKi9cbiAgZ2V0IHB1YmtleSgpIHtcbiAgICBpZiAoIXRoaXMuX3B1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiTm90IHJlYWR5XCIpO1xuICAgIHJldHVybiB0aGlzLl9wdWJrZXk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJpdmF0ZSBrZXkgaW4gbnNlYyBmb3JtLlxuICAgKi9cbiAgZ2V0IG5zZWMoKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgcmVhZHlcIik7XG4gICAgcmV0dXJuIG5pcDE5Ni5uc2VjRW5jb2RlKHRoaXMuX3ByaXZhdGVLZXkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpYyBrZXkgaW4gbnB1YiBmb3JtLlxuICAgKi9cbiAgZ2V0IG5wdWIoKSB7XG4gICAgaWYgKCF0aGlzLl9wdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIk5vdCByZWFkeVwiKTtcbiAgICByZXR1cm4gbmlwMTk2Lm5wdWJFbmNvZGUodGhpcy5fcHVia2V5KTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgYSBuZXcgcHJpdmF0ZSBrZXkuXG4gICAqL1xuICBzdGF0aWMgZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGdlbmVyYXRlU2VjcmV0S2V5KCk7XG4gICAgcmV0dXJuIG5ldyBfTkRLUHJpdmF0ZUtleVNpZ25lcihwcml2YXRlS2V5KTtcbiAgfVxuICAvKipcbiAgICogTm9vcCBpbiBOREtQcml2YXRlS2V5U2lnbmVyLlxuICAgKi9cbiAgYXN5bmMgYmxvY2tVbnRpbFJlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIuXG4gICAqL1xuICBhc3luYyB1c2VyKCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIuXG4gICAqL1xuICBnZXQgdXNlclN5bmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cbiAgYXN5bmMgc2lnbihldmVudCkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gc2lnbiB3aXRob3V0IGEgcHJpdmF0ZSBrZXlcIik7XG4gICAgfVxuICAgIHJldHVybiBmaW5hbGl6ZUV2ZW50KGV2ZW50LCB0aGlzLl9wcml2YXRlS2V5KS5zaWc7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbkVuYWJsZWQoc2NoZW1lKSB7XG4gICAgY29uc3QgZW5hYmxlZCA9IFtdO1xuICAgIGlmICghc2NoZW1lIHx8IHNjaGVtZSA9PT0gXCJuaXAwNFwiKSBlbmFibGVkLnB1c2goXCJuaXAwNFwiKTtcbiAgICBpZiAoIXNjaGVtZSB8fCBzY2hlbWUgPT09IFwibmlwNDRcIikgZW5hYmxlZC5wdXNoKFwibmlwNDRcIik7XG4gICAgcmV0dXJuIGVuYWJsZWQ7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdChyZWNpcGllbnQsIHZhbHVlLCBzY2hlbWUpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGVLZXkgfHwgIXRoaXMucHJpdmF0ZUtleSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gZW5jcnlwdCB3aXRob3V0IGEgcHJpdmF0ZSBrZXlcIik7XG4gICAgfVxuICAgIGNvbnN0IHJlY2lwaWVudEhleFB1YktleSA9IHJlY2lwaWVudC5wdWJrZXk7XG4gICAgaWYgKHNjaGVtZSA9PT0gXCJuaXA0NFwiKSB7XG4gICAgICBjb25zdCBjb252ZXJzYXRpb25LZXkgPSBuaXA0NC52Mi51dGlscy5nZXRDb252ZXJzYXRpb25LZXkodGhpcy5fcHJpdmF0ZUtleSwgcmVjaXBpZW50SGV4UHViS2V5KTtcbiAgICAgIHJldHVybiBhd2FpdCBuaXA0NC52Mi5lbmNyeXB0KHZhbHVlLCBjb252ZXJzYXRpb25LZXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgbmlwMDQuZW5jcnlwdCh0aGlzLl9wcml2YXRlS2V5LCByZWNpcGllbnRIZXhQdWJLZXksIHZhbHVlKTtcbiAgfVxuICBhc3luYyBkZWNyeXB0KHNlbmRlciwgdmFsdWUsIHNjaGVtZSkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSB8fCAhdGhpcy5wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkF0dGVtcHRlZCB0byBkZWNyeXB0IHdpdGhvdXQgYSBwcml2YXRlIGtleVwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2VuZGVySGV4UHViS2V5ID0gc2VuZGVyLnB1YmtleTtcbiAgICBpZiAoc2NoZW1lID09PSBcIm5pcDQ0XCIpIHtcbiAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbktleSA9IG5pcDQ0LnYyLnV0aWxzLmdldENvbnZlcnNhdGlvbktleSh0aGlzLl9wcml2YXRlS2V5LCBzZW5kZXJIZXhQdWJLZXkpO1xuICAgICAgcmV0dXJuIGF3YWl0IG5pcDQ0LnYyLmRlY3J5cHQodmFsdWUsIGNvbnZlcnNhdGlvbktleSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBuaXAwNC5kZWNyeXB0KHRoaXMuX3ByaXZhdGVLZXksIHNlbmRlckhleFB1YktleSwgdmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBzaWduZXIncyBwcml2YXRlIGtleSBpbnRvIGEgc3RvcmFibGUgZm9ybWF0LlxuICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHR5cGUgYW5kIHRoZSBoZXggcHJpdmF0ZSBrZXkuXG4gICAqL1xuICB0b1BheWxvYWQoKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJQcml2YXRlIGtleSBub3QgYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICB0eXBlOiBcInByaXZhdGUta2V5XCIsXG4gICAgICBwYXlsb2FkOiB0aGlzLnByaXZhdGVLZXlcbiAgICAgIC8vIFVzZSB0aGUgaGV4IHByaXZhdGUga2V5XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gIH1cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplcyB0aGUgc2lnbmVyIGZyb20gYSBwYXlsb2FkIHN0cmluZy5cbiAgICogQHBhcmFtIHBheWxvYWRTdHJpbmcgVGhlIEpTT04gc3RyaW5nIG9idGFpbmVkIGZyb20gdG9QYXlsb2FkKCkuXG4gICAqIEBwYXJhbSBuZGsgT3B0aW9uYWwgTkRLIGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBOREtQcml2YXRlS2V5U2lnbmVyLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21QYXlsb2FkKHBheWxvYWRTdHJpbmcsIG5kaykge1xuICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHBheWxvYWRTdHJpbmcpO1xuICAgIGlmIChwYXlsb2FkLnR5cGUgIT09IFwicHJpdmF0ZS1rZXlcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBheWxvYWQgdHlwZTogZXhwZWN0ZWQgJ3ByaXZhdGUta2V5JywgZ290ICR7cGF5bG9hZC50eXBlfWApO1xuICAgIH1cbiAgICBpZiAoIXBheWxvYWQucGF5bG9hZCB8fCB0eXBlb2YgcGF5bG9hZC5wYXlsb2FkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBheWxvYWQgY29udGVudCBmb3IgcHJpdmF0ZS1rZXkgc2lnbmVyXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9OREtQcml2YXRlS2V5U2lnbmVyKHBheWxvYWQucGF5bG9hZCwgbmRrKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9naWZ0LXdyYXBwaW5nLnRzXG5hc3luYyBmdW5jdGlvbiBnaWZ0V3JhcChldmVudCwgcmVjaXBpZW50LCBzaWduZXIsIHBhcmFtcyA9IHt9KSB7XG4gIGxldCBfc2lnbmVyID0gc2lnbmVyO1xuICBwYXJhbXMuc2NoZW1lID8/PSBcIm5pcDQ0XCI7XG4gIGlmICghX3NpZ25lcikge1xuICAgIGlmICghZXZlbnQubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBzaWduZXIgYXZhaWxhYmxlIGZvciBnaWZ0V3JhcFwiKTtcbiAgICBfc2lnbmVyID0gZXZlbnQubmRrLnNpZ25lcjtcbiAgfVxuICBpZiAoIV9zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIm5vIHNpZ25lclwiKTtcbiAgaWYgKCFfc2lnbmVyLmVuY3J5cHRpb25FbmFibGVkIHx8ICFfc2lnbmVyLmVuY3J5cHRpb25FbmFibGVkKHBhcmFtcy5zY2hlbWUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcInNpZ25lciBpcyBub3QgYWJsZSB0byBnaWZ0V3JhcFwiKTtcbiAgY29uc3QgcnVtb3IgPSBnZXRSdW1vckV2ZW50KGV2ZW50LCBwYXJhbXM/LnJ1bW9yS2luZCk7XG4gIGNvbnN0IHNlYWwgPSBhd2FpdCBnZXRTZWFsRXZlbnQocnVtb3IsIHJlY2lwaWVudCwgX3NpZ25lciwgcGFyYW1zLnNjaGVtZSk7XG4gIGNvbnN0IHdyYXAgPSBhd2FpdCBnZXRXcmFwRXZlbnQoc2VhbCwgcmVjaXBpZW50LCBwYXJhbXMpO1xuICByZXR1cm4gbmV3IE5ES0V2ZW50KGV2ZW50Lm5kaywgd3JhcCk7XG59XG5hc3luYyBmdW5jdGlvbiBnaWZ0VW53cmFwKGV2ZW50LCBzZW5kZXIsIHNpZ25lciwgc2NoZW1lID0gXCJuaXA0NFwiKSB7XG4gIGNvbnN0IF9zZW5kZXIgPSBzZW5kZXIgfHwgbmV3IE5ES1VzZXIoeyBwdWJrZXk6IGV2ZW50LnB1YmtleSB9KTtcbiAgbGV0IF9zaWduZXIgPSBzaWduZXI7XG4gIGlmICghX3NpZ25lcikge1xuICAgIGlmICghZXZlbnQubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBzaWduZXIgYXZhaWxhYmxlIGZvciBnaWZ0VW53cmFwXCIpO1xuICAgIF9zaWduZXIgPSBldmVudC5uZGsuc2lnbmVyO1xuICB9XG4gIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJubyBzaWduZXJcIik7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2VhbCA9IEpTT04ucGFyc2UoYXdhaXQgc2lnbmVyLmRlY3J5cHQoX3NlbmRlciwgZXZlbnQuY29udGVudCwgc2NoZW1lKSk7XG4gICAgaWYgKCFzZWFsKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVjcnlwdCB3cmFwcGVyXCIpO1xuICAgIGlmICghbmV3IE5ES0V2ZW50KHZvaWQgMCwgc2VhbCkudmVyaWZ5U2lnbmF0dXJlKGZhbHNlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkdpZnRTZWFsIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gZmFpbGVkIVwiKTtcbiAgICBjb25zdCBydW1vclNlbmRlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBzZWFsLnB1YmtleSB9KTtcbiAgICBjb25zdCBydW1vciA9IEpTT04ucGFyc2UoYXdhaXQgc2lnbmVyLmRlY3J5cHQocnVtb3JTZW5kZXIsIHNlYWwuY29udGVudCwgc2NoZW1lKSk7XG4gICAgaWYgKCFydW1vcikgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY3J5cHQgc2VhbFwiKTtcbiAgICBpZiAocnVtb3IucHVia2V5ICE9PSBfc2VuZGVyLnB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBHaWZ0V3JhcCwgc2VuZGVyIHZhbGlkYXRpb24gZmFpbGVkIVwiKTtcbiAgICByZXR1cm4gbmV3IE5ES0V2ZW50KGV2ZW50Lm5kaywgcnVtb3IpO1xuICB9IGNhdGNoIChfZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIkdvdCBlcnJvciB1bndyYXBwaW5nIGV2ZW50ISBTZWUgY29uc29sZSBsb2cuXCIpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSdW1vckV2ZW50KGV2ZW50LCBraW5kKSB7XG4gIGNvbnN0IHJ1bW9yID0gZXZlbnQucmF3RXZlbnQoKTtcbiAgcnVtb3Iua2luZCA9IGtpbmQgfHwgcnVtb3Iua2luZCB8fCAxNCAvKiBQcml2YXRlRGlyZWN0TWVzc2FnZSAqLztcbiAgcnVtb3Iuc2lnID0gdm9pZCAwO1xuICBydW1vci5pZCA9IGdldEV2ZW50SGFzaDIocnVtb3IpO1xuICByZXR1cm4gbmV3IE5ES0V2ZW50KGV2ZW50Lm5kaywgcnVtb3IpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0U2VhbEV2ZW50KHJ1bW9yLCByZWNpcGllbnQsIHNpZ25lciwgc2NoZW1lID0gXCJuaXA0NFwiKSB7XG4gIGNvbnN0IHNlYWwgPSBuZXcgTkRLRXZlbnQocnVtb3IubmRrKTtcbiAgc2VhbC5raW5kID0gMTMgLyogR2lmdFdyYXBTZWFsICovO1xuICBzZWFsLmNyZWF0ZWRfYXQgPSBhcHByb3hpbWF0ZU5vdyg1KTtcbiAgc2VhbC5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkocnVtb3IucmF3RXZlbnQoKSk7XG4gIGF3YWl0IHNlYWwuZW5jcnlwdChyZWNpcGllbnQsIHNpZ25lciwgc2NoZW1lKTtcbiAgYXdhaXQgc2VhbC5zaWduKHNpZ25lcik7XG4gIHJldHVybiBzZWFsO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0V3JhcEV2ZW50KHNlYWxlZCwgcmVjaXBpZW50LCBwYXJhbXMsIHNjaGVtZSA9IFwibmlwNDRcIikge1xuICBjb25zdCBzaWduZXIgPSBOREtQcml2YXRlS2V5U2lnbmVyLmdlbmVyYXRlKCk7XG4gIGNvbnN0IHdyYXAgPSBuZXcgTkRLRXZlbnQoc2VhbGVkLm5kayk7XG4gIHdyYXAua2luZCA9IDEwNTkgLyogR2lmdFdyYXAgKi87XG4gIHdyYXAuY3JlYXRlZF9hdCA9IGFwcHJveGltYXRlTm93KDUpO1xuICBpZiAocGFyYW1zPy53cmFwVGFncykgd3JhcC50YWdzID0gcGFyYW1zLndyYXBUYWdzO1xuICB3cmFwLnRhZyhyZWNpcGllbnQpO1xuICB3cmFwLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShzZWFsZWQucmF3RXZlbnQoKSk7XG4gIGF3YWl0IHdyYXAuZW5jcnlwdChyZWNpcGllbnQsIHNpZ25lciwgc2NoZW1lKTtcbiAgYXdhaXQgd3JhcC5zaWduKHNpZ25lcik7XG4gIHJldHVybiB3cmFwO1xufVxuZnVuY3Rpb24gYXBwcm94aW1hdGVOb3coZHJpZnQgPSAwKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxZTMgLSBNYXRoLnJhbmRvbSgpICogMTAgKiogZHJpZnQpO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3NpbXBsZS1ncm91cC9pbmRleC50c1xudmFyIE5ES1NpbXBsZUdyb3VwID0gY2xhc3MgX05ES1NpbXBsZUdyb3VwIHtcbiAgbmRrO1xuICBncm91cElkO1xuICByZWxheVNldDtcbiAgZmV0Y2hpbmdNZXRhZGF0YTtcbiAgbWV0YWRhdGE7XG4gIG1lbWJlckxpc3Q7XG4gIGFkbWluTGlzdDtcbiAgY29uc3RydWN0b3IobmRrLCByZWxheVNldCwgZ3JvdXBJZCkge1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuZ3JvdXBJZCA9IGdyb3VwSWQgPz8gcmFuZG9tSWQoMjQpO1xuICAgIHRoaXMucmVsYXlTZXQgPSByZWxheVNldDtcbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXBJZDtcbiAgfVxuICByZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlTZXQ/LnJlbGF5VXJscztcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRhZGF0YT8ubmFtZTtcbiAgfVxuICBnZXQgYWJvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGE/LmFib3V0O1xuICB9XG4gIGdldCBwaWN0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhPy5waWN0dXJlO1xuICB9XG4gIGdldCBtZW1iZXJzKCkge1xuICAgIHJldHVybiB0aGlzLm1lbWJlckxpc3Q/Lm1lbWJlcnMgPz8gW107XG4gIH1cbiAgZ2V0IGFkbWlucygpIHtcbiAgICByZXR1cm4gdGhpcy5hZG1pbkxpc3Q/Lm1lbWJlcnMgPz8gW107XG4gIH1cbiAgYXN5bmMgZ2V0TWV0YWRhdGEoKSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVNZXRhZGF0YUV2ZW50KCk7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGdyb3VwIGJ5IHB1Ymxpc2hpbmcgYSBraW5kOjkwMDcgZXZlbnQuXG4gICAqIEBwYXJhbSBzaWduZXJcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUdyb3VwKHNpZ25lcikge1xuICAgIHNpZ25lciA/Pz0gdGhpcy5uZGsuc2lnbmVyO1xuICAgIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBzaWduZXIudXNlcigpO1xuICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKFwiTm8gdXNlciBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGspO1xuICAgIGV2ZW50LmtpbmQgPSA5MDA3IC8qIEdyb3VwQWRtaW5DcmVhdGVHcm91cCAqLztcbiAgICBldmVudC50YWdzLnB1c2goW1wiaFwiLCB0aGlzLmdyb3VwSWRdKTtcbiAgICBhd2FpdCBldmVudC5zaWduKHNpZ25lcik7XG4gICAgcmV0dXJuIGV2ZW50LnB1Ymxpc2godGhpcy5yZWxheVNldCk7XG4gIH1cbiAgYXN5bmMgc2V0TWV0YWRhdGEoeyBuYW1lLCBhYm91dCwgcGljdHVyZSB9KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGspO1xuICAgIGV2ZW50LmtpbmQgPSA5MDAyIC8qIEdyb3VwQWRtaW5FZGl0TWV0YWRhdGEgKi87XG4gICAgZXZlbnQudGFncy5wdXNoKFtcImhcIiwgdGhpcy5ncm91cElkXSk7XG4gICAgaWYgKG5hbWUpIGV2ZW50LnRhZ3MucHVzaChbXCJuYW1lXCIsIG5hbWVdKTtcbiAgICBpZiAoYWJvdXQpIGV2ZW50LnRhZ3MucHVzaChbXCJhYm91dFwiLCBhYm91dF0pO1xuICAgIGlmIChwaWN0dXJlKSBldmVudC50YWdzLnB1c2goW1wicGljdHVyZVwiLCBwaWN0dXJlXSk7XG4gICAgYXdhaXQgZXZlbnQuc2lnbigpO1xuICAgIHJldHVybiBldmVudC5wdWJsaXNoKHRoaXMucmVsYXlTZXQpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgdXNlciB0byB0aGUgZ3JvdXAgdXNpbmcgYSBraW5kOjkwMDAgZXZlbnRcbiAgICogQHBhcmFtIHVzZXIgdXNlciB0byBhZGRcbiAgICogQHBhcmFtIG9wdHMgb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgYWRkVXNlcih1c2VyKSB7XG4gICAgY29uc3QgYWRkVXNlckV2ZW50ID0gX05ES1NpbXBsZUdyb3VwLmdlbmVyYXRlQWRkVXNlckV2ZW50KHVzZXIucHVia2V5LCB0aGlzLmdyb3VwSWQpO1xuICAgIGFkZFVzZXJFdmVudC5uZGsgPSB0aGlzLm5kaztcbiAgICByZXR1cm4gYWRkVXNlckV2ZW50O1xuICB9XG4gIGFzeW5jIGdldE1lbWJlckxpc3RFdmVudCgpIHtcbiAgICBjb25zdCBtZW1iZXJMaXN0ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChcbiAgICAgIHtcbiAgICAgICAga2luZHM6IFszOTAwMiAvKiBHcm91cE1lbWJlcnMgKi9dLFxuICAgICAgICBcIiNkXCI6IFt0aGlzLmdyb3VwSWRdXG4gICAgICB9LFxuICAgICAgdm9pZCAwLFxuICAgICAgdGhpcy5yZWxheVNldFxuICAgICk7XG4gICAgaWYgKCFtZW1iZXJMaXN0KSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0LmZyb20obWVtYmVyTGlzdCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBsaXN0IG9mIHVzZXJzIHRoYXQgYmVsb25nIHRvIHRoaXMgZ3JvdXBcbiAgICovXG4gIGFzeW5jIGdldE1lbWJlcnMoKSB7XG4gICAgY29uc3QgbWVtYmVycyA9IFtdO1xuICAgIGNvbnN0IG1lbWJlclB1YmtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IG1lbWJlckxpc3RFdmVudCA9IGF3YWl0IHRoaXMuZ2V0TWVtYmVyTGlzdEV2ZW50KCk7XG4gICAgaWYgKCFtZW1iZXJMaXN0RXZlbnQpIHJldHVybiBbXTtcbiAgICBmb3IgKGNvbnN0IHBUYWcgb2YgbWVtYmVyTGlzdEV2ZW50LmdldE1hdGNoaW5nVGFncyhcInBcIikpIHtcbiAgICAgIGNvbnN0IHB1YmtleSA9IHBUYWdbMV07XG4gICAgICBpZiAobWVtYmVyUHVia2V5cy5oYXMocHVia2V5KSkgY29udGludWU7XG4gICAgICBtZW1iZXJQdWJrZXlzLmFkZChwdWJrZXkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWVtYmVycy5wdXNoKHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXkgfSkpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZW1iZXJzO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gZXZlbnQgdGhhdCBsaXN0cyB0aGUgbWVtYmVycyBvZiBhIGdyb3VwLlxuICAgKiBAcGFyYW0gZ3JvdXBJZFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlVXNlckxpc3RFdmVudChncm91cElkKSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodm9pZCAwLCB7XG4gICAgICBraW5kOiAzOTAwMiAvKiBHcm91cE1lbWJlcnMgKi8sXG4gICAgICB0YWdzOiBbXG4gICAgICAgIFtcImhcIiwgZ3JvdXBJZF0sXG4gICAgICAgIFtcImFsdFwiLCBcIkdyb3VwIE1lbWJlciBMaXN0XCJdXG4gICAgICBdXG4gICAgfSk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gZXZlbnQgdGhhdCBhZGRzIGEgdXNlciB0byBhIGdyb3VwLlxuICAgKiBAcGFyYW0gdXNlclB1YmtleSBwdWJrZXkgb2YgdGhlIHVzZXIgdG8gYWRkXG4gICAqIEBwYXJhbSBncm91cElkIGdyb3VwIHRvIGFkZCB0aGUgdXNlciB0b1xuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlQWRkVXNlckV2ZW50KHVzZXJQdWJrZXksIGdyb3VwSWQpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh2b2lkIDAsIHtcbiAgICAgIGtpbmQ6IDllMyAvKiBHcm91cEFkbWluQWRkVXNlciAqLyxcbiAgICAgIHRhZ3M6IFtbXCJoXCIsIGdyb3VwSWRdXVxuICAgIH0pO1xuICAgIGV2ZW50LnRhZ3MucHVzaChbXCJwXCIsIHVzZXJQdWJrZXldKTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdFRvSm9pbihfcHVia2V5LCBjb250ZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDkwMjEgLyogR3JvdXBBZG1pblJlcXVlc3RKb2luICovLFxuICAgICAgY29udGVudDogY29udGVudCA/PyBcIlwiLFxuICAgICAgdGFnczogW1tcImhcIiwgdGhpcy5ncm91cElkXV1cbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgc3VyZSB0aGF0IGEgbWV0YWRhdGEgZXZlbnQgZXhpc3RzIGxvY2FsbHlcbiAgICovXG4gIGFzeW5jIGVuc3VyZU1ldGFkYXRhRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMubWV0YWRhdGEpIHJldHVybjtcbiAgICBpZiAodGhpcy5mZXRjaGluZ01ldGFkYXRhKSByZXR1cm4gdGhpcy5mZXRjaGluZ01ldGFkYXRhO1xuICAgIHRoaXMuZmV0Y2hpbmdNZXRhZGF0YSA9IHRoaXMubmRrLmZldGNoRXZlbnQoXG4gICAgICB7XG4gICAgICAgIGtpbmRzOiBbMzllMyAvKiBHcm91cE1ldGFkYXRhICovXSxcbiAgICAgICAgXCIjZFwiOiBbdGhpcy5ncm91cElkXVxuICAgICAgfSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHRoaXMucmVsYXlTZXRcbiAgICApLnRoZW4oKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEuZnJvbShldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbmV3IE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEodGhpcy5uZGspO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLmRUYWcgPSB0aGlzLmdyb3VwSWQ7XG4gICAgICB9XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICB0aGlzLmZldGNoaW5nTWV0YWRhdGEgPSB2b2lkIDA7XG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbWV0YWRhdGEgZm9yIGdyb3VwICR7dGhpcy5ncm91cElkfWApO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmZldGNoaW5nTWV0YWRhdGE7XG4gIH1cbn07XG5mdW5jdGlvbiByYW5kb21JZChsZW5ndGgpIHtcbiAgY29uc3QgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5XCI7XG4gIGNvbnN0IGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdCArPSBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnNMZW5ndGgpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvYXBwLXNldHRpbmdzL2luZGV4LnRzXG52YXIgTkRLQXBwU2V0dGluZ3MgPSBjbGFzcyBfTkRLQXBwU2V0dGluZ3MgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGFwcE5hbWU7XG4gIHNldHRpbmdzID0ge307XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMwMDc4IC8qIEFwcFNwZWNpZmljRGF0YSAqLztcbiAgICB0aGlzLmRUYWcgPz89IHRoaXMuYXBwTmFtZTtcbiAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGFyc2luZyBhcHAgc2V0dGluZ3NcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0FwcFNldHRpbmdzKGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYSB2YWx1ZSBmb3IgYSBnaXZlbiBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuc2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSB2YWx1ZSBmb3IgYSBnaXZlbiBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5nc1trZXldO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2hSZXBsYWNlYWJsZShyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnNldHRpbmdzKTtcbiAgICByZXR1cm4gc3VwZXIucHVibGlzaFJlcGxhY2VhYmxlKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9hdXRoLXBvbGljaWVzLnRzXG5pbXBvcnQgY3JlYXRlRGVidWcyIGZyb20gXCJkZWJ1Z1wiO1xuZnVuY3Rpb24gZGlzY29ubmVjdChwb29sLCBkZWJ1ZzgpIHtcbiAgZGVidWc4ID8/PSBjcmVhdGVEZWJ1ZzIoXCJuZGs6cmVsYXk6YXV0aC1wb2xpY2llczpkaXNjb25uZWN0XCIpO1xuICByZXR1cm4gYXN5bmMgKHJlbGF5KSA9PiB7XG4gICAgZGVidWc4Py4oYFJlbGF5ICR7cmVsYXkudXJsfSByZXF1ZXN0ZWQgYXV0aGVudGljYXRpb24sIGRpc2Nvbm5lY3RpbmdgKTtcbiAgICBwb29sLnJlbW92ZVJlbGF5KHJlbGF5LnVybCk7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBzaWduQW5kQXV0aChldmVudCwgcmVsYXksIHNpZ25lciwgZGVidWc4LCByZXNvbHZlLCByZWplY3QpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBldmVudC5zaWduKHNpZ25lcik7XG4gICAgcmVzb2x2ZShldmVudCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1Zzg/LihgRmFpbGVkIHRvIHB1Ymxpc2ggYXV0aCBldmVudCB0byByZWxheSAke3JlbGF5LnVybH1gLCBlKTtcbiAgICByZWplY3QoZXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBzaWduSW4oeyBuZGssIHNpZ25lciwgZGVidWc6IGRlYnVnOCB9ID0ge30pIHtcbiAgZGVidWc4ID8/PSBjcmVhdGVEZWJ1ZzIoXCJuZGs6YXV0aC1wb2xpY2llczpzaWduSW5cIik7XG4gIHJldHVybiBhc3luYyAocmVsYXksIGNoYWxsZW5nZSkgPT4ge1xuICAgIGRlYnVnOD8uKGBSZWxheSAke3JlbGF5LnVybH0gcmVxdWVzdGVkIGF1dGhlbnRpY2F0aW9uLCBzaWduaW5nIGluYCk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrKTtcbiAgICBldmVudC5raW5kID0gMjIyNDIgLyogQ2xpZW50QXV0aCAqLztcbiAgICBldmVudC50YWdzID0gW1xuICAgICAgW1wicmVsYXlcIiwgcmVsYXkudXJsXSxcbiAgICAgIFtcImNoYWxsZW5nZVwiLCBjaGFsbGVuZ2VdXG4gICAgXTtcbiAgICBzaWduZXIgPz89IG5kaz8uc2lnbmVyO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoc2lnbmVyKSB7XG4gICAgICAgIGF3YWl0IHNpZ25BbmRBdXRoKGV2ZW50LCByZWxheSwgc2lnbmVyLCBkZWJ1ZzgsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZGs/Lm9uY2UoXCJzaWduZXI6cmVhZHlcIiwgYXN5bmMgKHNpZ25lcjIpID0+IHtcbiAgICAgICAgICBhd2FpdCBzaWduQW5kQXV0aChldmVudCwgcmVsYXksIHNpZ25lcjIsIGRlYnVnOCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG52YXIgTkRLUmVsYXlBdXRoUG9saWNpZXMgPSB7XG4gIGRpc2Nvbm5lY3QsXG4gIHNpZ25JblxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwMDcvaW5kZXgudHNcbmltcG9ydCBkZWJ1ZzUgZnJvbSBcImRlYnVnXCI7XG52YXIgTkRLTmlwMDdTaWduZXIgPSBjbGFzcyBfTkRLTmlwMDdTaWduZXIge1xuICBfdXNlclByb21pc2U7XG4gIGVuY3J5cHRpb25RdWV1ZSA9IFtdO1xuICBlbmNyeXB0aW9uUHJvY2Vzc2luZyA9IGZhbHNlO1xuICBkZWJ1ZztcbiAgd2FpdFRpbWVvdXQ7XG4gIF9wdWJrZXk7XG4gIG5kaztcbiAgX3VzZXI7XG4gIC8qKlxuICAgKiBAcGFyYW0gd2FpdFRpbWVvdXQgLSBUaGUgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgdGhlIE5JUC0wNyB0byBiZWNvbWUgYXZhaWxhYmxlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3YWl0VGltZW91dCA9IDFlMywgbmRrKSB7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnNShcIm5kazpuaXAwN1wiKTtcbiAgICB0aGlzLndhaXRUaW1lb3V0ID0gd2FpdFRpbWVvdXQ7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gIH1cbiAgZ2V0IHB1YmtleSgpIHtcbiAgICBpZiAoIXRoaXMuX3B1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiTm90IHJlYWR5XCIpO1xuICAgIHJldHVybiB0aGlzLl9wdWJrZXk7XG4gIH1cbiAgYXN5bmMgYmxvY2tVbnRpbFJlYWR5KCkge1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckV4dGVuc2lvbigpO1xuICAgIGNvbnN0IHB1YmtleSA9IGF3YWl0IHdpbmRvdy5ub3N0cj8uZ2V0UHVibGljS2V5KCk7XG4gICAgaWYgKCFwdWJrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgcmVqZWN0ZWQgYWNjZXNzXCIpO1xuICAgIH1cbiAgICB0aGlzLl9wdWJrZXkgPSBwdWJrZXk7XG4gICAgbGV0IHVzZXI7XG4gICAgaWYgKHRoaXMubmRrKSB1c2VyID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleSB9KTtcbiAgICBlbHNlIHVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleSB9KTtcbiAgICB0aGlzLl91c2VyID0gdXNlcjtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgdXNlciBwcm9wZXJ0eS5cbiAgICogQHJldHVybnMgVGhlIE5ES1VzZXIgaW5zdGFuY2UuXG4gICAqL1xuICBhc3luYyB1c2VyKCkge1xuICAgIGlmICghdGhpcy5fdXNlclByb21pc2UpIHtcbiAgICAgIHRoaXMuX3VzZXJQcm9taXNlID0gdGhpcy5ibG9ja1VudGlsUmVhZHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJQcm9taXNlO1xuICB9XG4gIGdldCB1c2VyU3luYygpIHtcbiAgICBpZiAoIXRoaXMuX3VzZXIpIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IHJlYWR5XCIpO1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIC8qKlxuICAgKiBTaWducyB0aGUgZ2l2ZW4gTm9zdHIgZXZlbnQuXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBOb3N0ciBldmVudCB0byBiZSBzaWduZWQuXG4gICAqIEByZXR1cm5zIFRoZSBzaWduYXR1cmUgb2YgdGhlIHNpZ25lZCBldmVudC5cbiAgICogQHRocm93cyBFcnJvciBpZiB0aGUgTklQLTA3IGlzIG5vdCBhdmFpbGFibGUgb24gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAqL1xuICBhc3luYyBzaWduKGV2ZW50KSB7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3Qgc2lnbmVkRXZlbnQgPSBhd2FpdCB3aW5kb3cubm9zdHI/LnNpZ25FdmVudChldmVudCk7XG4gICAgaWYgKCFzaWduZWRFdmVudCkgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHNpZ24gZXZlbnRcIik7XG4gICAgcmV0dXJuIHNpZ25lZEV2ZW50LnNpZztcbiAgfVxuICBhc3luYyByZWxheXMobmRrKSB7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3QgcmVsYXlzID0gYXdhaXQgd2luZG93Lm5vc3RyPy5nZXRSZWxheXM/LigpIHx8IHt9O1xuICAgIGNvbnN0IGFjdGl2ZVJlbGF5cyA9IFtdO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIE9iamVjdC5rZXlzKHJlbGF5cykpIHtcbiAgICAgIGlmIChyZWxheXNbdXJsXS5yZWFkICYmIHJlbGF5c1t1cmxdLndyaXRlKSB7XG4gICAgICAgIGFjdGl2ZVJlbGF5cy5wdXNoKHVybCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVSZWxheXMubWFwKCh1cmwpID0+IG5ldyBOREtSZWxheSh1cmwsIG5kaz8ucmVsYXlBdXRoRGVmYXVsdFBvbGljeSwgbmRrKSk7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbkVuYWJsZWQobmlwKSB7XG4gICAgY29uc3QgZW5hYmxlZCA9IFtdO1xuICAgIGlmICgoIW5pcCB8fCBuaXAgPT09IFwibmlwMDRcIikgJiYgQm9vbGVhbih3aW5kb3cubm9zdHI/Lm5pcDA0KSkgZW5hYmxlZC5wdXNoKFwibmlwMDRcIik7XG4gICAgaWYgKCghbmlwIHx8IG5pcCA9PT0gXCJuaXA0NFwiKSAmJiBCb29sZWFuKHdpbmRvdy5ub3N0cj8ubmlwNDQpKSBlbmFibGVkLnB1c2goXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gZW5hYmxlZDtcbiAgfVxuICBhc3luYyBlbmNyeXB0KHJlY2lwaWVudCwgdmFsdWUsIG5pcCA9IFwibmlwMDRcIikge1xuICAgIGlmICghYXdhaXQgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZChuaXApKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25pcH1lbmNyeXB0aW9uIGlzIG5vdCBhdmFpbGFibGUgZnJvbSB5b3VyIGJyb3dzZXIgZXh0ZW5zaW9uYCk7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3QgcmVjaXBpZW50SGV4UHViS2V5ID0gcmVjaXBpZW50LnB1YmtleTtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZUVuY3J5cHRpb24obmlwLCBcImVuY3J5cHRcIiwgcmVjaXBpZW50SGV4UHViS2V5LCB2YWx1ZSk7XG4gIH1cbiAgYXN5bmMgZGVjcnlwdChzZW5kZXIsIHZhbHVlLCBuaXAgPSBcIm5pcDA0XCIpIHtcbiAgICBpZiAoIWF3YWl0IHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQobmlwKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuaXB9ZW5jcnlwdGlvbiBpcyBub3QgYXZhaWxhYmxlIGZyb20geW91ciBicm93c2VyIGV4dGVuc2lvbmApO1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckV4dGVuc2lvbigpO1xuICAgIGNvbnN0IHNlbmRlckhleFB1YktleSA9IHNlbmRlci5wdWJrZXk7XG4gICAgcmV0dXJuIHRoaXMucXVldWVFbmNyeXB0aW9uKG5pcCwgXCJkZWNyeXB0XCIsIHNlbmRlckhleFB1YktleSwgdmFsdWUpO1xuICB9XG4gIGFzeW5jIHF1ZXVlRW5jcnlwdGlvbihzY2hlbWUsIG1ldGhvZCwgY291bnRlcnBhcnR5SGV4cHVia2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmVuY3J5cHRpb25RdWV1ZS5wdXNoKHtcbiAgICAgICAgc2NoZW1lLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGNvdW50ZXJwYXJ0eUhleHB1YmtleSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHJlc29sdmUsXG4gICAgICAgIHJlamVjdFxuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMuZW5jcnlwdGlvblByb2Nlc3NpbmcpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzRW5jcnlwdGlvblF1ZXVlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0VuY3J5cHRpb25RdWV1ZShpdGVtLCByZXRyaWVzID0gMCkge1xuICAgIGlmICghaXRlbSAmJiB0aGlzLmVuY3J5cHRpb25RdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmNyeXB0aW9uUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgY29uc3QgY3VycmVudEl0ZW0gPSBpdGVtIHx8IHRoaXMuZW5jcnlwdGlvblF1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKCFjdXJyZW50SXRlbSkge1xuICAgICAgdGhpcy5lbmNyeXB0aW9uUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHNjaGVtZSwgbWV0aG9kLCBjb3VudGVycGFydHlIZXhwdWJrZXksIHZhbHVlLCByZXNvbHZlLCByZWplY3QgfSA9IGN1cnJlbnRJdGVtO1xuICAgIHRoaXMuZGVidWcoXCJQcm9jZXNzaW5nIGVuY3J5cHRpb24gcXVldWUgaXRlbVwiLCB7XG4gICAgICBtZXRob2QsXG4gICAgICBjb3VudGVycGFydHlIZXhwdWJrZXksXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aW5kb3cubm9zdHI/LltzY2hlbWVdPy5bbWV0aG9kXShjb3VudGVycGFydHlIZXhwdWJrZXksIHZhbHVlKTtcbiAgICAgIGlmICghcmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZW5jcnlwdC9kZWNyeXB0XCIpO1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICBpZiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKFwiY2FsbCBhbHJlYWR5IGV4ZWN1dGluZ1wiKSAmJiByZXRyaWVzIDwgNSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiUmV0cnlpbmcgZW5jcnlwdGlvbiBxdWV1ZSBpdGVtXCIsIHtcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgY291bnRlcnBhcnR5SGV4cHVia2V5LFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHJldHJpZXNcbiAgICAgICAgfSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucHJvY2Vzc0VuY3J5cHRpb25RdWV1ZShjdXJyZW50SXRlbSwgcmV0cmllcyArIDEpO1xuICAgICAgICB9LCA1MCAqIHJldHJpZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZWplY3QoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yTWVzc2FnZSkpO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NFbmNyeXB0aW9uUXVldWUoKTtcbiAgfVxuICB3YWl0Rm9yRXh0ZW5zaW9uKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAod2luZG93Lm5vc3RyKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHRpbWVySWQ7XG4gICAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBpZiAod2luZG93Lm5vc3RyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKFwiTklQLTA3IGV4dGVuc2lvbiBub3QgYXZhaWxhYmxlXCIpKTtcbiAgICAgIH0sIHRoaXMud2FpdFRpbWVvdXQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBzaWduZXIgdHlwZSBpbnRvIGEgc3RvcmFibGUgZm9ybWF0LlxuICAgKiBOSVAtMDcgc2lnbmVycyBkb24ndCBoYXZlIHBlcnNpc3RlbnQgc3RhdGUgdG8gc2VyaWFsaXplIGJleW9uZCB0aGVpciB0eXBlLlxuICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHR5cGUuXG4gICAqL1xuICB0b1BheWxvYWQoKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHR5cGU6IFwibmlwMDdcIixcbiAgICAgIHBheWxvYWQ6IFwiXCJcbiAgICAgIC8vIE5vIHNwZWNpZmljIHBheWxvYWQgbmVlZGVkIGZvciBOSVAtMDdcbiAgICB9O1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBzaWduZXIgZnJvbSBhIHBheWxvYWQgc3RyaW5nLlxuICAgKiBDcmVhdGVzIGEgbmV3IE5ES05pcDA3U2lnbmVyIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gcGF5bG9hZFN0cmluZyBUaGUgSlNPTiBzdHJpbmcgb2J0YWluZWQgZnJvbSB0b1BheWxvYWQoKS5cbiAgICogQHBhcmFtIG5kayBPcHRpb25hbCBOREsgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIE5ES05pcDA3U2lnbmVyLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21QYXlsb2FkKHBheWxvYWRTdHJpbmcsIG5kaykge1xuICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHBheWxvYWRTdHJpbmcpO1xuICAgIGlmIChwYXlsb2FkLnR5cGUgIT09IFwibmlwMDdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBheWxvYWQgdHlwZTogZXhwZWN0ZWQgJ25pcDA3JywgZ290ICR7cGF5bG9hZC50eXBlfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9OREtOaXAwN1NpZ25lcih2b2lkIDAsIG5kayk7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvaW5kZXgudHNcbmltcG9ydCB7IGhleFRvQnl0ZXMgYXMgaGV4VG9CeXRlczIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9ycGMudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI1IH0gZnJvbSBcInRzZWVwXCI7XG52YXIgTkRLTm9zdHJScGMgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjUge1xuICBuZGs7XG4gIHNpZ25lcjtcbiAgcmVsYXlTZXQ7XG4gIGRlYnVnO1xuICBlbmNyeXB0aW9uVHlwZSA9IFwibmlwMDRcIjtcbiAgcG9vbDtcbiAgY29uc3RydWN0b3IobmRrLCBzaWduZXIsIGRlYnVnOCwgcmVsYXlVcmxzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLnNpZ25lciA9IHNpZ25lcjtcbiAgICBpZiAocmVsYXlVcmxzKSB7XG4gICAgICB0aGlzLnBvb2wgPSBuZXcgTkRLUG9vbChyZWxheVVybHMsIFtdLCBuZGssIHtcbiAgICAgICAgZGVidWc6IGRlYnVnOC5leHRlbmQoXCJycGMtcG9vbFwiKSxcbiAgICAgICAgbmFtZTogXCJOb3N0ciBSUENcIlxuICAgICAgfSk7XG4gICAgICB0aGlzLnJlbGF5U2V0ID0gbmV3IE5ES1JlbGF5U2V0KC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIG5kaywgdGhpcy5wb29sKTtcbiAgICAgIGZvciAoY29uc3QgdXJsIG9mIHJlbGF5VXJscykge1xuICAgICAgICBjb25zdCByZWxheSA9IHRoaXMucG9vbC5nZXRSZWxheSh1cmwsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIHJlbGF5LmF1dGhQb2xpY3kgPSBOREtSZWxheUF1dGhQb2xpY2llcy5zaWduSW4oeyBuZGssIHNpZ25lciwgZGVidWc6IGRlYnVnOCB9KTtcbiAgICAgICAgdGhpcy5yZWxheVNldC5hZGRSZWxheShyZWxheSk7XG4gICAgICAgIHJlbGF5LmNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnOC5leHRlbmQoXCJycGNcIik7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBhIGZpbHRlci4gVGhpcyBmdW5jdGlvbiB3aWxsIHJlc29sdmUgb25jZSB0aGUgc3Vic2NyaXB0aW9uIGlzIHJlYWR5LlxuICAgKi9cbiAgc3Vic2NyaWJlKGZpbHRlcikge1xuICAgIGNvbnN0IHN1YiA9IHRoaXMubmRrLnN1YnNjcmliZShcbiAgICAgIGZpbHRlcixcbiAgICAgIHtcbiAgICAgICAgY2xvc2VPbkVvc2U6IGZhbHNlLFxuICAgICAgICBncm91cGFibGU6IGZhbHNlLFxuICAgICAgICBjYWNoZVVzYWdlOiBcIk9OTFlfUkVMQVlcIiAvKiBPTkxZX1JFTEFZICovLFxuICAgICAgICBwb29sOiB0aGlzLnBvb2wsXG4gICAgICAgIHJlbGF5U2V0OiB0aGlzLnJlbGF5U2V0XG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHN1Yi5vbihcImV2ZW50XCIsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkRXZlbnQgPSBhd2FpdCB0aGlzLnBhcnNlRXZlbnQoZXZlbnQpO1xuICAgICAgICBpZiAocGFyc2VkRXZlbnQubWV0aG9kKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFwicmVxdWVzdFwiLCBwYXJzZWRFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbWl0KGByZXNwb25zZS0ke3BhcnNlZEV2ZW50LmlkfWAsIHBhcnNlZEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiZXJyb3IgcGFyc2luZyBldmVudFwiLCBlLCBldmVudC5yYXdFdmVudCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHN1Yi5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnKFwiZW9zZWRcIik7XG4gICAgICAgIHJlc29sdmUoc3ViKTtcbiAgICAgIH0pO1xuICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcGFyc2VFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLmVuY3J5cHRpb25UeXBlID09PSBcIm5pcDQ0XCIgJiYgZXZlbnQuY29udGVudC5pbmNsdWRlcyhcIj9pdj1cIikpIHtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBcIm5pcDA0XCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVuY3J5cHRpb25UeXBlID09PSBcIm5pcDA0XCIgJiYgIWV2ZW50LmNvbnRlbnQuaW5jbHVkZXMoXCI/aXY9XCIpKSB7XG4gICAgICB0aGlzLmVuY3J5cHRpb25UeXBlID0gXCJuaXA0NFwiO1xuICAgIH1cbiAgICBjb25zdCByZW1vdGVVc2VyID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogZXZlbnQucHVia2V5IH0pO1xuICAgIHJlbW90ZVVzZXIubmRrID0gdGhpcy5uZGs7XG4gICAgbGV0IGRlY3J5cHRlZENvbnRlbnQ7XG4gICAgdHJ5IHtcbiAgICAgIGRlY3J5cHRlZENvbnRlbnQgPSBhd2FpdCB0aGlzLnNpZ25lci5kZWNyeXB0KHJlbW90ZVVzZXIsIGV2ZW50LmNvbnRlbnQsIHRoaXMuZW5jcnlwdGlvblR5cGUpO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICBjb25zdCBvdGhlckVuY3J5cHRpb25UeXBlID0gdGhpcy5lbmNyeXB0aW9uVHlwZSA9PT0gXCJuaXAwNFwiID8gXCJuaXA0NFwiIDogXCJuaXAwNFwiO1xuICAgICAgZGVjcnlwdGVkQ29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmRlY3J5cHQocmVtb3RlVXNlciwgZXZlbnQuY29udGVudCwgb3RoZXJFbmNyeXB0aW9uVHlwZSk7XG4gICAgICB0aGlzLmVuY3J5cHRpb25UeXBlID0gb3RoZXJFbmNyeXB0aW9uVHlwZTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkQ29udGVudCA9IEpTT04ucGFyc2UoZGVjcnlwdGVkQ29udGVudCk7XG4gICAgY29uc3QgeyBpZCwgbWV0aG9kLCBwYXJhbXMsIHJlc3VsdCwgZXJyb3IgfSA9IHBhcnNlZENvbnRlbnQ7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgcmV0dXJuIHsgaWQsIHB1YmtleTogZXZlbnQucHVia2V5LCBtZXRob2QsIHBhcmFtcywgZXZlbnQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgaWQsIHJlc3VsdCwgZXJyb3IsIGV2ZW50IH07XG4gIH1cbiAgYXN5bmMgc2VuZFJlc3BvbnNlKGlkLCByZW1vdGVQdWJrZXksIHJlc3VsdCwga2luZCA9IDI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqLywgZXJyb3IpIHtcbiAgICBjb25zdCByZXMgPSB7IGlkLCByZXN1bHQgfTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJlcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgcmVtb3RlVXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHJlbW90ZVB1YmtleSB9KTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZCxcbiAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlcyksXG4gICAgICB0YWdzOiBbW1wicFwiLCByZW1vdGVQdWJrZXldXSxcbiAgICAgIHB1YmtleTogbG9jYWxVc2VyLnB1YmtleVxuICAgIH0pO1xuICAgIGV2ZW50LmNvbnRlbnQgPSBhd2FpdCB0aGlzLnNpZ25lci5lbmNyeXB0KHJlbW90ZVVzZXIsIGV2ZW50LmNvbnRlbnQsIHRoaXMuZW5jcnlwdGlvblR5cGUpO1xuICAgIGF3YWl0IGV2ZW50LnNpZ24odGhpcy5zaWduZXIpO1xuICAgIGF3YWl0IGV2ZW50LnB1Ymxpc2godGhpcy5yZWxheVNldCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVxdWVzdC5cbiAgICogQHBhcmFtIHJlbW90ZVB1YmtleVxuICAgKiBAcGFyYW0gbWV0aG9kXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGtpbmRcbiAgICogQHBhcmFtIGlkXG4gICAqL1xuICBhc3luYyBzZW5kUmVxdWVzdChyZW1vdGVQdWJrZXksIG1ldGhvZCwgcGFyYW1zID0gW10sIGtpbmQgPSAyNDEzMywgY2IpIHtcbiAgICBjb25zdCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KTtcbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgcmVtb3RlVXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHJlbW90ZVB1YmtleSB9KTtcbiAgICBjb25zdCByZXF1ZXN0ID0geyBpZCwgbWV0aG9kLCBwYXJhbXMgfTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKCkgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5yZXN1bHQgPT09IFwiYXV0aF91cmxcIikge1xuICAgICAgICAgIHRoaXMub25jZShgcmVzcG9uc2UtJHtpZH1gLCByZXNwb25zZUhhbmRsZXIpO1xuICAgICAgICAgIHRoaXMuZW1pdChcImF1dGhVcmxcIiwgcmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICAgICAgY2IocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNlKGByZXNwb25zZS0ke2lkfWAsIHJlc3BvbnNlSGFuZGxlcik7XG4gICAgfSk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQsXG4gICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcbiAgICAgIHRhZ3M6IFtbXCJwXCIsIHJlbW90ZVB1YmtleV1dLFxuICAgICAgcHVia2V5OiBsb2NhbFVzZXIucHVia2V5XG4gICAgfSk7XG4gICAgZXZlbnQuY29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmVuY3J5cHQocmVtb3RlVXNlciwgZXZlbnQuY29udGVudCwgdGhpcy5lbmNyeXB0aW9uVHlwZSk7XG4gICAgYXdhaXQgZXZlbnQuc2lnbih0aGlzLnNpZ25lcik7XG4gICAgYXdhaXQgZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9jb25uZWN0LnRzXG52YXIgQ29ubmVjdEV2ZW50SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtfLCB0b2tlbl0gPSBwYXJhbXM7XG4gICAgY29uc3QgZGVidWc4ID0gYmFja2VuZC5kZWJ1Zy5leHRlbmQoXCJjb25uZWN0XCIpO1xuICAgIGRlYnVnOChgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9YCk7XG4gICAgaWYgKHRva2VuICYmIGJhY2tlbmQuYXBwbHlUb2tlbikge1xuICAgICAgZGVidWc4KFwiYXBwbHlpbmcgdG9rZW5cIik7XG4gICAgICBhd2FpdCBiYWNrZW5kLmFwcGx5VG9rZW4ocmVtb3RlUHVia2V5LCB0b2tlbik7XG4gICAgfVxuICAgIGlmIChhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgICAgaWQsXG4gICAgICBwdWJrZXk6IHJlbW90ZVB1YmtleSxcbiAgICAgIG1ldGhvZDogXCJjb25uZWN0XCIsXG4gICAgICBwYXJhbXM6IHRva2VuXG4gICAgfSkpIHtcbiAgICAgIGRlYnVnOChgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IGFsbG93ZWRgKTtcbiAgICAgIHJldHVybiBcImFja1wiO1xuICAgIH1cbiAgICBkZWJ1ZzgoYGNvbm5lY3Rpb24gcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSByZWplY3RlZGApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvZ2V0LXB1YmxpYy1rZXkudHNcbnZhciBHZXRQdWJsaWNLZXlIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgX2lkLCBfcmVtb3RlUHVia2V5LCBfcGFyYW1zKSB7XG4gICAgcmV0dXJuIGJhY2tlbmQubG9jYWxVc2VyPy5wdWJrZXk7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvbmlwMDQtZGVjcnlwdC50c1xudmFyIE5pcDA0RGVjcnlwdEhhbmRsaW5nU3RyYXRlZ3kgPSBjbGFzcyB7XG4gIGFzeW5jIGhhbmRsZShiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpIHtcbiAgICBjb25zdCBbc2VuZGVyUHVia2V5LCBwYXlsb2FkXSA9IHBhcmFtcztcbiAgICBjb25zdCBzZW5kZXJVc2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IHNlbmRlclB1YmtleSB9KTtcbiAgICBjb25zdCBkZWNyeXB0ZWRQYXlsb2FkID0gYXdhaXQgZGVjcnlwdDIoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgc2VuZGVyVXNlciwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIGRlY3J5cHRlZFBheWxvYWQ7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0MihiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBzZW5kZXJVc2VyLCBwYXlsb2FkKSB7XG4gIGlmICghYXdhaXQgYmFja2VuZC5wdWJrZXlBbGxvd2VkKHtcbiAgICBpZCxcbiAgICBwdWJrZXk6IHJlbW90ZVB1YmtleSxcbiAgICBtZXRob2Q6IFwibmlwMDRfZGVjcnlwdFwiLFxuICAgIHBhcmFtczogcGF5bG9hZFxuICB9KSkge1xuICAgIGJhY2tlbmQuZGVidWcoYGRlY3J5cHQgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSByZWplY3RlZGApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IGJhY2tlbmQuc2lnbmVyLmRlY3J5cHQoc2VuZGVyVXNlciwgcGF5bG9hZCwgXCJuaXAwNFwiKTtcbn1cblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9uaXAwNC1lbmNyeXB0LnRzXG52YXIgTmlwMDRFbmNyeXB0SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtyZWNpcGllbnRQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlY2lwaWVudFVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogcmVjaXBpZW50UHVia2V5IH0pO1xuICAgIGNvbnN0IGVuY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBlbmNyeXB0MihiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCByZWNpcGllbnRVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZW5jcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQyKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHJlY2lwaWVudFVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXAwNF9lbmNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZW5jcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZW5jcnlwdChyZWNpcGllbnRVc2VyLCBwYXlsb2FkLCBcIm5pcDA0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL25pcDQ0LWRlY3J5cHQudHNcbnZhciBOaXAwNERlY3J5cHRIYW5kbGluZ1N0cmF0ZWd5MiA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtzZW5kZXJQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHNlbmRlclVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogc2VuZGVyUHVia2V5IH0pO1xuICAgIGNvbnN0IGRlY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBkZWNyeXB0MyhiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBzZW5kZXJVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZGVjcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQzKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHNlbmRlclVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXA0NF9kZWNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZGVjcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZGVjcnlwdChzZW5kZXJVc2VyLCBwYXlsb2FkLCBcIm5pcDQ0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL25pcDQ0LWVuY3J5cHQudHNcbnZhciBOaXAwNEVuY3J5cHRIYW5kbGluZ1N0cmF0ZWd5MiA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtyZWNpcGllbnRQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlY2lwaWVudFVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogcmVjaXBpZW50UHVia2V5IH0pO1xuICAgIGNvbnN0IGVuY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBlbmNyeXB0MyhiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCByZWNpcGllbnRVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZW5jcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQzKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHJlY2lwaWVudFVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXA0NF9lbmNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZW5jcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZW5jcnlwdChyZWNpcGllbnRVc2VyLCBwYXlsb2FkLCBcIm5pcDQ0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL3BpbmcudHNcbnZhciBQaW5nRXZlbnRIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgX3BhcmFtcykge1xuICAgIGNvbnN0IGRlYnVnOCA9IGJhY2tlbmQuZGVidWcuZXh0ZW5kKFwicGluZ1wiKTtcbiAgICBkZWJ1ZzgoYHBpbmcgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fWApO1xuICAgIGlmIChhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoeyBpZCwgcHVia2V5OiByZW1vdGVQdWJrZXksIG1ldGhvZDogXCJwaW5nXCIgfSkpIHtcbiAgICAgIGRlYnVnOChgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IGFsbG93ZWRgKTtcbiAgICAgIHJldHVybiBcInBvbmdcIjtcbiAgICB9XG4gICAgZGVidWc4KGBjb25uZWN0aW9uIHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL3NpZ24tZXZlbnQudHNcbnZhciBTaWduRXZlbnRIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gICAgY29uc3QgZXZlbnQgPSBhd2FpdCBzaWduRXZlbnQoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKTtcbiAgICBpZiAoIWV2ZW50KSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhd2FpdCBldmVudC50b05vc3RyRXZlbnQoKSk7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBzaWduRXZlbnQoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gIGNvbnN0IFtldmVudFN0cmluZ10gPSBwYXJhbXM7XG4gIGJhY2tlbmQuZGVidWcoYHNpZ24gZXZlbnQgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fWApO1xuICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudChiYWNrZW5kLm5kaywgSlNPTi5wYXJzZShldmVudFN0cmluZykpO1xuICBiYWNrZW5kLmRlYnVnKFwiZXZlbnQgdG8gc2lnblwiLCBldmVudC5yYXdFdmVudCgpKTtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJzaWduX2V2ZW50XCIsXG4gICAgcGFyYW1zOiBldmVudFxuICB9KSkge1xuICAgIGJhY2tlbmQuZGVidWcoYHNpZ24gZXZlbnQgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSByZWplY3RlZGApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgYmFja2VuZC5kZWJ1Zyhgc2lnbiBldmVudCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IGFsbG93ZWRgKTtcbiAgYXdhaXQgZXZlbnQuc2lnbihiYWNrZW5kLnNpZ25lcik7XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9pbmRleC50c1xudmFyIE5ES05pcDQ2QmFja2VuZCA9IGNsYXNzIHtcbiAgbmRrO1xuICBzaWduZXI7XG4gIGxvY2FsVXNlcjtcbiAgZGVidWc7XG4gIHJwYztcbiAgcGVybWl0Q2FsbGJhY2s7XG4gIHJlbGF5VXJscztcbiAgLyoqXG4gICAqIEBwYXJhbSBuZGsgVGhlIE5ESyBpbnN0YW5jZSB0byB1c2VcbiAgICogQHBhcmFtIHByaXZhdGVLZXlPclNpZ25lciBUaGUgcHJpdmF0ZSBrZXkgb3Igc2lnbmVyIG9mIHRoZSBucHViIHRoYXQgd2FudHMgdG8gYmUgcHVibGlzaGVkIGFzXG4gICAqIEBwYXJhbSBwZXJtaXRDYWxsYmFjayBDYWxsYmFjayBleGVjdXRlZCB3aGVuIHBlcm1pc3Npb24gaXMgcmVxdWVzdGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuZGssIHByaXZhdGVLZXlPclNpZ25lciwgcGVybWl0Q2FsbGJhY2ssIHJlbGF5VXJscykge1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIGlmIChwcml2YXRlS2V5T3JTaWduZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICB0aGlzLnNpZ25lciA9IG5ldyBOREtQcml2YXRlS2V5U2lnbmVyKHByaXZhdGVLZXlPclNpZ25lcik7XG4gICAgfSBlbHNlIGlmIChwcml2YXRlS2V5T3JTaWduZXIgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIHRoaXMuc2lnbmVyID0gbmV3IE5ES1ByaXZhdGVLZXlTaWduZXIoaGV4VG9CeXRlczIocHJpdmF0ZUtleU9yU2lnbmVyKSk7XG4gICAgfSBlbHNlIGlmIChwcml2YXRlS2V5T3JTaWduZXIgaW5zdGFuY2VvZiBOREtQcml2YXRlS2V5U2lnbmVyKSB7XG4gICAgICB0aGlzLnNpZ25lciA9IHByaXZhdGVLZXlPclNpZ25lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduZXJcIik7XG4gICAgfVxuICAgIHRoaXMuZGVidWcgPSBuZGsuZGVidWcuZXh0ZW5kKFwibmlwNDY6YmFja2VuZFwiKTtcbiAgICB0aGlzLnJlbGF5VXJscyA9IHJlbGF5VXJscyA/PyBBcnJheS5mcm9tKG5kay5wb29sLnJlbGF5cy5rZXlzKCkpO1xuICAgIHRoaXMucnBjID0gbmV3IE5ES05vc3RyUnBjKG5kaywgdGhpcy5zaWduZXIsIHRoaXMuZGVidWcsIHRoaXMucmVsYXlVcmxzKTtcbiAgICB0aGlzLnBlcm1pdENhbGxiYWNrID0gcGVybWl0Q2FsbGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHN0YXJ0cyB0aGUgYmFja2VuZCwgd2hpY2ggd2lsbCBzdGFydCBsaXN0ZW5pbmcgZm9yIGluY29taW5nXG4gICAqIHJlcXVlc3RzLlxuICAgKi9cbiAgYXN5bmMgc3RhcnQoKSB7XG4gICAgdGhpcy5sb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3Qgc3ViID0gdGhpcy5uZGsuc3Vic2NyaWJlKFxuICAgICAge1xuICAgICAgICBraW5kczogWzI0MTMzXSxcbiAgICAgICAgXCIjcFwiOiBbdGhpcy5sb2NhbFVzZXIucHVia2V5XVxuICAgICAgfSxcbiAgICAgIHsgY2xvc2VPbkVvc2U6IGZhbHNlIH1cbiAgICApO1xuICAgIHN1Yi5vbihcImV2ZW50XCIsIChlKSA9PiB0aGlzLmhhbmRsZUluY29taW5nRXZlbnQoZSkpO1xuICB9XG4gIGhhbmRsZXJzID0ge1xuICAgIGNvbm5lY3Q6IG5ldyBDb25uZWN0RXZlbnRIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgc2lnbl9ldmVudDogbmV3IFNpZ25FdmVudEhhbmRsaW5nU3RyYXRlZ3koKSxcbiAgICBuaXAwNF9lbmNyeXB0OiBuZXcgTmlwMDRFbmNyeXB0SGFuZGxpbmdTdHJhdGVneSgpLFxuICAgIG5pcDA0X2RlY3J5cHQ6IG5ldyBOaXAwNERlY3J5cHRIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgbmlwNDRfZW5jcnlwdDogbmV3IE5pcDA0RW5jcnlwdEhhbmRsaW5nU3RyYXRlZ3kyKCksXG4gICAgbmlwNDRfZGVjcnlwdDogbmV3IE5pcDA0RGVjcnlwdEhhbmRsaW5nU3RyYXRlZ3kyKCksXG4gICAgZ2V0X3B1YmxpY19rZXk6IG5ldyBHZXRQdWJsaWNLZXlIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgcGluZzogbmV3IFBpbmdFdmVudEhhbmRsaW5nU3RyYXRlZ3koKVxuICB9O1xuICAvKipcbiAgICogRW5hYmxlcyB0aGUgdXNlciB0byBzZXQgYSBjdXN0b20gc3RyYXRlZ3kgZm9yIGhhbmRsaW5nIGluY29taW5nIGV2ZW50cy5cbiAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBtZXRob2QgdG8gc2V0IHRoZSBzdHJhdGVneSBmb3JcbiAgICogQHBhcmFtIHN0cmF0ZWd5IC0gVGhlIHN0cmF0ZWd5IHRvIHNldFxuICAgKi9cbiAgc2V0U3RyYXRlZ3kobWV0aG9kLCBzdHJhdGVneSkge1xuICAgIHRoaXMuaGFuZGxlcnNbbWV0aG9kXSA9IHN0cmF0ZWd5O1xuICB9XG4gIC8qKlxuICAgKiBPdmVybG9hZCB0aGlzIG1ldGhvZCB0byBhcHBseSB0b2tlbnMsIHdoaWNoIGNhblxuICAgKiB3cmFwIHBlcm1pc3Npb24gc2V0cyB0byBiZSBhcHBsaWVkIHRvIGEgcHVia2V5LlxuICAgKiBAcGFyYW0gcHVia2V5IHB1YmxpYyBrZXkgdG8gYXBwbHkgdG9rZW4gdG9cbiAgICogQHBhcmFtIHRva2VuIHRva2VuIHRvIGFwcGx5XG4gICAqL1xuICBhc3luYyBhcHBseVRva2VuKF9wdWJrZXksIF90b2tlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvbm5lY3Rpb24gdG9rZW4gbm90IHN1cHBvcnRlZFwiKTtcbiAgfVxuICBhc3luYyBoYW5kbGVJbmNvbWluZ0V2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgeyBpZCwgbWV0aG9kLCBwYXJhbXMgfSA9IGF3YWl0IHRoaXMucnBjLnBhcnNlRXZlbnQoZXZlbnQpO1xuICAgIGNvbnN0IHJlbW90ZVB1YmtleSA9IGV2ZW50LnB1YmtleTtcbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgdGhpcy5kZWJ1ZyhcImluY29taW5nIGV2ZW50XCIsIHsgaWQsIG1ldGhvZCwgcGFyYW1zIH0pO1xuICAgIGlmICghZXZlbnQudmVyaWZ5U2lnbmF0dXJlKGZhbHNlKSkge1xuICAgICAgdGhpcy5kZWJ1ZyhcImludmFsaWQgc2lnbmF0dXJlXCIsIGV2ZW50LnJhd0V2ZW50KCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdHJhdGVneSA9IHRoaXMuaGFuZGxlcnNbbWV0aG9kXTtcbiAgICBpZiAoc3RyYXRlZ3kpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgc3RyYXRlZ3kuaGFuZGxlKHRoaXMsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJlcnJvciBoYW5kbGluZyBldmVudFwiLCBlLCB7IGlkLCBtZXRob2QsIHBhcmFtcyB9KTtcbiAgICAgICAgdGhpcy5ycGMuc2VuZFJlc3BvbnNlKGlkLCByZW1vdGVQdWJrZXksIFwiZXJyb3JcIiwgdm9pZCAwLCBlLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlYnVnKFwidW5zdXBwb3J0ZWQgbWV0aG9kXCIsIHsgbWV0aG9kLCBwYXJhbXMgfSk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgdGhpcy5kZWJ1Zyhgc2VuZGluZyByZXNwb25zZSB0byAke3JlbW90ZVB1YmtleX1gLCByZXNwb25zZSk7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVzcG9uc2UoaWQsIHJlbW90ZVB1YmtleSwgcmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVzcG9uc2UoaWQsIHJlbW90ZVB1YmtleSwgXCJlcnJvclwiLCB2b2lkIDAsIFwiTm90IGF1dGhvcml6ZWRcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGVuIGJ5IHRoZSB1c2VyIHRvIGFsbG93IG9yIHJlamVjdCBpbmNvbWluZ1xuICAgKiBjb25uZWN0aW9ucy5cbiAgICovXG4gIGFzeW5jIHB1YmtleUFsbG93ZWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMucGVybWl0Q2FsbGJhY2socGFyYW1zKTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvaW5kZXgudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI2IH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy9zaWduZXJzL2Rlc2VyaWFsaXphdGlvbi50c1xudmFyIHNpZ25lclJlZ2lzdHJ5ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnNpZ25lclJlZ2lzdHJ5LnNldChcInByaXZhdGUta2V5XCIsIE5ES1ByaXZhdGVLZXlTaWduZXIpO1xuc2lnbmVyUmVnaXN0cnkuc2V0KFwibmlwMDdcIiwgTkRLTmlwMDdTaWduZXIpO1xuc2lnbmVyUmVnaXN0cnkuc2V0KFwibmlwNDZcIiwgTkRLTmlwNDZTaWduZXIpO1xuYXN5bmMgZnVuY3Rpb24gbmRrU2lnbmVyRnJvbVBheWxvYWQocGF5bG9hZFN0cmluZywgbmRrKSB7XG4gIGxldCBwYXJzZWQ7XG4gIHRyeSB7XG4gICAgcGFyc2VkID0gSlNPTi5wYXJzZShwYXlsb2FkU3RyaW5nKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHNpZ25lciBwYXlsb2FkOiAke2UgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6IFN0cmluZyhlKX1gKTtcbiAgfVxuICBjb25zdCBTaWduZXJDbGFzcyA9IHNpZ25lclJlZ2lzdHJ5LmdldChwYXJzZWQudHlwZSk7XG4gIGlmICghU2lnbmVyQ2xhc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc2lnbmVyIHR5cGU6ICR7cGFyc2VkLnR5cGV9YCk7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgU2lnbmVyQ2xhc3MuZnJvbVBheWxvYWQocGF5bG9hZFN0cmluZywgbmRrKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnN0IGVycm9yTXNnID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpO1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlc2VyaWFsaXplIHNpZ25lciB0eXBlICR7cGFyc2VkLnR5cGV9OiAke2Vycm9yTXNnfWApO1xuICB9XG59XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2luZGV4LnRzXG52YXIgTkRLTmlwNDZTaWduZXIgPSBjbGFzcyBfTkRLTmlwNDZTaWduZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXI2IHtcbiAgbmRrO1xuICBfdXNlcjtcbiAgLyoqXG4gICAqIFRoZSBwdWJrZXkgb2YgdGhlIGJ1bmtlciB0aGF0IHdpbGwgYmUgcHJvdmlkaW5nIHNpZ25hdHVyZXNcbiAgICovXG4gIGJ1bmtlclB1YmtleTtcbiAgLyoqXG4gICAqIFRoZSBwdWJrZXkgb2YgdGhlIHVzZXIgdGhhdCBldmVudHMgd2lsbCBiZSBwdWJsaXNoZWQgYXNcbiAgICovXG4gIHVzZXJQdWJrZXk7XG4gIGdldCBwdWJrZXkoKSB7XG4gICAgaWYgKCF0aGlzLnVzZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIk5vdCByZWFkeVwiKTtcbiAgICByZXR1cm4gdGhpcy51c2VyUHVia2V5O1xuICB9XG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBzZWNyZXQgdmFsdWUgcHJvdmlkZWQgdG8gY29ubmVjdCB0byB0aGUgYnVua2VyXG4gICAqL1xuICBzZWNyZXQ7XG4gIGxvY2FsU2lnbmVyO1xuICBuaXAwNTtcbiAgcnBjO1xuICBkZWJ1ZztcbiAgcmVsYXlVcmxzO1xuICBzdWJzY3JpcHRpb247XG4gIC8qKlxuICAgKiBAcGFyYW0gbmRrIC0gVGhlIE5ESyBpbnN0YW5jZSB0byB1c2VcbiAgICogQHBhcmFtIHVzZXJPckNvbm5lY3Rpb25Ub2tlbiAtIFRoZSBwdWJsaWMga2V5LCBvciBhIGNvbm5lY3Rpb24gdG9rZW4sIG9mIHRoZSBucHViIHRoYXQgd2FudHMgdG8gYmUgcHVibGlzaGVkIGFzXG4gICAqIEBwYXJhbSBsb2NhbFNpZ25lciAtIFRoZSBzaWduZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVxdWVzdCBldmVudHMgdG8gYmUgc2lnbmVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuZGssIHVzZXJPckNvbm5lY3Rpb25Ub2tlbiwgbG9jYWxTaWduZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuZGVidWcgPSBuZGsuZGVidWcuZXh0ZW5kKFwibmlwNDY6c2lnbmVyXCIpO1xuICAgIGlmICh1c2VyT3JDb25uZWN0aW9uVG9rZW4uc3RhcnRzV2l0aChcImJ1bmtlcjovL1wiKSkge1xuICAgICAgdGhpcy5jb25uZWN0aW9uVG9rZW5Jbml0KHVzZXJPckNvbm5lY3Rpb25Ub2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmlwMDVJbml0KHVzZXJPckNvbm5lY3Rpb25Ub2tlbik7XG4gICAgfVxuICAgIGlmICghbG9jYWxTaWduZXIpIHtcbiAgICAgIHRoaXMubG9jYWxTaWduZXIgPSBOREtQcml2YXRlS2V5U2lnbmVyLmdlbmVyYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9jYWxTaWduZXIgPSBsb2NhbFNpZ25lcjtcbiAgICB9XG4gICAgdGhpcy5ycGMgPSBuZXcgTkRLTm9zdHJScGModGhpcy5uZGssIHRoaXMubG9jYWxTaWduZXIsIHRoaXMuZGVidWcsIHRoaXMucmVsYXlVcmxzKTtcbiAgfVxuICBjb25uZWN0aW9uVG9rZW5Jbml0KGNvbm5lY3Rpb25Ub2tlbikge1xuICAgIGNvbnN0IGJ1bmtlclVybCA9IG5ldyBVUkwoY29ubmVjdGlvblRva2VuKTtcbiAgICBjb25zdCBidW5rZXJQdWJrZXkgPSBidW5rZXJVcmwuaG9zdG5hbWUgfHwgYnVua2VyVXJsLnBhdGhuYW1lLnJlcGxhY2UoL15cXC9cXC8vLCBcIlwiKTtcbiAgICBjb25zdCB1c2VyUHVia2V5ID0gYnVua2VyVXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJwdWJrZXlcIik7XG4gICAgY29uc3QgcmVsYXlVcmxzID0gYnVua2VyVXJsLnNlYXJjaFBhcmFtcy5nZXRBbGwoXCJyZWxheVwiKTtcbiAgICBjb25zdCBzZWNyZXQgPSBidW5rZXJVcmwuc2VhcmNoUGFyYW1zLmdldChcInNlY3JldFwiKTtcbiAgICB0aGlzLmJ1bmtlclB1YmtleSA9IGJ1bmtlclB1YmtleTtcbiAgICB0aGlzLnVzZXJQdWJrZXkgPSB1c2VyUHVia2V5O1xuICAgIHRoaXMucmVsYXlVcmxzID0gcmVsYXlVcmxzO1xuICAgIHRoaXMuc2VjcmV0ID0gc2VjcmV0O1xuICB9XG4gIG5pcDA1SW5pdChuaXAwNSkge1xuICAgIHRoaXMubmlwMDUgPSBuaXAwNTtcbiAgfVxuICAvKipcbiAgICogV2Ugc3RhcnQgbGlzdGVuaW5nIGZvciBldmVudHMgZnJvbSB0aGUgYnVua2VyXG4gICAqL1xuICBhc3luYyBzdGFydExpc3RlbmluZygpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHJldHVybjtcbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLmxvY2FsU2lnbmVyLnVzZXIoKTtcbiAgICBpZiAoIWxvY2FsVXNlcikgdGhyb3cgbmV3IEVycm9yKFwiTG9jYWwgc2lnbmVyIG5vdCByZWFkeVwiKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGF3YWl0IHRoaXMucnBjLnN1YnNjcmliZSh7XG4gICAgICBraW5kczogWzI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqL10sXG4gICAgICBcIiNwXCI6IFtsb2NhbFVzZXIucHVia2V5XVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIgdGhhdCBpcyBiZWluZyBwdWJsaXNoZWQgYXNcbiAgICovXG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgaWYgKHRoaXMuX3VzZXIpIHJldHVybiB0aGlzLl91c2VyO1xuICAgIHJldHVybiB0aGlzLmJsb2NrVW50aWxSZWFkeSgpO1xuICB9XG4gIGdldCB1c2VyU3luYygpIHtcbiAgICBpZiAoIXRoaXMuX3VzZXIpIHRocm93IG5ldyBFcnJvcihcIlJlbW90ZSB1c2VyIG5vdCByZWFkeSBzeW5jaHJvbm91c2x5XCIpO1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIGFzeW5jIGJsb2NrVW50aWxSZWFkeSgpIHtcbiAgICBpZiAodGhpcy5uaXAwNSAmJiAhdGhpcy51c2VyUHVia2V5KSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgTkRLVXNlci5mcm9tTmlwMDUodGhpcy5uaXAwNSwgdGhpcy5uZGspO1xuICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgdGhpcy5fdXNlciA9IHVzZXI7XG4gICAgICAgIHRoaXMudXNlclB1YmtleSA9IHVzZXIucHVia2V5O1xuICAgICAgICB0aGlzLnJlbGF5VXJscyA9IHVzZXIubmlwNDZVcmxzO1xuICAgICAgICB0aGlzLnJwYyA9IG5ldyBOREtOb3N0clJwYyh0aGlzLm5kaywgdGhpcy5sb2NhbFNpZ25lciwgdGhpcy5kZWJ1ZywgdGhpcy5yZWxheVVybHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuYnVua2VyUHVia2V5ICYmIHRoaXMudXNlclB1YmtleSkge1xuICAgICAgdGhpcy5idW5rZXJQdWJrZXkgPSB0aGlzLnVzZXJQdWJrZXk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5zdGFydExpc3RlbmluZygpO1xuICAgIHRoaXMucnBjLm9uKFwiYXV0aFVybFwiLCAoLi4ucHJvcHMpID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImF1dGhVcmxcIiwgLi4ucHJvcHMpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjb25uZWN0UGFyYW1zID0gW3RoaXMudXNlclB1YmtleSA/PyBcIlwiXTtcbiAgICAgIGlmICh0aGlzLnNlY3JldCkgY29ubmVjdFBhcmFtcy5wdXNoKHRoaXMuc2VjcmV0KTtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KHRoaXMuYnVua2VyUHVia2V5LCBcImNvbm5lY3RcIiwgY29ubmVjdFBhcmFtcywgMjQxMzMsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2UucmVzdWx0ID09PSBcImFja1wiKSB7XG4gICAgICAgICAgdGhpcy5nZXRQdWJsaWNLZXkoKS50aGVuKChwdWJrZXkpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXNlclB1YmtleSA9IHB1YmtleTtcbiAgICAgICAgICAgIHRoaXMuX3VzZXIgPSB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5IH0pO1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLl91c2VyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRQdWJsaWNLZXkoKSB7XG4gICAgaWYgKHRoaXMudXNlclB1YmtleSkgcmV0dXJuIHRoaXMudXNlclB1YmtleTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIF9yZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KHRoaXMuYnVua2VyUHVia2V5LCBcImdldF9wdWJsaWNfa2V5XCIsIFtdLCAyNDEzMywgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIHJlc29sdmUocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGVuY3J5cHRpb25FbmFibGVkKHNjaGVtZSkge1xuICAgIGlmIChzY2hlbWUpIHJldHVybiBbc2NoZW1lXTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtcIm5pcDA0XCIsIFwibmlwNDRcIl0pO1xuICB9XG4gIGFzeW5jIGVuY3J5cHQocmVjaXBpZW50LCB2YWx1ZSwgc2NoZW1lID0gXCJuaXAwNFwiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvbihyZWNpcGllbnQsIHZhbHVlLCBzY2hlbWUsIFwiZW5jcnlwdFwiKTtcbiAgfVxuICBhc3luYyBkZWNyeXB0KHNlbmRlciwgdmFsdWUsIHNjaGVtZSA9IFwibmlwMDRcIikge1xuICAgIHJldHVybiB0aGlzLmVuY3J5cHRpb24oc2VuZGVyLCB2YWx1ZSwgc2NoZW1lLCBcImRlY3J5cHRcIik7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbihwZWVyLCB2YWx1ZSwgc2NoZW1lLCBtZXRob2QpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYnVua2VyUHVia2V5LFxuICAgICAgICBgJHtzY2hlbWV9XyR7bWV0aG9kfWAsXG4gICAgICAgIFtwZWVyLnB1YmtleSwgdmFsdWVdLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBhc3luYyBzaWduKGV2ZW50KSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KFxuICAgICAgICB0aGlzLmJ1bmtlclB1YmtleSxcbiAgICAgICAgXCJzaWduX2V2ZW50XCIsXG4gICAgICAgIFtKU09OLnN0cmluZ2lmeShldmVudCldLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgIHJlc29sdmUoanNvbi5zaWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIGNyZWF0aW5nIGEgbmV3IGFjY291bnQgb24gdGhlIHJlbW90ZSBzZXJ2ZXIuXG4gICAqIEBwYXJhbSB1c2VybmFtZSBEZXNpcmVkIHVzZXJuYW1lIGZvciB0aGUgTklQLTA1XG4gICAqIEBwYXJhbSBkb21haW4gRGVzaXJlZCBkb21haW4gZm9yIHRoZSBOSVAtMDVcbiAgICogQHBhcmFtIGVtYWlsIEVtYWlsIGFkZHJlc3MgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBhY2NvdW50IC0tIFJlbW90ZSBzZXJ2ZXJzIG1heSB1c2UgdGhpcyBmb3IgcmVjb3ZlcnlcbiAgICogQHJldHVybnMgVGhlIHB1YmxpYyBrZXkgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgYWNjb3VudFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQWNjb3VudCh1c2VybmFtZSwgZG9tYWluLCBlbWFpbCkge1xuICAgIGF3YWl0IHRoaXMuc3RhcnRMaXN0ZW5pbmcoKTtcbiAgICBjb25zdCByZXEgPSBbXTtcbiAgICBpZiAodXNlcm5hbWUpIHJlcS5wdXNoKHVzZXJuYW1lKTtcbiAgICBpZiAoZG9tYWluKSByZXEucHVzaChkb21haW4pO1xuICAgIGlmIChlbWFpbCkgcmVxLnB1c2goZW1haWwpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMuYnVua2VyUHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJCdW5rZXIgcHVia2V5IG5vdCBzZXRcIik7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVxdWVzdChcbiAgICAgICAgdGhpcy5idW5rZXJQdWJrZXksXG4gICAgICAgIFwiY3JlYXRlX2FjY291bnRcIixcbiAgICAgICAgcmVxLFxuICAgICAgICAyNDEzMyAvKiBOb3N0ckNvbm5lY3QgKi8sXG4gICAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGlmICghcmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YmtleSA9IHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgIHJlc29sdmUocHVia2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgdGhlIHNpZ25lcidzIGNvbm5lY3Rpb24gZGV0YWlscyBhbmQgbG9jYWwgc2lnbmVyIHN0YXRlLlxuICAgKiBAcmV0dXJucyBBIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHR5cGUsIGNvbm5lY3Rpb24gaW5mbywgYW5kIGxvY2FsIHNpZ25lciBwYXlsb2FkLlxuICAgKi9cbiAgdG9QYXlsb2FkKCkge1xuICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkgfHwgIXRoaXMudXNlclB1YmtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTklQLTQ2IHNpZ25lciBpcyBub3QgZnVsbHkgaW5pdGlhbGl6ZWQgZm9yIHNlcmlhbGl6YXRpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICB0eXBlOiBcIm5pcDQ2XCIsXG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGJ1bmtlclB1YmtleTogdGhpcy5idW5rZXJQdWJrZXksXG4gICAgICAgIHVzZXJQdWJrZXk6IHRoaXMudXNlclB1YmtleSxcbiAgICAgICAgcmVsYXlVcmxzOiB0aGlzLnJlbGF5VXJscyxcbiAgICAgICAgc2VjcmV0OiB0aGlzLnNlY3JldCxcbiAgICAgICAgbG9jYWxTaWduZXJQYXlsb2FkOiB0aGlzLmxvY2FsU2lnbmVyLnRvUGF5bG9hZCgpLFxuICAgICAgICAvLyBTdG9yZSBuaXAwNSBpZiBpdCB3YXMgdXNlZCBmb3IgaW5pdGlhbGl6YXRpb24sIG90aGVyd2lzZSBudWxsXG4gICAgICAgIG5pcDA1OiB0aGlzLm5pcDA1IHx8IG51bGxcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemVzIHRoZSBzaWduZXIgZnJvbSBhIHBheWxvYWQgc3RyaW5nLlxuICAgKiBAcGFyYW0gcGF5bG9hZFN0cmluZyBUaGUgSlNPTiBzdHJpbmcgb2J0YWluZWQgZnJvbSB0b1BheWxvYWQoKS5cbiAgICogQHBhcmFtIG5kayBUaGUgTkRLIGluc3RhbmNlLCByZXF1aXJlZCBmb3IgTklQLTQ2LlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBOREtOaXA0NlNpZ25lci5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tUGF5bG9hZChwYXlsb2FkU3RyaW5nLCBuZGspIHtcbiAgICBpZiAoIW5kaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIGlzIHJlcXVpcmVkIHRvIGRlc2VyaWFsaXplIE5JUC00NiBzaWduZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UocGF5bG9hZFN0cmluZyk7XG4gICAgaWYgKHBhcnNlZC50eXBlICE9PSBcIm5pcDQ2XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXlsb2FkIHR5cGU6IGV4cGVjdGVkICduaXA0NicsIGdvdCAke3BhcnNlZC50eXBlfWApO1xuICAgIH1cbiAgICBjb25zdCBwYXlsb2FkID0gcGFyc2VkLnBheWxvYWQ7XG4gICAgaWYgKCFwYXlsb2FkIHx8IHR5cGVvZiBwYXlsb2FkICE9PSBcIm9iamVjdFwiIHx8ICFwYXlsb2FkLmxvY2FsU2lnbmVyUGF5bG9hZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXlsb2FkIGNvbnRlbnQgZm9yIG5pcDQ2IHNpZ25lclwiKTtcbiAgICB9XG4gICAgY29uc3QgbG9jYWxTaWduZXIgPSBhd2FpdCBuZGtTaWduZXJGcm9tUGF5bG9hZChwYXlsb2FkLmxvY2FsU2lnbmVyUGF5bG9hZCwgbmRrKTtcbiAgICBpZiAoIWxvY2FsU2lnbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVzZXJpYWxpemUgbG9jYWwgc2lnbmVyIGZvciBOSVAtNDZcIik7XG4gICAgfVxuICAgIGxldCBzaWduZXI7XG4gICAgaWYgKHBheWxvYWQubmlwMDUpIHtcbiAgICAgIHNpZ25lciA9IG5ldyBfTkRLTmlwNDZTaWduZXIobmRrLCBwYXlsb2FkLm5pcDA1LCBsb2NhbFNpZ25lcik7XG4gICAgICBzaWduZXIudXNlclB1YmtleSA9IHBheWxvYWQudXNlclB1YmtleTtcbiAgICAgIHNpZ25lci5idW5rZXJQdWJrZXkgPSBwYXlsb2FkLmJ1bmtlclB1YmtleTtcbiAgICAgIHNpZ25lci5yZWxheVVybHMgPSBwYXlsb2FkLnJlbGF5VXJscztcbiAgICAgIHNpZ25lci5zZWNyZXQgPSBwYXlsb2FkLnNlY3JldDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2lnbmVyID0gbmV3IF9OREtOaXA0NlNpZ25lcihuZGssIHBheWxvYWQudXNlclB1YmtleSwgbG9jYWxTaWduZXIpO1xuICAgICAgc2lnbmVyLmJ1bmtlclB1YmtleSA9IHBheWxvYWQuYnVua2VyUHVia2V5O1xuICAgICAgc2lnbmVyLnJlbGF5VXJscyA9IHBheWxvYWQucmVsYXlVcmxzO1xuICAgICAgc2lnbmVyLnNlY3JldCA9IHBheWxvYWQuc2VjcmV0O1xuICAgIH1cbiAgICByZXR1cm4gc2lnbmVyO1xuICB9XG59O1xuXG4vLyBzcmMvZHZtL3NjaGVkdWxlLnRzXG5mdW5jdGlvbiBhZGRSZWxheXMoZXZlbnQsIHJlbGF5cykge1xuICBjb25zdCB0YWdzID0gW107XG4gIGlmICghcmVsYXlzIHx8IHJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zdCBwb29sUmVsYXlzID0gZXZlbnQubmRrPy5wb29sLnJlbGF5cztcbiAgICByZWxheXMgPSBwb29sUmVsYXlzID8gT2JqZWN0LmtleXMocG9vbFJlbGF5cykgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHJlbGF5cyAmJiByZWxheXMubGVuZ3RoID4gMCkgdGFncy5wdXNoKFtcInJlbGF5c1wiLCAuLi5yZWxheXNdKTtcbiAgcmV0dXJuIHRhZ3M7XG59XG5hc3luYyBmdW5jdGlvbiBkdm1TY2hlZHVsZShldmVudHMsIGR2bSwgcmVsYXlzLCBlbmNyeXB0ZWQgPSB0cnVlLCB3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV2ZW50cykpIHtcbiAgICBldmVudHMgPSBbZXZlbnRzXTtcbiAgfVxuICBjb25zdCBuZGsgPSBldmVudHNbMF0ubmRrO1xuICBpZiAoIW5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIG5vdCBzZXRcIik7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgaWYgKCFldmVudC5zaWcpIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IG5vdCBzaWduZWRcIik7XG4gICAgaWYgKCFldmVudC5jcmVhdGVkX2F0KSB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBoYXMgbm8gZGF0ZVwiKTtcbiAgICBpZiAoIWR2bSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gRFZNIHNwZWNpZmllZFwiKTtcbiAgICBpZiAoZXZlbnQuY3JlYXRlZF9hdCA8PSBEYXRlLm5vdygpIC8gMWUzKSB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBuZWVkcyB0byBiZSBpbiB0aGUgZnV0dXJlXCIpO1xuICB9XG4gIGNvbnN0IHNjaGVkdWxlRXZlbnQgPSBuZXcgTkRLRFZNUmVxdWVzdChuZGssIHtcbiAgICBraW5kOiA1OTA1IC8qIERWTUV2ZW50U2NoZWR1bGUgKi9cbiAgfSk7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgc2NoZWR1bGVFdmVudC5hZGRJbnB1dChKU09OLnN0cmluZ2lmeShldmVudC5yYXdFdmVudCgpKSwgXCJ0ZXh0XCIpO1xuICB9XG4gIHNjaGVkdWxlRXZlbnQudGFncy5wdXNoKC4uLmFkZFJlbGF5cyhldmVudHNbMF0sIHJlbGF5cykpO1xuICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgYXdhaXQgc2NoZWR1bGVFdmVudC5lbmNyeXB0aW9uKGR2bSk7XG4gIH0gZWxzZSB7XG4gICAgc2NoZWR1bGVFdmVudC5kdm0gPSBkdm07XG4gIH1cbiAgYXdhaXQgc2NoZWR1bGVFdmVudC5zaWduKCk7XG4gIGxldCByZXM7XG4gIGlmICh3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpIHtcbiAgICByZXMgPSBuZGsuc3Vic2NyaWJlKFxuICAgICAge1xuICAgICAgICBraW5kczogWzU5MDUgLyogRFZNRXZlbnRTY2hlZHVsZSAqLyArIDFlMywgN2UzIC8qIERWTUpvYkZlZWRiYWNrICovXSxcbiAgICAgICAgLi4uc2NoZWR1bGVFdmVudC5maWx0ZXIoKVxuICAgICAgfSxcbiAgICAgIHsgZ3JvdXBhYmxlOiBmYWxzZSwgY2xvc2VPbkVvc2U6IGZhbHNlIH1cbiAgICApO1xuICB9XG4gIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlamVjdCkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVzPy5zdG9wKCk7XG4gICAgICByZWplY3QoXCJUaW1lb3V0IHdhaXRpbmcgZm9yIGFuIGFuc3dlciBmcm9tIHRoZSBEVk1cIik7XG4gICAgfSwgd2FpdEZvckNvbmZpcm1hdGlvbkZvck1zKTtcbiAgfSk7XG4gIGNvbnN0IHNjaGVkdWxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAod2FpdEZvckNvbmZpcm1hdGlvbkZvck1zKSB7XG4gICAgICByZXM/Lm9uKFwiZXZlbnRcIiwgYXN5bmMgKGUpID0+IHtcbiAgICAgICAgcmVzPy5zdG9wKCk7XG4gICAgICAgIGlmIChlLmtpbmQgPT09IDdlMyAvKiBEVk1Kb2JGZWVkYmFjayAqLykge1xuICAgICAgICAgIGNvbnN0IGZlZWRiYWNrID0gYXdhaXQgTkRLRFZNSm9iRmVlZGJhY2suZnJvbShlKTtcbiAgICAgICAgICBpZiAoZmVlZGJhY2suc3RhdHVzID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c1RhZyA9IGZlZWRiYWNrLmdldE1hdGNoaW5nVGFncyhcInN0YXR1c1wiKTtcbiAgICAgICAgICAgIHJlamVjdChzdGF0dXNUYWc/LlsyXSA/PyBmZWVkYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoZmVlZGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNjaGVkdWxlRXZlbnQucHVibGlzaCgpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKCF3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpIHJlc29sdmUodm9pZCAwKTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKHdhaXRGb3JDb25maXJtYXRpb25Gb3JNcykge1xuICAgICAgUHJvbWlzZS5yYWNlKFt0aW1lb3V0UHJvbWlzZSwgc2NoZWR1bGVQcm9taXNlXSkudGhlbigoZSkgPT4ge1xuICAgICAgICByZXNvbHZlKGUpO1xuICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVQcm9taXNlLnRoZW4ocmVzb2x2ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL25kay9pbmRleC50c1xuaW1wb3J0IGRlYnVnNyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI4IH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy9ldmVudHMvZGVkdXAudHNcbmZ1bmN0aW9uIGRlZHVwKGV2ZW50MSwgZXZlbnQyKSB7XG4gIGlmIChldmVudDEuY3JlYXRlZF9hdCA+IGV2ZW50Mi5jcmVhdGVkX2F0KSB7XG4gICAgcmV0dXJuIGV2ZW50MTtcbiAgfVxuICByZXR1cm4gZXZlbnQyO1xufVxuXG4vLyBzcmMvb3V0Ym94L3RyYWNrZXIudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI3IH0gZnJvbSBcInRzZWVwXCI7XG5pbXBvcnQgeyBMUlVDYWNoZSBhcyBMUlVDYWNoZTIgfSBmcm9tIFwidHlwZXNjcmlwdC1scnUtY2FjaGVcIjtcblxuLy8gc3JjL3V0aWxzL2dldC11c2Vycy1yZWxheS1saXN0LnRzXG5hc3luYyBmdW5jdGlvbiBnZXRSZWxheUxpc3RGb3JVc2VyKHB1YmtleSwgbmRrKSB7XG4gIGNvbnN0IGxpc3QgPSBhd2FpdCBnZXRSZWxheUxpc3RGb3JVc2VycyhbcHVia2V5XSwgbmRrKTtcbiAgcmV0dXJuIGxpc3QuZ2V0KHB1YmtleSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRSZWxheUxpc3RGb3JVc2VycyhwdWJrZXlzLCBuZGssIHNraXBDYWNoZSA9IGZhbHNlLCB0aW1lb3V0ID0gMWUzKSB7XG4gIGNvbnN0IHBvb2wgPSBuZGsub3V0Ym94UG9vbCB8fCBuZGsucG9vbDtcbiAgY29uc3Qgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCByZWxheSBvZiBwb29sLnJlbGF5cy52YWx1ZXMoKSkgc2V0LmFkZChyZWxheSk7XG4gIGNvbnN0IHJlbGF5TGlzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBmcm9tQ29udGFjdExpc3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCByZWxheVNldCA9IG5ldyBOREtSZWxheVNldChzZXQsIG5kayk7XG4gIGlmIChuZGsuY2FjaGVBZGFwdGVyPy5sb2NraW5nICYmICFza2lwQ2FjaGUpIHtcbiAgICBjb25zdCBjYWNoZWRMaXN0ID0gYXdhaXQgbmRrLmZldGNoRXZlbnRzKFxuICAgICAgeyBraW5kczogWzMsIDEwMDAyXSwgYXV0aG9yczogQXJyYXkuZnJvbShuZXcgU2V0KHB1YmtleXMpKSB9LFxuICAgICAgeyBjYWNoZVVzYWdlOiBcIk9OTFlfQ0FDSEVcIiAvKiBPTkxZX0NBQ0hFICovLCBzdWJJZDogXCJuZGstcmVsYXktbGlzdC1mZXRjaFwiIH1cbiAgICApO1xuICAgIGZvciAoY29uc3QgcmVsYXlMaXN0IG9mIGNhY2hlZExpc3QpIHtcbiAgICAgIGlmIChyZWxheUxpc3Qua2luZCA9PT0gMTAwMDIpIHJlbGF5TGlzdHMuc2V0KHJlbGF5TGlzdC5wdWJrZXksIE5ES1JlbGF5TGlzdC5mcm9tKHJlbGF5TGlzdCkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHJlbGF5TGlzdCBvZiBjYWNoZWRMaXN0KSB7XG4gICAgICBpZiAocmVsYXlMaXN0LmtpbmQgPT09IDMpIHtcbiAgICAgICAgaWYgKHJlbGF5TGlzdHMuaGFzKHJlbGF5TGlzdC5wdWJrZXkpKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbGlzdCA9IHJlbGF5TGlzdEZyb21LaW5kMyhuZGssIHJlbGF5TGlzdCk7XG4gICAgICAgIGlmIChsaXN0KSBmcm9tQ29udGFjdExpc3Quc2V0KHJlbGF5TGlzdC5wdWJrZXksIGxpc3QpO1xuICAgICAgfVxuICAgIH1cbiAgICBwdWJrZXlzID0gcHVia2V5cy5maWx0ZXIoKHB1YmtleSkgPT4gIXJlbGF5TGlzdHMuaGFzKHB1YmtleSkgJiYgIWZyb21Db250YWN0TGlzdC5oYXMocHVia2V5KSk7XG4gIH1cbiAgaWYgKHB1YmtleXMubGVuZ3RoID09PSAwKSByZXR1cm4gcmVsYXlMaXN0cztcbiAgY29uc3QgcmVsYXlMaXN0RXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgY29udGFjdExpc3RFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTdWJzY3JpcHRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzdWJzY3JpYmVPcHRzID0ge1xuICAgICAgICBjbG9zZU9uRW9zZTogdHJ1ZSxcbiAgICAgICAgcG9vbCxcbiAgICAgICAgZ3JvdXBhYmxlOiB0cnVlLFxuICAgICAgICBzdWJJZDogXCJuZGstcmVsYXktbGlzdC1mZXRjaFwiLFxuICAgICAgICBhZGRTaW5jZUZyb21DYWNoZTogdHJ1ZSxcbiAgICAgICAgcmVsYXlTZXRcbiAgICAgIH07XG4gICAgICBpZiAocmVsYXlTZXQpIHN1YnNjcmliZU9wdHMucmVsYXlTZXQgPSByZWxheVNldDtcbiAgICAgIG5kay5zdWJzY3JpYmUoeyBraW5kczogWzMsIDEwMDAyXSwgYXV0aG9yczogcHVia2V5cyB9LCBzdWJzY3JpYmVPcHRzLCB7XG4gICAgICAgIG9uRXZlbnQ6IChldmVudCkgPT4ge1xuICAgICAgICAgIGlmIChldmVudC5raW5kID09PSAxMDAwMiAvKiBSZWxheUxpc3QgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRXZlbnQgPSByZWxheUxpc3RFdmVudHMuZ2V0KGV2ZW50LnB1YmtleSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdFdmVudCAmJiBleGlzdGluZ0V2ZW50LmNyZWF0ZWRfYXQgPiBldmVudC5jcmVhdGVkX2F0KSByZXR1cm47XG4gICAgICAgICAgICByZWxheUxpc3RFdmVudHMuc2V0KGV2ZW50LnB1YmtleSwgZXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2luZCA9PT0gMyAvKiBDb250YWN0cyAqLykge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdFdmVudCA9IGNvbnRhY3RMaXN0RXZlbnRzLmdldChldmVudC5wdWJrZXkpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRXZlbnQgJiYgZXhpc3RpbmdFdmVudC5jcmVhdGVkX2F0ID4gZXZlbnQuY3JlYXRlZF9hdCkgcmV0dXJuO1xuICAgICAgICAgICAgY29udGFjdExpc3RFdmVudHMuc2V0KGV2ZW50LnB1YmtleSwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Fb3NlOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiByZWxheUxpc3RFdmVudHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHJlbGF5TGlzdHMuc2V0KGV2ZW50LnB1YmtleSwgTkRLUmVsYXlMaXN0LmZyb20oZXZlbnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCBwdWJrZXkgb2YgcHVia2V5cykge1xuICAgICAgICAgICAgaWYgKHJlbGF5TGlzdHMuaGFzKHB1YmtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgY29udGFjdExpc3QgPSBjb250YWN0TGlzdEV2ZW50cy5nZXQocHVia2V5KTtcbiAgICAgICAgICAgIGlmICghY29udGFjdExpc3QpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbGlzdCA9IHJlbGF5TGlzdEZyb21LaW5kMyhuZGssIGNvbnRhY3RMaXN0KTtcbiAgICAgICAgICAgIGlmIChsaXN0KSByZWxheUxpc3RzLnNldChwdWJrZXksIGxpc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHJlbGF5TGlzdHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZXNvbHZlKHJlbGF5TGlzdHMpO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgfTtcbiAgICBoYW5kbGVTdWJzY3JpcHRpb24oKTtcbiAgfSk7XG59XG5cbi8vIHNyYy9vdXRib3gvdHJhY2tlci50c1xudmFyIE91dGJveEl0ZW0gPSBjbGFzcyB7XG4gIC8qKlxuICAgKiBUeXBlIG9mIGl0ZW1cbiAgICovXG4gIHR5cGU7XG4gIC8qKlxuICAgKiBUaGUgcmVsYXkgVVJMcyB0aGF0IGFyZSBvZiBpbnRlcmVzdCB0byB0aGlzIGl0ZW1cbiAgICovXG4gIHJlbGF5VXJsU2NvcmVzO1xuICByZWFkUmVsYXlzO1xuICB3cml0ZVJlbGF5cztcbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5yZWxheVVybFNjb3JlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5yZWFkUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLndyaXRlUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgfVxufTtcbnZhciBPdXRib3hUcmFja2VyID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXI3IHtcbiAgZGF0YTtcbiAgbmRrO1xuICBkZWJ1ZztcbiAgY29uc3RydWN0b3IobmRrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLmRlYnVnID0gbmRrLmRlYnVnLmV4dGVuZChcIm91dGJveC10cmFja2VyXCIpO1xuICAgIHRoaXMuZGF0YSA9IG5ldyBMUlVDYWNoZTIoe1xuICAgICAgbWF4U2l6ZTogMWU1LFxuICAgICAgZW50cnlFeHBpcmF0aW9uVGltZUluTVM6IDIgKiA2MCAqIDFlM1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbGlzdCBvZiB1c2VycyB0byB0aGUgdHJhY2tlci5cbiAgICogQHBhcmFtIGl0ZW1zXG4gICAqIEBwYXJhbSBza2lwQ2FjaGVcbiAgICovXG4gIGFzeW5jIHRyYWNrVXNlcnMoaXRlbXMsIHNraXBDYWNoZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSA0MDApIHtcbiAgICAgIGNvbnN0IHNsaWNlID0gaXRlbXMuc2xpY2UoaSwgaSArIDQwMCk7XG4gICAgICBjb25zdCBwdWJrZXlzID0gc2xpY2UubWFwKChpdGVtKSA9PiBnZXRLZXlGcm9tSXRlbShpdGVtKSkuZmlsdGVyKChwdWJrZXkpID0+ICF0aGlzLmRhdGEuaGFzKHB1YmtleSkpO1xuICAgICAgaWYgKHB1YmtleXMubGVuZ3RoID09PSAwKSBjb250aW51ZTtcbiAgICAgIGZvciAoY29uc3QgcHVia2V5IG9mIHB1YmtleXMpIHtcbiAgICAgICAgdGhpcy5kYXRhLnNldChwdWJrZXksIG5ldyBPdXRib3hJdGVtKFwidXNlclwiKSk7XG4gICAgICB9XG4gICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIGdldFJlbGF5TGlzdEZvclVzZXJzKHB1YmtleXMsIHRoaXMubmRrLCBza2lwQ2FjaGUpLnRoZW4oKHJlbGF5TGlzdHMpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3B1YmtleSwgcmVsYXlMaXN0XSBvZiByZWxheUxpc3RzKSB7XG4gICAgICAgICAgICAgIGxldCBvdXRib3hJdGVtID0gdGhpcy5kYXRhLmdldChwdWJrZXkpO1xuICAgICAgICAgICAgICBvdXRib3hJdGVtID8/PSBuZXcgT3V0Ym94SXRlbShcInVzZXJcIik7XG4gICAgICAgICAgICAgIGlmIChyZWxheUxpc3QpIHtcbiAgICAgICAgICAgICAgICBvdXRib3hJdGVtLnJlYWRSZWxheXMgPSBuZXcgU2V0KG5vcm1hbGl6ZShyZWxheUxpc3QucmVhZFJlbGF5VXJscykpO1xuICAgICAgICAgICAgICAgIG91dGJveEl0ZW0ud3JpdGVSZWxheXMgPSBuZXcgU2V0KG5vcm1hbGl6ZShyZWxheUxpc3Qud3JpdGVSZWxheVVybHMpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIG91dGJveEl0ZW0ucmVhZFJlbGF5cykge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmRrLnBvb2wuYmxhY2tsaXN0UmVsYXlVcmxzLmhhcyhyZWxheVVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0Ym94SXRlbS5yZWFkUmVsYXlzLmRlbGV0ZShyZWxheVVybCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2Ygb3V0Ym94SXRlbS53cml0ZVJlbGF5cykge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmRrLnBvb2wuYmxhY2tsaXN0UmVsYXlVcmxzLmhhcyhyZWxheVVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0Ym94SXRlbS53cml0ZVJlbGF5cy5kZWxldGUocmVsYXlVcmwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuc2V0KHB1YmtleSwgb3V0Ym94SXRlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5maW5hbGx5KHJlc29sdmUpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gc2NvcmVcbiAgICovXG4gIHRyYWNrKGl0ZW0sIHR5cGUsIF9za2lwQ2FjaGUgPSB0cnVlKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5RnJvbUl0ZW0oaXRlbSk7XG4gICAgdHlwZSA/Pz0gZ2V0VHlwZUZyb21JdGVtKGl0ZW0pO1xuICAgIGxldCBvdXRib3hJdGVtID0gdGhpcy5kYXRhLmdldChrZXkpO1xuICAgIGlmICghb3V0Ym94SXRlbSkge1xuICAgICAgb3V0Ym94SXRlbSA9IG5ldyBPdXRib3hJdGVtKHR5cGUpO1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtVc2VyKSB7XG4gICAgICAgIHRoaXMudHJhY2tVc2VycyhbaXRlbV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0Ym94SXRlbTtcbiAgfVxufTtcbmZ1bmN0aW9uIGdldEtleUZyb21JdGVtKGl0ZW0pIHtcbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtVc2VyKSB7XG4gICAgcmV0dXJuIGl0ZW0ucHVia2V5O1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuZnVuY3Rpb24gZ2V0VHlwZUZyb21JdGVtKGl0ZW0pIHtcbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtVc2VyKSB7XG4gICAgcmV0dXJuIFwidXNlclwiO1xuICB9XG4gIHJldHVybiBcImtpbmRcIjtcbn1cblxuLy8gc3JjL3JlbGF5L3NldHMvdXRpbHMudHNcbmZ1bmN0aW9uIGNvcnJlY3RSZWxheVNldChyZWxheVNldCwgcG9vbCkge1xuICBjb25zdCBjb25uZWN0ZWRSZWxheXMgPSBwb29sLmNvbm5lY3RlZFJlbGF5cygpO1xuICBjb25zdCBpbmNsdWRlc0Nvbm5lY3RlZFJlbGF5ID0gQXJyYXkuZnJvbShyZWxheVNldC5yZWxheXMpLnNvbWUoKHJlbGF5KSA9PiB7XG4gICAgcmV0dXJuIGNvbm5lY3RlZFJlbGF5cy5tYXAoKHIpID0+IHIudXJsKS5pbmNsdWRlcyhyZWxheS51cmwpO1xuICB9KTtcbiAgaWYgKCFpbmNsdWRlc0Nvbm5lY3RlZFJlbGF5KSB7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiBjb25uZWN0ZWRSZWxheXMpIHtcbiAgICAgIHJlbGF5U2V0LmFkZFJlbGF5KHJlbGF5KTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbm5lY3RlZFJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHBvb2wucmVsYXlzLnZhbHVlcygpKSB7XG4gICAgICByZWxheVNldC5hZGRSZWxheShyZWxheSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWxheVNldDtcbn1cblxuLy8gc3JjL3N1YnNjcmlwdGlvbi9tYW5hZ2VyLnRzXG5pbXBvcnQgeyBtYXRjaEZpbHRlcnMgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbnZhciBOREtTdWJzY3JpcHRpb25NYW5hZ2VyID0gY2xhc3Mge1xuICBzdWJzY3JpcHRpb25zO1xuICBzZWVuRXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBhZGQoc3ViKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChzdWIuaW50ZXJuYWxJZCwgc3ViKTtcbiAgICBpZiAoc3ViLm9uU3RvcHBlZCkge1xuICAgIH1cbiAgICBzdWIub25TdG9wcGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZShzdWIuaW50ZXJuYWxJZCk7XG4gICAgfTtcbiAgICBzdWIub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1Yi5pbnRlcm5hbElkKTtcbiAgICB9KTtcbiAgfVxuICBzZWVuRXZlbnQoZXZlbnRJZCwgcmVsYXkpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5zZWVuRXZlbnRzLmdldChldmVudElkKSB8fCBbXTtcbiAgICBjdXJyZW50LnB1c2gocmVsYXkpO1xuICAgIHRoaXMuc2VlbkV2ZW50cy5zZXQoZXZlbnRJZCwgY3VycmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZW5ldmVyIGFuIGV2ZW50IGNvbWVzIGluLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICogVGhpcyBmdW5jdGlvbiBtYXRjaGVzIHRoZSByZWNlaXZlZCBldmVudCBhZ2FpbnN0IGFsbCB0aGVcbiAgICoga25vd24gKGkuZS4gYWN0aXZlKSBOREtTdWJzY3JpcHRpb25zLCBhbmQgaWYgaXQgbWF0Y2hlcyxcbiAgICogaXQgc2VuZHMgdGhlIGV2ZW50IHRvIHRoZSBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIFRoaXMgaXMgdGhlIHNpbmdsZSBwbGFjZSBpbiB0aGUgY29kZWJhc2UgdGhhdCBtYXRjaGVzXG4gICAqIGluY29taW5nIGV2ZW50cyB3aXRoIHBhcnRpZXMgaW50ZXJlc3RlZCBpbiB0aGUgZXZlbnQuXG4gICAqXG4gICAqIFRoaXMgaXMgYWxzbyB3aGF0IGFsbG93cyBmb3IgcmVhY3Rpdml0eSBpbiBOREsgYXBwcywgc3VjaCB0aGF0XG4gICAqIHdoZW5ldmVyIGFuIGFjdGl2ZSBzdWJzY3JpcHRpb24gcmVjZWl2ZXMgYW4gZXZlbnQgdGhhdCBzb21lXG4gICAqIG90aGVyIGFjdGl2ZSBzdWJzY3JpcHRpb24gd291bGQgd2FudCB0byByZWNlaXZlLCBib3RoIHJlY2VpdmUgaXQuXG4gICAqXG4gICAqIFRPRE8gVGhpcyBhbHNvIGFsbG93cyBmb3Igc3Vic2NyaXB0aW9ucyB0aGF0IG92ZXJsYXAgaW4gbWVhbmluZ1xuICAgKiB0byBiZSBjb2xsYXBzZWQgaW50byBvbmUuXG4gICAqXG4gICAqIEkuZS4gaWYgYSBzdWJzY3JpcHRpb24gd2l0aCBmaWx0ZXI6IGtpbmRzOiBbMV0sIGF1dGhvcnM6IFthbGljZV1cbiAgICogaXMgY3JlYXRlZCBhbmQgRU9TRXMsIGFuZCB0aGVuIGEgc3Vic2VxdWVudCBzdWJzY3JpcHRpb24gd2l0aFxuICAgKiBraW5kczogWzFdLCBhdXRob3JzOiBbYWxpY2VdIGlzIGNyZWF0ZWQsIG9uY2UgdGhlIHNlY29uZCBzdWJzY3JpcHRpb25cbiAgICogRU9TRXMgd2UgY2FuIHNhZmVseSBjbG9zZSBpdCwgaW5jcmVtZW50IGl0cyByZWZDb3VudCBhbmQgY2xvc2UgaXQsXG4gICAqIGFuZCB3aGVuIHRoZSBmaXJzdCBzdWJzY3JpcHRpb24gcmVjZWl2ZXMgYSBuZXcgZXZlbnQgZnJvbSBBbGljZSB0aGlzXG4gICAqIGNvZGUgd2lsbCBtYWtlIHRoZSBzZWNvbmQgc3Vic2NyaXB0aW9uIHJlY2VpdmUgdGhlIGV2ZW50IGV2ZW4gdGhvdWdoXG4gICAqIGl0IGhhcyBubyBhY3RpdmUgc3Vic2NyaXB0aW9uIG9uIGEgcmVsYXkuXG4gICAqIEBwYXJhbSBldmVudCBSYXcgZXZlbnQgcmVjZWl2ZWQgZnJvbSBhIHJlbGF5XG4gICAqIEBwYXJhbSByZWxheSBSZWxheSB0aGF0IHNlbnQgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBvcHRpbWlzdGljUHVibGlzaCBXaGV0aGVyIHRoZSBldmVudCBpcyBjb21pbmcgZnJvbSBhbiBvcHRpbWlzdGljIHB1Ymxpc2hcbiAgICovXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQsIHJlbGF5LCBvcHRpbWlzdGljUHVibGlzaCA9IGZhbHNlKSB7XG4gICAgaWYgKHJlbGF5KSB0aGlzLnNlZW5FdmVudChldmVudC5pZCwgcmVsYXkpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMudmFsdWVzKCk7XG4gICAgY29uc3QgbWF0Y2hpbmdTdWJzID0gW107XG4gICAgZm9yIChjb25zdCBzdWIgb2Ygc3Vic2NyaXB0aW9ucykge1xuICAgICAgaWYgKG1hdGNoRmlsdGVycyhzdWIuZmlsdGVycywgZXZlbnQpKSB7XG4gICAgICAgIG1hdGNoaW5nU3Vicy5wdXNoKHN1Yik7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3ViIG9mIG1hdGNoaW5nU3Vicykge1xuICAgICAgc3ViLmV2ZW50UmVjZWl2ZWQoZXZlbnQsIHJlbGF5LCBmYWxzZSwgb3B0aW1pc3RpY1B1Ymxpc2gpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL25kay9hY3RpdmUtdXNlci50c1xuaW1wb3J0IGNyZWF0ZURlYnVnMyBmcm9tIFwiZGVidWdcIjtcbnZhciBkZWJ1ZzYgPSBjcmVhdGVEZWJ1ZzMoXCJuZGs6YWN0aXZlLXVzZXJcIik7XG5hc3luYyBmdW5jdGlvbiBnZXRVc2VyUmVsYXlMaXN0KHVzZXIpIHtcbiAgaWYgKCF0aGlzLmF1dG9Db25uZWN0VXNlclJlbGF5cykgcmV0dXJuO1xuICBjb25zdCB1c2VyUmVsYXlzID0gYXdhaXQgZ2V0UmVsYXlMaXN0Rm9yVXNlcih1c2VyLnB1YmtleSwgdGhpcyk7XG4gIGlmICghdXNlclJlbGF5cykgcmV0dXJuO1xuICBmb3IgKGNvbnN0IHVybCBvZiB1c2VyUmVsYXlzLnJlbGF5cykge1xuICAgIGxldCByZWxheSA9IHRoaXMucG9vbC5yZWxheXMuZ2V0KHVybCk7XG4gICAgaWYgKCFyZWxheSkge1xuICAgICAgcmVsYXkgPSBuZXcgTkRLUmVsYXkodXJsLCB0aGlzLnJlbGF5QXV0aERlZmF1bHRQb2xpY3ksIHRoaXMpO1xuICAgICAgdGhpcy5wb29sLmFkZFJlbGF5KHJlbGF5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVzZXJSZWxheXM7XG59XG5hc3luYyBmdW5jdGlvbiBzZXRBY3RpdmVVc2VyKHVzZXIpIHtcbiAgY29uc3QgcG9vbCA9IHRoaXMub3V0Ym94UG9vbCB8fCB0aGlzLnBvb2w7XG4gIGlmIChwb29sLmNvbm5lY3RlZFJlbGF5cy5sZW5ndGggPiAwKSB7XG4gICAgc2V0QWN0aXZlVXNlckNvbm5lY3RlZC5jYWxsKHRoaXMsIHVzZXIpO1xuICB9IGVsc2Uge1xuICAgIHBvb2wub25jZShcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgc2V0QWN0aXZlVXNlckNvbm5lY3RlZC5jYWxsKHRoaXMsIHVzZXIpO1xuICAgIH0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBzZXRBY3RpdmVVc2VyQ29ubmVjdGVkKHVzZXIpIHtcbiAgY29uc3QgdXNlclJlbGF5cyA9IGF3YWl0IGdldFVzZXJSZWxheUxpc3QuY2FsbCh0aGlzLCB1c2VyKTtcbiAgY29uc3QgZmlsdGVycyA9IFtcbiAgICB7XG4gICAgICBraW5kczogWzEwMDA2IC8qIEJsb2NrUmVsYXlMaXN0ICovXSxcbiAgICAgIGF1dGhvcnM6IFt1c2VyLnB1YmtleV1cbiAgICB9XG4gIF07XG4gIGlmICh0aGlzLmF1dG9GZXRjaFVzZXJNdXRlbGlzdCkge1xuICAgIGZpbHRlcnNbMF0ua2luZHM/LnB1c2goMWU0IC8qIE11dGVMaXN0ICovKTtcbiAgfVxuICBjb25zdCBldmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCByZWxheVNldCA9IHVzZXJSZWxheXMgPyB1c2VyUmVsYXlzLnJlbGF5U2V0IDogdm9pZCAwO1xuICB0aGlzLnN1YnNjcmliZShcbiAgICBmaWx0ZXJzLFxuICAgIHsgc3ViSWQ6IFwiYWN0aXZlLXVzZXItc2V0dGluZ3NcIiwgY2xvc2VPbkVvc2U6IHRydWUsIHJlbGF5U2V0IH0sXG4gICAge1xuICAgICAgb25FdmVudDogKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZFdmVudCA9IGV2ZW50cy5nZXQoZXZlbnQua2luZCk7XG4gICAgICAgIGlmIChwcmV2RXZlbnQgJiYgcHJldkV2ZW50LmNyZWF0ZWRfYXQgPj0gZXZlbnQuY3JlYXRlZF9hdCkgcmV0dXJuO1xuICAgICAgICBldmVudHMuc2V0KGV2ZW50LmtpbmQsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBvbkVvc2U6ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMudmFsdWVzKCkpIHtcbiAgICAgICAgICBwcm9jZXNzRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzRXZlbnQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtpbmQgPT09IDEwMDA2IC8qIEJsb2NrUmVsYXlMaXN0ICovKSB7XG4gICAgcHJvY2Vzc0Jsb2NrUmVsYXlMaXN0LmNhbGwodGhpcywgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGV2ZW50LmtpbmQgPT09IDFlNCAvKiBNdXRlTGlzdCAqLykge1xuICAgIHByb2Nlc3NNdXRlTGlzdC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrUmVsYXlMaXN0KGV2ZW50KSB7XG4gIGNvbnN0IGxpc3QgPSBsaXN0c19kZWZhdWx0LmZyb20oZXZlbnQpO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgbGlzdC5pdGVtcykge1xuICAgIHRoaXMucG9vbC5ibGFja2xpc3RSZWxheVVybHMuYWRkKGl0ZW1bMF0pO1xuICB9XG4gIGRlYnVnNihcIkFkZGVkICVkIHJlbGF5cyB0byByZWxheSBibGFja2xpc3RcIiwgbGlzdC5pdGVtcy5sZW5ndGgpO1xufVxuZnVuY3Rpb24gcHJvY2Vzc011dGVMaXN0KG11dGVMaXN0KSB7XG4gIGNvbnN0IGxpc3QgPSBsaXN0c19kZWZhdWx0LmZyb20obXV0ZUxpc3QpO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgbGlzdC5pdGVtcykge1xuICAgIHRoaXMubXV0ZWRJZHMuc2V0KGl0ZW1bMV0sIGl0ZW1bMF0pO1xuICB9XG4gIGRlYnVnNihcIkFkZGVkICVkIHVzZXJzIHRvIG11dGUgbGlzdFwiLCBsaXN0Lml0ZW1zLmxlbmd0aCk7XG59XG5cbi8vIHNyYy9uZGsvZW50aXR5LnRzXG5pbXBvcnQgeyBuaXAxOSBhcyBuaXAxOTcgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbmZ1bmN0aW9uIGdldEVudGl0eShlbnRpdHkpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkZWNvZGVkID0gbmlwMTk3LmRlY29kZShlbnRpdHkpO1xuICAgIGlmIChkZWNvZGVkLnR5cGUgPT09IFwibnB1YlwiKSByZXR1cm4gbnB1Yih0aGlzLCBkZWNvZGVkLmRhdGEpO1xuICAgIGlmIChkZWNvZGVkLnR5cGUgPT09IFwibnByb2ZpbGVcIikgcmV0dXJuIG5wcm9maWxlKHRoaXMsIGRlY29kZWQuZGF0YSk7XG4gICAgcmV0dXJuIGRlY29kZWQ7XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIG5wdWIobmRrLCBwdWJrZXkpIHtcbiAgcmV0dXJuIG5kay5nZXRVc2VyKHsgcHVia2V5IH0pO1xufVxuZnVuY3Rpb24gbnByb2ZpbGUobmRrLCBwcm9maWxlKSB7XG4gIGNvbnN0IHVzZXIgPSBuZGsuZ2V0VXNlcih7IHB1YmtleTogcHJvZmlsZS5wdWJrZXkgfSk7XG4gIGlmIChwcm9maWxlLnJlbGF5cykgdXNlci5yZWxheVVybHMgPSBwcm9maWxlLnJlbGF5cztcbiAgcmV0dXJuIHVzZXI7XG59XG5cbi8vIHNyYy9uZGsvZmV0Y2gtZXZlbnQtZnJvbS10YWcudHNcbmZ1bmN0aW9uIGlzVmFsaWRIaW50KGhpbnQpIHtcbiAgaWYgKCFoaW50IHx8IGhpbnQgPT09IFwiXCIpIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICBuZXcgVVJMKGhpbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChfZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hFdmVudEZyb21UYWcodGFnLCBvcmlnaW5hbEV2ZW50LCBzdWJPcHRzLCBmYWxsYmFjayA9IHtcbiAgdHlwZTogXCJ0aW1lb3V0XCJcbn0pIHtcbiAgY29uc3QgZDQgPSB0aGlzLmRlYnVnLmV4dGVuZChcImZldGNoLWV2ZW50LWZyb20tdGFnXCIpO1xuICBjb25zdCBbXywgaWQsIGhpbnRdID0gdGFnO1xuICBzdWJPcHRzID0ge307XG4gIGQ0KFwiZmV0Y2hpbmcgZXZlbnQgZnJvbSB0YWdcIiwgdGFnLCBzdWJPcHRzLCBmYWxsYmFjayk7XG4gIGNvbnN0IGF1dGhvclJlbGF5cyA9IGdldFJlbGF5c0ZvclN5bmModGhpcywgb3JpZ2luYWxFdmVudC5wdWJrZXkpO1xuICBpZiAoYXV0aG9yUmVsYXlzICYmIGF1dGhvclJlbGF5cy5zaXplID4gMCkge1xuICAgIGQ0KFwiZmV0Y2hpbmcgZXZlbnQgZnJvbSBhdXRob3IgcmVsYXlzICVvXCIsIEFycmF5LmZyb20oYXV0aG9yUmVsYXlzKSk7XG4gICAgY29uc3QgcmVsYXlTZXQyID0gTkRLUmVsYXlTZXQuZnJvbVJlbGF5VXJscyhBcnJheS5mcm9tKGF1dGhvclJlbGF5cyksIHRoaXMpO1xuICAgIGNvbnN0IGV2ZW50MiA9IGF3YWl0IHRoaXMuZmV0Y2hFdmVudChpZCwgc3ViT3B0cywgcmVsYXlTZXQyKTtcbiAgICBpZiAoZXZlbnQyKSByZXR1cm4gZXZlbnQyO1xuICB9IGVsc2Uge1xuICAgIGQ0KFwibm8gYXV0aG9yIHJlbGF5cyBmb3VuZCBmb3IgJXNcIiwgb3JpZ2luYWxFdmVudC5wdWJrZXksIG9yaWdpbmFsRXZlbnQpO1xuICB9XG4gIGNvbnN0IHJlbGF5U2V0ID0gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcnModGhpcywgW3sgaWRzOiBbaWRdIH1dLCB0aGlzLnBvb2wpO1xuICBkNChcImZldGNoaW5nIGV2ZW50IHdpdGhvdXQgcmVsYXkgaGludFwiLCByZWxheVNldCk7XG4gIGNvbnN0IGV2ZW50ID0gYXdhaXQgdGhpcy5mZXRjaEV2ZW50KGlkLCBzdWJPcHRzKTtcbiAgaWYgKGV2ZW50KSByZXR1cm4gZXZlbnQ7XG4gIGlmIChoaW50ICYmIGhpbnQgIT09IFwiXCIpIHtcbiAgICBjb25zdCBldmVudDIgPSBhd2FpdCB0aGlzLmZldGNoRXZlbnQoaWQsIHN1Yk9wdHMsIHRoaXMucG9vbC5nZXRSZWxheShoaW50LCB0cnVlLCB0cnVlLCBbeyBpZHM6IFtpZF0gfV0pKTtcbiAgICBpZiAoZXZlbnQyKSByZXR1cm4gZXZlbnQyO1xuICB9XG4gIGxldCByZXN1bHQgPSB2b2lkIDA7XG4gIGNvbnN0IHJlbGF5ID0gaXNWYWxpZEhpbnQoaGludCkgPyB0aGlzLnBvb2wuZ2V0UmVsYXkoaGludCwgZmFsc2UsIHRydWUsIFt7IGlkczogW2lkXSB9XSkgOiB2b2lkIDA7XG4gIGNvbnN0IGZldGNoTWF5YmVXaXRoUmVsYXlIaW50ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICB0aGlzLmZldGNoRXZlbnQoaWQsIHN1Yk9wdHMsIHJlbGF5KS50aGVuKHJlc29sdmUpO1xuICB9KTtcbiAgaWYgKCFpc1ZhbGlkSGludChoaW50KSB8fCBmYWxsYmFjay50eXBlID09PSBcIm5vbmVcIikge1xuICAgIHJldHVybiBmZXRjaE1heWJlV2l0aFJlbGF5SGludDtcbiAgfVxuICBjb25zdCBmYWxsYmFja0ZldGNoUHJvbWlzZSA9IG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgZmFsbGJhY2tSZWxheVNldCA9IGZhbGxiYWNrLnJlbGF5U2V0O1xuICAgIGNvbnN0IHRpbWVvdXQgPSBmYWxsYmFjay50aW1lb3V0ID8/IDE1MDA7XG4gICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZTIpID0+IHNldFRpbWVvdXQocmVzb2x2ZTIsIHRpbWVvdXQpKTtcbiAgICBpZiAoZmFsbGJhY2sudHlwZSA9PT0gXCJ0aW1lb3V0XCIpIGF3YWl0IHRpbWVvdXRQcm9taXNlO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZDQoXCJmYWxsYmFjayBmZXRjaCB0cmlnZ2VyZWRcIik7XG4gICAgICBjb25zdCBmYWxsYmFja0V2ZW50ID0gYXdhaXQgdGhpcy5mZXRjaEV2ZW50KGlkLCBzdWJPcHRzLCBmYWxsYmFja1JlbGF5U2V0KTtcbiAgICAgIHJlc29sdmUoZmFsbGJhY2tFdmVudCk7XG4gICAgfVxuICB9KTtcbiAgc3dpdGNoIChmYWxsYmFjay50eXBlKSB7XG4gICAgY2FzZSBcInRpbWVvdXRcIjpcbiAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2ZldGNoTWF5YmVXaXRoUmVsYXlIaW50LCBmYWxsYmFja0ZldGNoUHJvbWlzZV0pO1xuICAgIGNhc2UgXCJlb3NlXCI6XG4gICAgICByZXN1bHQgPSBhd2FpdCBmZXRjaE1heWJlV2l0aFJlbGF5SGludDtcbiAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICByZXR1cm4gZmFsbGJhY2tGZXRjaFByb21pc2U7XG4gIH1cbn1cblxuLy8gc3JjL25kay9xdWV1ZS9pbmRleC50c1xudmFyIFF1ZXVlID0gY2xhc3Mge1xuICBxdWV1ZSA9IFtdO1xuICBtYXhDb25jdXJyZW5jeTtcbiAgcHJvY2Vzc2luZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHByb21pc2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IoX25hbWUsIG1heENvbmN1cnJlbmN5KSB7XG4gICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IG1heENvbmN1cnJlbmN5O1xuICB9XG4gIGFkZChpdGVtKSB7XG4gICAgaWYgKHRoaXMucHJvbWlzZXMuaGFzKGl0ZW0uaWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9taXNlcy5nZXQoaXRlbS5pZCk7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goe1xuICAgICAgICAuLi5pdGVtLFxuICAgICAgICBmdW5jOiAoKSA9PiBpdGVtLmZ1bmMoKS50aGVuKFxuICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9jZXNzKCk7XG4gICAgfSk7XG4gICAgdGhpcy5wcm9taXNlcy5zZXQoaXRlbS5pZCwgcHJvbWlzZSk7XG4gICAgcHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMucHJvbWlzZXMuZGVsZXRlKGl0ZW0uaWQpO1xuICAgICAgdGhpcy5wcm9jZXNzaW5nLmRlbGV0ZShpdGVtLmlkKTtcbiAgICAgIHRoaXMucHJvY2VzcygpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIHByb2Nlc3MoKSB7XG4gICAgaWYgKHRoaXMucHJvY2Vzc2luZy5zaXplID49IHRoaXMubWF4Q29uY3VycmVuY3kgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICBpZiAoIWl0ZW0gfHwgdGhpcy5wcm9jZXNzaW5nLmhhcyhpdGVtLmlkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NpbmcuYWRkKGl0ZW0uaWQpO1xuICAgIGl0ZW0uZnVuYygpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgfVxuICBjbGVhclByb2Nlc3NpbmcoKSB7XG4gICAgdGhpcy5wcm9jZXNzaW5nLmNsZWFyKCk7XG4gIH1cbiAgY2xlYXJBbGwoKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuY2xlYXJQcm9jZXNzaW5nKCk7XG4gIH1cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlLmxlbmd0aDtcbiAgfVxufTtcblxuLy8gc3JjL25kay9pbmRleC50c1xudmFyIERFRkFVTFRfT1VUQk9YX1JFTEFZUyA9IFtcIndzczovL3B1cnBsZXBhZy5lcy9cIiwgXCJ3c3M6Ly9ub3MubG9sL1wiXTtcbnZhciBERUZBVUxUX0JMQUNLTElTVEVEX1JFTEFZUyA9IFtcbiAgXCJ3c3M6Ly9icmIuaW8vXCIsXG4gIC8vIEJSQlxuICBcIndzczovL25vc3RyLm11dGlueXdhbGxldC5jb20vXCJcbiAgLy8gRG9uJ3QgdHJ5IHRvIHJlYWQgZnJvbSB0aGlzIHJlbGF5IHNpbmNlIGl0J3MgYSB3cml0ZS1vbmx5IHJlbGF5XG4gIC8vIFwid3NzOi8vcHVycGxlcGFnLmVzL1wiLCAvLyBUaGlzIGlzIGEgaGFjaywgc2luY2UgdGhpcyBpcyBhIG1vc3RseSByZWFkLW9ubHkgcmVsYXksIGJ1dCBub3QgZnVsbHkuIE9uY2Ugd2UgaGF2ZSByZWxheSByb3V0aW5nIHRoaXMgY2FuIGJlIHJlbW92ZWQgc28gaXQgb25seSByZWNlaXZlcyB0aGUgc3VwcG9ydGVkIGtpbmRzXG5dO1xudmFyIE5ESyA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyOCB7XG4gIF9leHBsaWNpdFJlbGF5VXJscztcbiAgYmxhY2tsaXN0UmVsYXlVcmxzO1xuICBwb29sO1xuICBvdXRib3hQb29sO1xuICBfc2lnbmVyO1xuICBfYWN0aXZlVXNlcjtcbiAgY2FjaGVBZGFwdGVyO1xuICBkZWJ1ZztcbiAgZGV2V3JpdGVSZWxheVNldDtcbiAgb3V0Ym94VHJhY2tlcjtcbiAgbXV0ZWRJZHM7XG4gIGNsaWVudE5hbWU7XG4gIGNsaWVudE5pcDg5O1xuICBxdWV1ZXNaYXBDb25maWc7XG4gIHF1ZXVlc05pcDA1O1xuICBhc3luY1NpZ1ZlcmlmaWNhdGlvbiA9IGZhbHNlO1xuICBpbml0aWFsVmFsaWRhdGlvblJhdGlvID0gMTtcbiAgbG93ZXN0VmFsaWRhdGlvblJhdGlvID0gMTtcbiAgdmFsaWRhdGlvblJhdGlvRm47XG4gIHN1Yk1hbmFnZXI7XG4gIHB1Ymxpc2hpbmdGYWlsdXJlSGFuZGxlZCA9IGZhbHNlO1xuICBwb29scyA9IFtdO1xuICAvKipcbiAgICogRGVmYXVsdCByZWxheS1hdXRoIHBvbGljeSB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIGEgcmVsYXkgcmVxdWVzdHMgYXV0aGVudGljYXRpb24sXG4gICAqIGlmIG5vIG90aGVyIHBvbGljeSBpcyBzcGVjaWZpZWQgZm9yIHRoYXQgcmVsYXkuXG4gICAqXG4gICAqIEBleGFtcGxlIERpc2Nvbm5lY3QgZnJvbSByZWxheXMgdGhhdCByZXF1ZXN0IGF1dGhlbnRpY2F0aW9uOlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIG5kay5yZWxheUF1dGhEZWZhdWx0UG9saWN5ID0gTkRLQXV0aFBvbGljaWVzLmRpc2Nvbm5lY3QobmRrLnBvb2wpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgU2lnbiBpbiB0byByZWxheXMgdGhhdCByZXF1ZXN0IGF1dGhlbnRpY2F0aW9uOlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIG5kay5yZWxheUF1dGhEZWZhdWx0UG9saWN5ID0gTkRLQXV0aFBvbGljaWVzLnNpZ25Jbih7bmRrfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlIFNpZ24gaW4gdG8gcmVsYXlzIHRoYXQgcmVxdWVzdCBhdXRoZW50aWNhdGlvbiwgYXNraW5nIHRoZSB1c2VyIGZvciBjb25maXJtYXRpb246XG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogbmRrLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kgPSAocmVsYXk6IE5ES1JlbGF5KSA9PiB7XG4gICAqICAgICBjb25zdCBzaWduSW4gPSBOREtBdXRoUG9saWNpZXMuc2lnbkluKHtuZGt9KTtcbiAgICogICAgIGlmIChjb25maXJtKGBSZWxheSAke3JlbGF5LnVybH0gaXMgcmVxdWVzdGluZyBhdXRoZW50aWNhdGlvbiwgZG8geW91IHdhbnQgdG8gc2lnbiBpbj9gKSkge1xuICAgKiAgICAgICAgc2lnbkluKHJlbGF5KTtcbiAgICogICAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIHJlbGF5QXV0aERlZmF1bHRQb2xpY3k7XG4gIC8qKlxuICAgKiBGZXRjaCBmdW5jdGlvbiB0byB1c2UgZm9yIEhUVFAgcmVxdWVzdHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaW1wb3J0IGZldGNoIGZyb20gXCJub2RlLWZldGNoXCI7XG4gICAqXG4gICAqIG5kay5odHRwRmV0Y2ggPSBmZXRjaDtcbiAgICogYGBgXG4gICAqL1xuICBodHRwRmV0Y2g7XG4gIC8qKlxuICAgKiBQcm92aWRlIGEgY2FsbGVyIGZ1bmN0aW9uIHRvIHJlY2VpdmUgYWxsIG5ldHdvcmtpbmcgdHJhZmZpYyBmcm9tIHJlbGF5c1xuICAgKi9cbiAgbmV0RGVidWc7XG4gIGF1dG9Db25uZWN0VXNlclJlbGF5cyA9IHRydWU7XG4gIGF1dG9GZXRjaFVzZXJNdXRlbGlzdCA9IHRydWU7XG4gIHdhbGxldENvbmZpZztcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRlYnVnID0gb3B0cy5kZWJ1ZyB8fCBkZWJ1ZzcoXCJuZGtcIik7XG4gICAgdGhpcy5uZXREZWJ1ZyA9IG9wdHMubmV0RGVidWc7XG4gICAgdGhpcy5fZXhwbGljaXRSZWxheVVybHMgPSBvcHRzLmV4cGxpY2l0UmVsYXlVcmxzIHx8IFtdO1xuICAgIHRoaXMuYmxhY2tsaXN0UmVsYXlVcmxzID0gb3B0cy5ibGFja2xpc3RSZWxheVVybHMgfHwgREVGQVVMVF9CTEFDS0xJU1RFRF9SRUxBWVM7XG4gICAgdGhpcy5zdWJNYW5hZ2VyID0gbmV3IE5ES1N1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICB0aGlzLnBvb2wgPSBuZXcgTkRLUG9vbChvcHRzLmV4cGxpY2l0UmVsYXlVcmxzIHx8IFtdLCBbXSwgdGhpcyk7XG4gICAgdGhpcy5wb29sLm5hbWUgPSBcIk1haW5cIjtcbiAgICB0aGlzLnBvb2wub24oXCJyZWxheTphdXRoXCIsIGFzeW5jIChyZWxheSwgY2hhbGxlbmdlKSA9PiB7XG4gICAgICBpZiAodGhpcy5yZWxheUF1dGhEZWZhdWx0UG9saWN5KSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVsYXlBdXRoRGVmYXVsdFBvbGljeShyZWxheSwgY2hhbGxlbmdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmF1dG9Db25uZWN0VXNlclJlbGF5cyA9IG9wdHMuYXV0b0Nvbm5lY3RVc2VyUmVsYXlzID8/IHRydWU7XG4gICAgdGhpcy5hdXRvRmV0Y2hVc2VyTXV0ZWxpc3QgPSBvcHRzLmF1dG9GZXRjaFVzZXJNdXRlbGlzdCA/PyB0cnVlO1xuICAgIHRoaXMuY2xpZW50TmFtZSA9IG9wdHMuY2xpZW50TmFtZTtcbiAgICB0aGlzLmNsaWVudE5pcDg5ID0gb3B0cy5jbGllbnROaXA4OTtcbiAgICB0aGlzLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kgPSBvcHRzLnJlbGF5QXV0aERlZmF1bHRQb2xpY3k7XG4gICAgaWYgKG9wdHMuZW5hYmxlT3V0Ym94TW9kZWwpIHtcbiAgICAgIHRoaXMub3V0Ym94UG9vbCA9IG5ldyBOREtQb29sKG9wdHMub3V0Ym94UmVsYXlVcmxzIHx8IERFRkFVTFRfT1VUQk9YX1JFTEFZUywgW10sIHRoaXMsIHtcbiAgICAgICAgZGVidWc6IHRoaXMuZGVidWcuZXh0ZW5kKFwib3V0Ym94LXBvb2xcIiksXG4gICAgICAgIG5hbWU6IFwiT3V0Ym94IFBvb2xcIlxuICAgICAgfSk7XG4gICAgICB0aGlzLm91dGJveFRyYWNrZXIgPSBuZXcgT3V0Ym94VHJhY2tlcih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5zaWduZXIgPSBvcHRzLnNpZ25lcjtcbiAgICB0aGlzLmNhY2hlQWRhcHRlciA9IG9wdHMuY2FjaGVBZGFwdGVyO1xuICAgIHRoaXMubXV0ZWRJZHMgPSBvcHRzLm11dGVkSWRzIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKG9wdHMuZGV2V3JpdGVSZWxheVVybHMpIHtcbiAgICAgIHRoaXMuZGV2V3JpdGVSZWxheVNldCA9IE5ES1JlbGF5U2V0LmZyb21SZWxheVVybHMob3B0cy5kZXZXcml0ZVJlbGF5VXJscywgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMucXVldWVzWmFwQ29uZmlnID0gbmV3IFF1ZXVlKFwiemFwc1wiLCAzKTtcbiAgICB0aGlzLnF1ZXVlc05pcDA1ID0gbmV3IFF1ZXVlKFwibmlwMDVcIiwgMTApO1xuICAgIHRoaXMuc2lnbmF0dXJlVmVyaWZpY2F0aW9uV29ya2VyID0gb3B0cy5zaWduYXR1cmVWZXJpZmljYXRpb25Xb3JrZXI7XG4gICAgdGhpcy5pbml0aWFsVmFsaWRhdGlvblJhdGlvID0gb3B0cy5pbml0aWFsVmFsaWRhdGlvblJhdGlvIHx8IDE7XG4gICAgdGhpcy5sb3dlc3RWYWxpZGF0aW9uUmF0aW8gPSBvcHRzLmxvd2VzdFZhbGlkYXRpb25SYXRpbyB8fCAxO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmh0dHBGZXRjaCA9IGZldGNoO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICBzZXQgZXhwbGljaXRSZWxheVVybHModXJscykge1xuICAgIHRoaXMuX2V4cGxpY2l0UmVsYXlVcmxzID0gdXJscy5tYXAobm9ybWFsaXplUmVsYXlVcmwpO1xuICAgIHRoaXMucG9vbC5yZWxheVVybHMgPSB1cmxzO1xuICB9XG4gIGdldCBleHBsaWNpdFJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy5fZXhwbGljaXRSZWxheVVybHMgfHwgW107XG4gIH1cbiAgc2V0IHNpZ25hdHVyZVZlcmlmaWNhdGlvbldvcmtlcih3b3JrZXIyKSB7XG4gICAgdGhpcy5hc3luY1NpZ1ZlcmlmaWNhdGlvbiA9ICEhd29ya2VyMjtcbiAgICBpZiAod29ya2VyMikge1xuICAgICAgc2lnbmF0dXJlVmVyaWZpY2F0aW9uSW5pdCh3b3JrZXIyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gZXhwbGljaXQgcmVsYXkgdG8gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSB1cmxcbiAgICogQHBhcmFtIHJlbGF5QXV0aFBvbGljeSBBdXRoZW50aWNhdGlvbiBwb2xpY3kgdG8gdXNlIGlmIGRpZmZlcmVudCBmcm9tIHRoZSBkZWZhdWx0XG4gICAqIEBwYXJhbSBjb25uZWN0IFdoZXRoZXIgdG8gY29ubmVjdCB0byB0aGUgcmVsYXkgYXV0b21hdGljYWxseVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYWRkRXhwbGljaXRSZWxheSh1cmxPclJlbGF5LCByZWxheUF1dGhQb2xpY3ksIGNvbm5lY3QgPSB0cnVlKSB7XG4gICAgbGV0IHJlbGF5O1xuICAgIGlmICh0eXBlb2YgdXJsT3JSZWxheSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVsYXkgPSBuZXcgTkRLUmVsYXkodXJsT3JSZWxheSwgcmVsYXlBdXRoUG9saWN5LCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVsYXkgPSB1cmxPclJlbGF5O1xuICAgIH1cbiAgICB0aGlzLnBvb2wuYWRkUmVsYXkocmVsYXksIGNvbm5lY3QpO1xuICAgIHRoaXMuZXhwbGljaXRSZWxheVVybHM/LnB1c2gocmVsYXkudXJsKTtcbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7IHJlbGF5Q291bnQ6IHRoaXMucG9vbC5yZWxheXMuc2l6ZSB9LnRvU3RyaW5nKCk7XG4gIH1cbiAgZ2V0IGFjdGl2ZVVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFjdGl2ZSB1c2VyIGZvciB0aGlzIE5ESyBpbnN0YW5jZSwgdHlwaWNhbGx5IHRoaXMgd2lsbCBiZVxuICAgKiBjYWxsZWQgd2hlbiBhc3NpZ25pbmcgYSBzaWduZXIgdG8gdGhlIE5ESyBpbnN0YW5jZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY29ubmVjdCB0byB0aGUgdXNlcidzIHJlbGF5cyBpZlxuICAgKiBgYXV0b0Nvbm5lY3RVc2VyUmVsYXlzYCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICogSXQgd2lsbCBhbHNvIGZldGNoIHRoZSB1c2VyJ3MgbXV0ZWxpc3QgaWYgYGF1dG9GZXRjaFVzZXJNdXRlbGlzdGAgaXMgc2V0IHRvIHRydWUuXG4gICAqL1xuICBzZXQgYWN0aXZlVXNlcih1c2VyKSB7XG4gICAgY29uc3QgZGlmZmVyZW50VXNlciA9IHRoaXMuX2FjdGl2ZVVzZXI/LnB1YmtleSAhPT0gdXNlcj8ucHVia2V5O1xuICAgIHRoaXMuX2FjdGl2ZVVzZXIgPSB1c2VyO1xuICAgIGlmICh1c2VyICYmIGRpZmZlcmVudFVzZXIpIHtcbiAgICAgIHNldEFjdGl2ZVVzZXIuY2FsbCh0aGlzLCB1c2VyKTtcbiAgICB9IGVsc2UgaWYgKCF1c2VyKSB7XG4gICAgICB0aGlzLm11dGVkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNpZ25lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lnbmVyO1xuICB9XG4gIHNldCBzaWduZXIobmV3U2lnbmVyKSB7XG4gICAgdGhpcy5fc2lnbmVyID0gbmV3U2lnbmVyO1xuICAgIGlmIChuZXdTaWduZXIpIHRoaXMuZW1pdChcInNpZ25lcjpyZWFkeVwiLCBuZXdTaWduZXIpO1xuICAgIG5ld1NpZ25lcj8udXNlcigpLnRoZW4oKHVzZXIpID0+IHtcbiAgICAgIHVzZXIubmRrID0gdGhpcztcbiAgICAgIHRoaXMuYWN0aXZlVXNlciA9IHVzZXI7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gcmVsYXlzIHdpdGggb3B0aW9uYWwgdGltZW91dC5cbiAgICogSWYgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCwgdGhlIGNvbm5lY3Rpb24gd2lsbCBiZSBjb250aW51ZWQgdG8gYmUgZXN0YWJsaXNoZWQgaW4gdGhlIGJhY2tncm91bmQuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KHRpbWVvdXRNcykge1xuICAgIGlmICh0aGlzLl9zaWduZXIgJiYgdGhpcy5hdXRvQ29ubmVjdFVzZXJSZWxheXMpIHtcbiAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgIFwiQXR0ZW1wdGluZyB0byBjb25uZWN0IHRvIHVzZXIgcmVsYXlzIHNwZWNpZmllZCBieSBzaWduZXIgJW9cIixcbiAgICAgICAgYXdhaXQgdGhpcy5fc2lnbmVyLnJlbGF5cz8uKHRoaXMpXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuX3NpZ25lci5yZWxheXMpIHtcbiAgICAgICAgY29uc3QgcmVsYXlzID0gYXdhaXQgdGhpcy5fc2lnbmVyLnJlbGF5cyh0aGlzKTtcbiAgICAgICAgcmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB0aGlzLnBvb2wuYWRkUmVsYXkocmVsYXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbnMgPSBbdGhpcy5wb29sLmNvbm5lY3QodGltZW91dE1zKV07XG4gICAgaWYgKHRoaXMub3V0Ym94UG9vbCkge1xuICAgICAgY29ubmVjdGlvbnMucHVzaCh0aGlzLm91dGJveFBvb2wuY29ubmVjdCh0aW1lb3V0TXMpKTtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyhcIkNvbm5lY3RpbmcgdG8gcmVsYXlzICVvXCIsIHsgdGltZW91dE1zIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbFNldHRsZWQoY29ubmVjdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBOREtVc2VyIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gb3B0c1xuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0VXNlcihvcHRzKSB7XG4gICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKG9wdHMpO1xuICAgIHVzZXIubmRrID0gdGhpcztcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgTkRLVXNlciBmcm9tIGEgTklQMDVcbiAgICogQHBhcmFtIG5pcDA1IE5JUC0wNSBJRFxuICAgKiBAcGFyYW0gc2tpcENhY2hlIFNraXAgY2FjaGVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGdldFVzZXJGcm9tTmlwMDUobmlwMDUsIHNraXBDYWNoZSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIE5ES1VzZXIuZnJvbU5pcDA1KG5pcDA1LCB0aGlzLCBza2lwQ2FjaGUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBzdGFydHMgYSBuZXcgc3Vic2NyaXB0aW9uLlxuICAgKlxuICAgKiBTdWJzY3JpcHRpb25zIGF1dG9tYXRpY2FsbHkgc3RhcnQgdW5sZXNzIGBhdXRvU3RhcnRgIGlzIHNldCB0byBgZmFsc2VgLlxuICAgKiBZb3UgY2FuIGNvbnRyb2wgYXV0b21hdGljIGNsb3Npbmcgb24gRU9TRSB2aWEgYG9wdHMuY2xvc2VPbkVvc2VgLlxuICAgKlxuICAgKiBAcGFyYW0gZmlsdGVycyAtIEEgc2luZ2xlIE5ES0ZpbHRlciBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgZmlsdGVycy5cbiAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25hbCBOREtTdWJzY3JpcHRpb25PcHRpb25zIHRvIGN1c3RvbWl6ZSBiZWhhdmlvciAoZS5nLiwgY2FjaGluZywgZ3JvdXBpbmcpLlxuICAgKiBAcGFyYW0gcmVsYXlTZXQgLSBPcHRpb25hbCBleHBsaWNpdCBOREtSZWxheVNldCB0byB1c2UgZm9yIHRoaXMgc3Vic2NyaXB0aW9uLiBJZiBub3QgcHJvdmlkZWQsIE5ESyBjYWxjdWxhdGVzIHRoZSBvcHRpbWFsIHNldC5cbiAgICogQHBhcmFtIGF1dG9TdGFydCAtIENvbnRyb2xzIGF1dG9tYXRpYyBzdGFydGluZyBhbmQgYWxsb3dzIHByb3ZpZGluZyBldmVudCBoYW5kbGVycy5cbiAgICogICAtIGB0cnVlYCAoZGVmYXVsdCk6IFN0YXJ0cyB0aGUgc3Vic2NyaXB0aW9uIGltbWVkaWF0ZWx5LlxuICAgKiAgIC0gYGZhbHNlYDogQ3JlYXRlcyB0aGUgc3Vic2NyaXB0aW9uIGJ1dCBkb2VzIG5vdCBzdGFydCBpdCAoY2FsbCBgc3Vic2NyaXB0aW9uLnN0YXJ0KClgIG1hbnVhbGx5KS5cbiAgICogICAtIGBOREtTdWJzY3JpcHRpb25FdmVudEhhbmRsZXJzYCBvYmplY3Q6IFN0YXJ0cyB0aGUgc3Vic2NyaXB0aW9uIGltbWVkaWF0ZWx5IGFuZCBhdHRhY2hlcyB0aGUgcHJvdmlkZWQgaGFuZGxlcnMgKGBvbkV2ZW50YCwgYG9uRXZlbnRzYCwgYG9uRW9zZWApLlxuICAgKiAgICAgLSBVc2luZyBgb25FdmVudHNgIGNoYW5nZXMgYmVoYXZpb3I6IGl0IHJlY2VpdmVzIGluaXRpYWwgY2FjaGVkIGV2ZW50cyBpbiBidWxrLCBhbmQgYG9uRXZlbnRgIGlzIHNraXBwZWQgZm9yIHRoYXQgaW5pdGlhbCBiYXRjaC4gU2VlIHtAbGluayBOREtTdWJzY3JpcHRpb25FdmVudEhhbmRsZXJzfS5cbiAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgTkRLU3Vic2NyaXB0aW9uIGluc3RhbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZSBCYXNpYyBzdWJzY3JpcHRpb25cbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBzdWIgPSBuZGsuc3Vic2NyaWJlKHsga2luZHM6IFsxXSwgYXV0aG9yczogW3B1YmtleV0gfSk7XG4gICAqIHN1Yi5vbihcImV2ZW50XCIsIChldmVudCkgPT4gY29uc29sZS5sb2coXCJLaW5kIDEgZXZlbnQ6XCIsIGV2ZW50LmNvbnRlbnQpKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlIFN1YnNjcmlwdGlvbiB3aXRoIG9wdGlvbnMgYW5kIGRpcmVjdCBoYW5kbGVyc1xuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHN1YiA9IG5kay5zdWJzY3JpYmUoXG4gICAqICAgeyBraW5kczogWzBdLCBhdXRob3JzOiBbcHVia2V5XSB9LFxuICAgKiAgIHsgY2xvc2VPbkVvc2U6IHRydWUsIGNhY2hlVXNhZ2U6IE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UuUEFSQUxMRUwgfSxcbiAgICogICB1bmRlZmluZWQsIC8vIFVzZSBkZWZhdWx0IHJlbGF5IHNldCBjYWxjdWxhdGlvblxuICAgKiAgIHtcbiAgICogICAgIG9uRXZlbnRzOiAoZXZlbnRzKSA9PiB7IC8vIFJlbmFtZWQgcGFyYW1ldGVyXG4gICAqICAgICAgIGlmIChldmVudHMubGVuZ3RoID4gMCkge1xuICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGBHb3QgJHtldmVudHMubGVuZ3RofSBwcm9maWxlIGV2ZW50cyBmcm9tIGNhY2hlOmAsIGV2ZW50c1swXS5jb250ZW50KTtcbiAgICogICAgICAgfVxuICAgKiAgICAgfSxcbiAgICogICAgIG9uRXZlbnQ6IChldmVudCkgPT4geyAvLyBSZW5hbWVkIHBhcmFtZXRlclxuICAgKiAgICAgICBjb25zb2xlLmxvZyhcIkdvdCBwcm9maWxlIHVwZGF0ZSBmcm9tIHJlbGF5OlwiLCBldmVudC5jb250ZW50KTsgLy8gQ2xhcmlmaWVkIHNvdXJjZVxuICAgKiAgICAgfSxcbiAgICogICAgIG9uRW9zZTogKCkgPT4gY29uc29sZS5sb2coXCJQcm9maWxlIHN1YnNjcmlwdGlvbiBmaW5pc2hlZC5cIilcbiAgICogICB9XG4gICAqICk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2luY2UgMi4xMy4wIGByZWxheVNldGAgcGFyYW1ldGVyIHJlbW92ZWQ7IHBhc3MgYHJlbGF5U2V0YCBvciBgcmVsYXlVcmxzYCB2aWEgYG9wdHNgLlxuICAgKi9cbiAgc3Vic2NyaWJlKGZpbHRlcnMsIG9wdHMsIGF1dG9TdGFydCA9IHRydWUpIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBuZXcgTkRLU3Vic2NyaXB0aW9uKHRoaXMsIGZpbHRlcnMsIG9wdHMpO1xuICAgIHRoaXMuc3ViTWFuYWdlci5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICBjb25zdCBwb29sID0gc3Vic2NyaXB0aW9uLnBvb2w7XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5yZWxheVNldCkge1xuICAgICAgZm9yIChjb25zdCByZWxheSBvZiBzdWJzY3JpcHRpb24ucmVsYXlTZXQucmVsYXlzKSB7XG4gICAgICAgIHBvb2wudXNlVGVtcG9yYXJ5UmVsYXkocmVsYXksIHZvaWQgMCwgc3Vic2NyaXB0aW9uLmZpbHRlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5vdXRib3hQb29sICYmIHN1YnNjcmlwdGlvbi5oYXNBdXRob3JzRmlsdGVyKCkpIHtcbiAgICAgIGNvbnN0IGF1dGhvcnMgPSBzdWJzY3JpcHRpb24uZmlsdGVycy5maWx0ZXIoKGZpbHRlcikgPT4gZmlsdGVyLmF1dGhvcnMgJiYgZmlsdGVyLmF1dGhvcnM/Lmxlbmd0aCA+IDApLmZsYXRNYXAoKGZpbHRlcikgPT4gZmlsdGVyLmF1dGhvcnMpO1xuICAgICAgdGhpcy5vdXRib3hUcmFja2VyPy50cmFja1VzZXJzKGF1dGhvcnMpO1xuICAgIH1cbiAgICBpZiAoYXV0b1N0YXJ0KSB7XG4gICAgICBsZXQgZXZlbnRzSGFuZGxlcjtcbiAgICAgIGlmICh0eXBlb2YgYXV0b1N0YXJ0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChhdXRvU3RhcnQub25FdmVudCkgc3Vic2NyaXB0aW9uLm9uKFwiZXZlbnRcIiwgYXV0b1N0YXJ0Lm9uRXZlbnQpO1xuICAgICAgICBpZiAoYXV0b1N0YXJ0Lm9uRW9zZSkgc3Vic2NyaXB0aW9uLm9uKFwiZW9zZVwiLCBhdXRvU3RhcnQub25Fb3NlKTtcbiAgICAgICAgaWYgKGF1dG9TdGFydC5vbkV2ZW50cykgZXZlbnRzSGFuZGxlciA9IGF1dG9TdGFydC5vbkV2ZW50cztcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYWNoZWRFdmVudHMgPSBzdWJzY3JpcHRpb24uc3RhcnQoIWV2ZW50c0hhbmRsZXIpO1xuICAgICAgICBpZiAoY2FjaGVkRXZlbnRzICYmIGNhY2hlZEV2ZW50cy5sZW5ndGggPiAwICYmICEhZXZlbnRzSGFuZGxlcikgZXZlbnRzSGFuZGxlcihjYWNoZWRFdmVudHMpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYW4gZXZlbnQgdG8gYSByZWxheVxuICAgKiBAcGFyYW0gZXZlbnQgZXZlbnQgdG8gcHVibGlzaFxuICAgKiBAcGFyYW0gcmVsYXlTZXQgZXhwbGljaXQgcmVsYXkgc2V0IHRvIHVzZVxuICAgKiBAcGFyYW0gdGltZW91dE1zIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIHRoZSBldmVudCB0byBiZSBwdWJsaXNoZWRcbiAgICogQHJldHVybnMgVGhlIHJlbGF5cyB0aGUgZXZlbnQgd2FzIHB1Ymxpc2hlZCB0b1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYGV2ZW50LnB1Ymxpc2goKWAgaW5zdGVhZFxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChldmVudCwgcmVsYXlTZXQsIHRpbWVvdXRNcykge1xuICAgIHRoaXMuZGVidWcoXCJEZXByZWNhdGVkOiBVc2UgYGV2ZW50LnB1Ymxpc2goKWAgaW5zdGVhZFwiKTtcbiAgICByZXR1cm4gZXZlbnQucHVibGlzaChyZWxheVNldCwgdGltZW91dE1zKTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZmV0Y2ggYW4gZXZlbnQgZnJvbSBhIHRhZywgZm9sbG93aW5nIHJlbGF5IGhpbnRzIGFuZFxuICAgKiBvdGhlciBiZXN0IHByYWN0aWNlcy5cbiAgICogQHBhcmFtIHRhZyBUYWcgdG8gZmV0Y2ggdGhlIGV2ZW50IGZyb21cbiAgICogQHBhcmFtIG9yaWdpbmFsRXZlbnQgRXZlbnQgd2hlcmUgdGhlIHRhZyBjYW1lIGZyb21cbiAgICogQHBhcmFtIHN1Yk9wdHMgU3Vic2NyaXB0aW9uIG9wdGlvbnMgdG8gdXNlIHdoZW4gZmV0Y2hpbmcgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBmYWxsYmFjayBGYWxsYmFjayBvcHRpb25zIHRvIHVzZSB3aGVuIHRoZSBoaW50IHJlbGF5IGRvZXNuJ3QgcmVzcG9uZFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZmV0Y2hFdmVudEZyb21UYWcgPSBmZXRjaEV2ZW50RnJvbVRhZy5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogRmV0Y2ggYW4gZXZlbnQgZnJvbSB0aGUgY2FjaGUgc3luY2hyb25vdXNseS5cbiAgICogQHBhcmFtIGlkT3JGaWx0ZXIgZXZlbnQgaWQgaW4gYmVjaDMyIGZvcm1hdCBvciBmaWx0ZXJcbiAgICogQHJldHVybnMgZXZlbnRzIGZyb20gdGhlIGNhY2hlIG9yIG51bGwgaWYgdGhlIGNhY2hlIGlzIGVtcHR5XG4gICAqL1xuICBmZXRjaEV2ZW50U3luYyhpZE9yRmlsdGVyKSB7XG4gICAgaWYgKCF0aGlzLmNhY2hlQWRhcHRlcikgdGhyb3cgbmV3IEVycm9yKFwiQ2FjaGUgYWRhcHRlciBub3Qgc2V0XCIpO1xuICAgIGxldCBmaWx0ZXJzO1xuICAgIGlmICh0eXBlb2YgaWRPckZpbHRlciA9PT0gXCJzdHJpbmdcIikgZmlsdGVycyA9IFtmaWx0ZXJGcm9tSWQoaWRPckZpbHRlcildO1xuICAgIGVsc2UgZmlsdGVycyA9IGlkT3JGaWx0ZXI7XG4gICAgY29uc3Qgc3ViID0gbmV3IE5ES1N1YnNjcmlwdGlvbih0aGlzLCBmaWx0ZXJzKTtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLmNhY2hlQWRhcHRlci5xdWVyeShzdWIpO1xuICAgIGlmIChldmVudHMgaW5zdGFuY2VvZiBQcm9taXNlKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWNoZSBhZGFwdGVyIGlzIGFzeW5jXCIpO1xuICAgIHJldHVybiBldmVudHMubWFwKChlKSA9PiB7XG4gICAgICBlLm5kayA9IHRoaXM7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBzaW5nbGUgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBpZE9yRmlsdGVyIGV2ZW50IGlkIGluIGJlY2gzMiBmb3JtYXQgb3IgZmlsdGVyXG4gICAqIEBwYXJhbSBvcHRzIHN1YnNjcmlwdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSByZWxheVNldE9yUmVsYXkgZXhwbGljaXQgcmVsYXkgc2V0IHRvIHVzZVxuICAgKi9cbiAgYXN5bmMgZmV0Y2hFdmVudChpZE9yRmlsdGVyLCBvcHRzLCByZWxheVNldE9yUmVsYXkpIHtcbiAgICBsZXQgZmlsdGVycztcbiAgICBsZXQgcmVsYXlTZXQ7XG4gICAgaWYgKHJlbGF5U2V0T3JSZWxheSBpbnN0YW5jZW9mIE5ES1JlbGF5KSB7XG4gICAgICByZWxheVNldCA9IG5ldyBOREtSZWxheVNldCgvKiBAX19QVVJFX18gKi8gbmV3IFNldChbcmVsYXlTZXRPclJlbGF5XSksIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAocmVsYXlTZXRPclJlbGF5IGluc3RhbmNlb2YgTkRLUmVsYXlTZXQpIHtcbiAgICAgIHJlbGF5U2V0ID0gcmVsYXlTZXRPclJlbGF5O1xuICAgIH1cbiAgICBpZiAoIXJlbGF5U2V0T3JSZWxheSAmJiB0eXBlb2YgaWRPckZpbHRlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKCFpc05pcDMzQVZhbHVlKGlkT3JGaWx0ZXIpKSB7XG4gICAgICAgIGNvbnN0IHJlbGF5cyA9IHJlbGF5c0Zyb21CZWNoMzIoaWRPckZpbHRlciwgdGhpcyk7XG4gICAgICAgIGlmIChyZWxheXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlbGF5U2V0ID0gbmV3IE5ES1JlbGF5U2V0KG5ldyBTZXQocmVsYXlzKSwgdGhpcyk7XG4gICAgICAgICAgcmVsYXlTZXQgPSBjb3JyZWN0UmVsYXlTZXQocmVsYXlTZXQsIHRoaXMucG9vbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpZE9yRmlsdGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmaWx0ZXJzID0gW2ZpbHRlckZyb21JZChpZE9yRmlsdGVyKV07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlkT3JGaWx0ZXIpKSB7XG4gICAgICBmaWx0ZXJzID0gaWRPckZpbHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsdGVycyA9IFtpZE9yRmlsdGVyXTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmlsdGVyOiAke0pTT04uc3RyaW5naWZ5KGlkT3JGaWx0ZXIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxldCBmZXRjaGVkRXZlbnQgPSBudWxsO1xuICAgICAgY29uc3Qgc3Vic2NyaWJlT3B0cyA9IHtcbiAgICAgICAgLi4ub3B0cyB8fCB7fSxcbiAgICAgICAgY2xvc2VPbkVvc2U6IHRydWVcbiAgICAgIH07XG4gICAgICBpZiAocmVsYXlTZXQpIHN1YnNjcmliZU9wdHMucmVsYXlTZXQgPSByZWxheVNldDtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLnN1YnNjcmliZShcbiAgICAgICAgZmlsdGVycyxcbiAgICAgICAgc3Vic2NyaWJlT3B0cyxcbiAgICAgICAgLy8gcmVsYXlTZXQsIC8vIFJlbW92ZWQ6IFBhc3NlZCB2aWEgb3B0c1xuICAgICAgICBmYWxzZVxuICAgICAgICAvLyBhdXRvU3RhcnQgPSBmYWxzZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHQyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHMuc3RvcCgpO1xuICAgICAgICByZXNvbHZlKGZldGNoZWRFdmVudCk7XG4gICAgICB9LCAxZTQpO1xuICAgICAgcy5vbihcImV2ZW50XCIsIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5uZGsgPSB0aGlzO1xuICAgICAgICBpZiAoIWV2ZW50LmlzUmVwbGFjZWFibGUoKSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0Mik7XG4gICAgICAgICAgcmVzb2x2ZShldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWZldGNoZWRFdmVudCB8fCBmZXRjaGVkRXZlbnQuY3JlYXRlZF9hdCA8IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgICAgICBmZXRjaGVkRXZlbnQgPSBldmVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0Mik7XG4gICAgICAgIHJlc29sdmUoZmV0Y2hlZEV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgcy5zdGFydCgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBldmVudHNcbiAgICovXG4gIGFzeW5jIGZldGNoRXZlbnRzKGZpbHRlcnMsIG9wdHMsIHJlbGF5U2V0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBldmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3Qgc3Vic2NyaWJlT3B0cyA9IHtcbiAgICAgICAgLi4ub3B0cyB8fCB7fSxcbiAgICAgICAgY2xvc2VPbkVvc2U6IHRydWVcbiAgICAgIH07XG4gICAgICBpZiAocmVsYXlTZXQpIHN1YnNjcmliZU9wdHMucmVsYXlTZXQgPSByZWxheVNldDtcbiAgICAgIGNvbnN0IHJlbGF5U2V0U3Vic2NyaXB0aW9uID0gdGhpcy5zdWJzY3JpYmUoXG4gICAgICAgIGZpbHRlcnMsXG4gICAgICAgIHN1YnNjcmliZU9wdHMsXG4gICAgICAgIC8vIHJlbGF5U2V0LCAvLyBSZW1vdmVkOiBQYXNzZWQgdmlhIG9wdHNcbiAgICAgICAgZmFsc2VcbiAgICAgICAgLy8gYXV0b1N0YXJ0ID0gZmFsc2VcbiAgICAgICk7XG4gICAgICBjb25zdCBvbkV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGxldCBfZXZlbnQ7XG4gICAgICAgIGlmICghKGV2ZW50IGluc3RhbmNlb2YgTkRLRXZlbnQpKSBfZXZlbnQgPSBuZXcgTkRLRXZlbnQodm9pZCAwLCBldmVudCk7XG4gICAgICAgIGVsc2UgX2V2ZW50ID0gZXZlbnQ7XG4gICAgICAgIGNvbnN0IGRlZHVwS2V5ID0gX2V2ZW50LmRlZHVwbGljYXRpb25LZXkoKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdFdmVudCA9IGV2ZW50cy5nZXQoZGVkdXBLZXkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdFdmVudCkge1xuICAgICAgICAgIF9ldmVudCA9IGRlZHVwKGV4aXN0aW5nRXZlbnQsIF9ldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgX2V2ZW50Lm5kayA9IHRoaXM7XG4gICAgICAgIGV2ZW50cy5zZXQoZGVkdXBLZXksIF9ldmVudCk7XG4gICAgICB9O1xuICAgICAgcmVsYXlTZXRTdWJzY3JpcHRpb24ub24oXCJldmVudFwiLCBvbkV2ZW50KTtcbiAgICAgIHJlbGF5U2V0U3Vic2NyaXB0aW9uLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUobmV3IFNldChldmVudHMudmFsdWVzKCkpKTtcbiAgICAgIH0pO1xuICAgICAgcmVsYXlTZXRTdWJzY3JpcHRpb24uc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IGEgc2lnbmVyIGlzIGF2YWlsYWJsZSB0byBzaWduIGFuIGV2ZW50LlxuICAgKi9cbiAgYXNzZXJ0U2lnbmVyKCkge1xuICAgIGlmICghdGhpcy5zaWduZXIpIHtcbiAgICAgIHRoaXMuZW1pdChcInNpZ25lcjpyZXF1aXJlZFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ25lciByZXF1aXJlZFwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0RW50aXR5ID0gZ2V0RW50aXR5LmJpbmQodGhpcyk7XG4gIHNldCB3YWxsZXQod2FsbGV0KSB7XG4gICAgaWYgKCF3YWxsZXQpIHtcbiAgICAgIHRoaXMud2FsbGV0Q29uZmlnID0gdm9pZCAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndhbGxldENvbmZpZyA/Pz0ge307XG4gICAgdGhpcy53YWxsZXRDb25maWcubG5QYXkgPSB3YWxsZXQ/LmxuUGF5Py5iaW5kKHdhbGxldCk7XG4gICAgdGhpcy53YWxsZXRDb25maWcuY2FzaHVQYXkgPSB3YWxsZXQ/LmNhc2h1UGF5Py5iaW5kKHdhbGxldCk7XG4gIH1cbn07XG5cbi8vIHNyYy96YXAvaW52b2ljZS50c1xuaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSBcImxpZ2h0LWJvbHQxMS1kZWNvZGVyXCI7XG5mdW5jdGlvbiB6YXBJbnZvaWNlRnJvbUV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiZGVzY3JpcHRpb25cIilbMF07XG4gIGNvbnN0IGJvbHQxMSA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImJvbHQxMVwiKVswXTtcbiAgbGV0IGRlY29kZWRJbnZvaWNlO1xuICBsZXQgemFwUmVxdWVzdDtcbiAgaWYgKCFkZXNjcmlwdGlvbiB8fCAhYm9sdDExIHx8ICFib2x0MTFbMV0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIGxldCB6YXBSZXF1ZXN0UGF5bG9hZCA9IGRlc2NyaXB0aW9uWzFdO1xuICAgIGlmICh6YXBSZXF1ZXN0UGF5bG9hZC5zdGFydHNXaXRoKFwiJVwiKSkge1xuICAgICAgemFwUmVxdWVzdFBheWxvYWQgPSBkZWNvZGVVUklDb21wb25lbnQoemFwUmVxdWVzdFBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAoemFwUmVxdWVzdFBheWxvYWQgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB6YXBSZXF1ZXN0ID0gSlNPTi5wYXJzZSh6YXBSZXF1ZXN0UGF5bG9hZCk7XG4gICAgZGVjb2RlZEludm9pY2UgPSBkZWNvZGUoYm9sdDExWzFdKTtcbiAgfSBjYXRjaCAoX2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBhbW91bnRTZWN0aW9uID0gZGVjb2RlZEludm9pY2Uuc2VjdGlvbnMuZmluZCgocykgPT4gcy5uYW1lID09PSBcImFtb3VudFwiKTtcbiAgaWYgKCFhbW91bnRTZWN0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYW1vdW50ID0gTnVtYmVyLnBhcnNlSW50KGFtb3VudFNlY3Rpb24udmFsdWUpO1xuICBpZiAoIWFtb3VudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGNvbnRlbnQgPSB6YXBSZXF1ZXN0LmNvbnRlbnQ7XG4gIGNvbnN0IHNlbmRlciA9IHphcFJlcXVlc3QucHVia2V5O1xuICBjb25zdCByZWNpcGllbnRUYWcgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpWzBdO1xuICBjb25zdCByZWNpcGllbnQgPSByZWNpcGllbnRUYWdbMV07XG4gIGxldCB6YXBwZWRFdmVudCA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImVcIilbMF07XG4gIGlmICghemFwcGVkRXZlbnQpIHtcbiAgICB6YXBwZWRFdmVudCA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImFcIilbMF07XG4gIH1cbiAgY29uc3QgemFwcGVkRXZlbnRJZCA9IHphcHBlZEV2ZW50ID8gemFwcGVkRXZlbnRbMV0gOiB2b2lkIDA7XG4gIGNvbnN0IHphcEludm9pY2UgPSB7XG4gICAgaWQ6IGV2ZW50LmlkLFxuICAgIHphcHBlcjogZXZlbnQucHVia2V5LFxuICAgIHphcHBlZTogc2VuZGVyLFxuICAgIHphcHBlZDogcmVjaXBpZW50LFxuICAgIHphcHBlZEV2ZW50OiB6YXBwZWRFdmVudElkLFxuICAgIGFtb3VudCxcbiAgICBjb21tZW50OiBjb250ZW50XG4gIH07XG4gIHJldHVybiB6YXBJbnZvaWNlO1xufVxuXG4vLyBzcmMvemFwcGVyL2luZGV4LnRzXG5pbXBvcnQgY3JlYXRlRGVidWc1IGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjkgfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL3phcHBlci9sbi50c1xuaW1wb3J0IHsgYmVjaDMyIH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG5pbXBvcnQgY3JlYXRlRGVidWc0IGZyb20gXCJkZWJ1Z1wiO1xudmFyIGQyID0gY3JlYXRlRGVidWc0KFwibmRrOnphcHBlcjpsblwiKTtcbmFzeW5jIGZ1bmN0aW9uIGdldE5pcDU3WmFwU3BlY0Zyb21MdWQoeyBsdWQwNiwgbHVkMTYgfSwgbmRrKSB7XG4gIGxldCB6YXBFbmRwb2ludDtcbiAgaWYgKGx1ZDE2ICYmICFsdWQxNi5zdGFydHNXaXRoKFwiTE5VUkxcIikpIHtcbiAgICBjb25zdCBbbmFtZSwgZG9tYWluXSA9IGx1ZDE2LnNwbGl0KFwiQFwiKTtcbiAgICB6YXBFbmRwb2ludCA9IGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9sbnVybHAvJHtuYW1lfWA7XG4gIH0gZWxzZSBpZiAobHVkMDYpIHtcbiAgICBjb25zdCB7IHdvcmRzIH0gPSBiZWNoMzIuZGVjb2RlKGx1ZDA2LCAxZTMpO1xuICAgIGNvbnN0IGRhdGEgPSBiZWNoMzIuZnJvbVdvcmRzKHdvcmRzKTtcbiAgICBjb25zdCB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuICAgIHphcEVuZHBvaW50ID0gdXRmOERlY29kZXIuZGVjb2RlKGRhdGEpO1xuICB9XG4gIGlmICghemFwRW5kcG9pbnQpIHtcbiAgICBkMihcIk5vIHphcCBlbmRwb2ludCBmb3VuZCAlb1wiLCB7IGx1ZDA2LCBsdWQxNiB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB6YXAgZW5kcG9pbnQgZm91bmRcIik7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBfZmV0Y2ggPSBuZGsuaHR0cEZldGNoIHx8IGZldGNoO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2ZldGNoKHphcEVuZHBvaW50KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmZXRjaCB6YXAgZW5kcG9pbnQgJHt6YXBFbmRwb2ludH06ICR7dGV4dH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZldGNoIHphcCBlbmRwb2ludCAke3phcEVuZHBvaW50fTogJHtlfWApO1xuICB9XG59XG5cbi8vIHNyYy96YXBwZXIvbmlwNTcudHNcbmltcG9ydCB7IG5pcDU3IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVphcFJlcXVlc3QodGFyZ2V0LCBuZGssIGRhdGEsIHB1YmtleSwgYW1vdW50LCByZWxheXMsIGNvbW1lbnQsIHRhZ3MsIHNpZ25lcikge1xuICBjb25zdCB6YXBFbmRwb2ludCA9IGRhdGEuY2FsbGJhY2s7XG4gIGNvbnN0IHphcFJlcXVlc3QgPSBuaXA1Ny5tYWtlWmFwUmVxdWVzdCh7XG4gICAgcHJvZmlsZTogcHVia2V5LFxuICAgIC8vIHNldCB0aGUgZXZlbnQgdG8gbnVsbCBzaW5jZSBub3N0ci10b29scyBkb2Vzbid0IHN1cHBvcnQgbmlwLTMzIHphcHNcbiAgICBldmVudDogbnVsbCxcbiAgICBhbW91bnQsXG4gICAgY29tbWVudDogY29tbWVudCB8fCBcIlwiLFxuICAgIHJlbGF5czogcmVsYXlzLnNsaWNlKDAsIDQpXG4gIH0pO1xuICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICBjb25zdCB0YWdzMiA9IHRhcmdldC5yZWZlcmVuY2VUYWdzKCk7XG4gICAgY29uc3Qgbm9uUFRhZ3MgPSB0YWdzMi5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcInBcIik7XG4gICAgemFwUmVxdWVzdC50YWdzLnB1c2goLi4ubm9uUFRhZ3MpO1xuICB9XG4gIHphcFJlcXVlc3QudGFncy5wdXNoKFtcImxudXJsXCIsIHphcEVuZHBvaW50XSk7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgemFwUmVxdWVzdCk7XG4gIGlmICh0YWdzKSB7XG4gICAgZXZlbnQudGFncyA9IGV2ZW50LnRhZ3MuY29uY2F0KHRhZ3MpO1xuICB9XG4gIGNvbnN0IGVUYWdnZWRFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBhVGFnZ2VkRXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgIGlmICh0YWdbMF0gPT09IFwiZVwiKSB7XG4gICAgICBlVGFnZ2VkRXZlbnRzLmFkZCh0YWdbMV0pO1xuICAgIH0gZWxzZSBpZiAodGFnWzBdID09PSBcImFcIikge1xuICAgICAgYVRhZ2dlZEV2ZW50cy5hZGQodGFnWzFdKTtcbiAgICB9XG4gIH1cbiAgaWYgKGVUYWdnZWRFdmVudHMuc2l6ZSA+IDEpIHRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGUtdGFnIGlzIGFsbG93ZWRcIik7XG4gIGlmIChhVGFnZ2VkRXZlbnRzLnNpemUgPiAxKSB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBhLXRhZyBpcyBhbGxvd2VkXCIpO1xuICBldmVudC50YWdzID0gZXZlbnQudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcInBcIik7XG4gIGV2ZW50LnRhZ3MucHVzaChbXCJwXCIsIHB1YmtleV0pO1xuICBhd2FpdCBldmVudC5zaWduKHNpZ25lcik7XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gc3JjL3phcHBlci9pbmRleC50c1xudmFyIGQzID0gY3JlYXRlRGVidWc1KFwibmRrOnphcHBlclwiKTtcbnZhciBOREtaYXBwZXIgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjkge1xuICB0YXJnZXQ7XG4gIG5kaztcbiAgY29tbWVudDtcbiAgYW1vdW50O1xuICB1bml0O1xuICB0YWdzO1xuICBzaWduZXI7XG4gIHphcE1ldGhvZDtcbiAgbnV0emFwQXNGYWxsYmFjaztcbiAgbG5QYXk7XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGNhc2h1IHBheW1lbnQgaXMgdG8gYmUgbWFkZS5cbiAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgc3dhcC9taW50IHByb29mcyBmb3IgdGhlIHJlcXVpcmVkIGFtb3VudCwgaW4gdGhlIHJlcXVpcmVkIHVuaXQsXG4gICAqIGluIGFueSBvZiB0aGUgcHJvdmlkZWQgbWludHMgYW5kIHJldHVybiB0aGUgcHJvb2ZzIGFuZCBtaW50IHVzZWQuXG4gICAqL1xuICBjYXNodVBheTtcbiAgb25Db21wbGV0ZTtcbiAgbWF4UmVsYXlzID0gMztcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgemFwXG4gICAqIEBwYXJhbSBhbW91bnQgVGhlIGFtb3VudCB0byBzZW5kIGluZGljYXRlZCBpbiB0aGUgdW5pdFxuICAgKiBAcGFyYW0gdW5pdCBUaGUgdW5pdCBvZiB0aGUgYW1vdW50XG4gICAqIEBwYXJhbSBvcHRzIE9wdGlvbnMgZm9yIHRoZSB6YXBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhcmdldCwgYW1vdW50LCB1bml0ID0gXCJtc2F0XCIsIG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5uZGsgPSBvcHRzLm5kayB8fCB0YXJnZXQubmRrO1xuICAgIGlmICghdGhpcy5uZGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5hbW91bnQgPSBhbW91bnQ7XG4gICAgdGhpcy5jb21tZW50ID0gb3B0cy5jb21tZW50O1xuICAgIHRoaXMudW5pdCA9IHVuaXQ7XG4gICAgdGhpcy50YWdzID0gb3B0cy50YWdzO1xuICAgIHRoaXMuc2lnbmVyID0gb3B0cy5zaWduZXI7XG4gICAgdGhpcy5udXR6YXBBc0ZhbGxiYWNrID0gb3B0cy5udXR6YXBBc0ZhbGxiYWNrID8/IGZhbHNlO1xuICAgIHRoaXMubG5QYXkgPSBvcHRzLmxuUGF5IHx8IHRoaXMubmRrLndhbGxldENvbmZpZz8ubG5QYXk7XG4gICAgdGhpcy5jYXNodVBheSA9IG9wdHMuY2FzaHVQYXkgfHwgdGhpcy5uZGsud2FsbGV0Q29uZmlnPy5jYXNodVBheTtcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBvcHRzLm9uQ29tcGxldGUgfHwgdGhpcy5uZGsud2FsbGV0Q29uZmlnPy5vblBheW1lbnRDb21wbGV0ZTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGUgemFwcGluZyBwcm9jZXNzXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBjYWxjdWxhdGUgdGhlIHNwbGl0cyBmb3IgdGhpcyB6YXAgYW5kIGluaXRpYXRlIGVhY2ggemFwIHNwbGl0LlxuICAgKi9cbiAgYXN5bmMgemFwKG1ldGhvZHMpIHtcbiAgICBjb25zdCBzcGxpdHMgPSB0aGlzLmdldFphcFNwbGl0cygpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgc3BsaXRzLm1hcChhc3luYyAoc3BsaXQpID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnphcFNwbGl0KHNwbGl0LCBtZXRob2RzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBFcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcInNwbGl0OmNvbXBsZXRlXCIsIHNwbGl0LCByZXN1bHQpO1xuICAgICAgICByZXN1bHRzLnNldChzcGxpdCwgcmVzdWx0KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLmVtaXQoXCJjb21wbGV0ZVwiLCByZXN1bHRzKTtcbiAgICBpZiAodGhpcy5vbkNvbXBsZXRlKSB0aGlzLm9uQ29tcGxldGUocmVzdWx0cyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgYXN5bmMgemFwTmlwNTcoc3BsaXQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMubG5QYXkpIHRocm93IG5ldyBFcnJvcihcIk5vIGxuUGF5IGZ1bmN0aW9uIGF2YWlsYWJsZVwiKTtcbiAgICBjb25zdCB6YXBTcGVjID0gYXdhaXQgZ2V0TmlwNTdaYXBTcGVjRnJvbUx1ZChkYXRhLCB0aGlzLm5kayk7XG4gICAgaWYgKCF6YXBTcGVjKSB0aHJvdyBuZXcgRXJyb3IoXCJObyB6YXAgc3BlYyBhdmFpbGFibGUgZm9yIHJlY2lwaWVudFwiKTtcbiAgICBjb25zdCByZWxheXMgPSBhd2FpdCB0aGlzLnJlbGF5cyhzcGxpdC5wdWJrZXkpO1xuICAgIGNvbnN0IHphcFJlcXVlc3QgPSBhd2FpdCBnZW5lcmF0ZVphcFJlcXVlc3QoXG4gICAgICB0aGlzLnRhcmdldCxcbiAgICAgIHRoaXMubmRrLFxuICAgICAgemFwU3BlYyxcbiAgICAgIHNwbGl0LnB1YmtleSxcbiAgICAgIHNwbGl0LmFtb3VudCxcbiAgICAgIHJlbGF5cyxcbiAgICAgIHRoaXMuY29tbWVudCxcbiAgICAgIHRoaXMudGFncyxcbiAgICAgIHRoaXMuc2lnbmVyXG4gICAgKTtcbiAgICBpZiAoIXphcFJlcXVlc3QpIHtcbiAgICAgIGQzKFwiVW5hYmxlIHRvIGdlbmVyYXRlIHphcCByZXF1ZXN0XCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGdlbmVyYXRlIHphcCByZXF1ZXN0XCIpO1xuICAgIH1cbiAgICBjb25zdCBwciA9IGF3YWl0IHRoaXMuZ2V0TG5JbnZvaWNlKHphcFJlcXVlc3QsIHNwbGl0LmFtb3VudCwgemFwU3BlYyk7XG4gICAgaWYgKCFwcikge1xuICAgICAgZDMoXCJVbmFibGUgdG8gZ2V0IHBheW1lbnQgcmVxdWVzdFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBnZXQgcGF5bWVudCByZXF1ZXN0XCIpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJsbl9pbnZvaWNlXCIsIHtcbiAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICBuaXA1N1phcFJlcXVlc3Q6IHphcFJlcXVlc3QsXG4gICAgICBwcixcbiAgICAgIHR5cGU6IFwibmlwNTdcIlxuICAgIH0pO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMubG5QYXkoe1xuICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcbiAgICAgIHJlY2lwaWVudFB1YmtleTogc3BsaXQucHVia2V5LFxuICAgICAgcGF5bWVudERlc2NyaXB0aW9uOiBcIk5JUC01NyBaYXBcIixcbiAgICAgIHByLFxuICAgICAgYW1vdW50OiBzcGxpdC5hbW91bnQsXG4gICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICBuaXA1N1phcFJlcXVlc3Q6IHphcFJlcXVlc3RcbiAgICB9KTtcbiAgICBpZiAocmVzPy5wcmVpbWFnZSkge1xuICAgICAgdGhpcy5lbWl0KFwibG5fcGF5bWVudFwiLCB7XG4gICAgICAgIHByZWltYWdlOiByZXMucHJlaW1hZ2UsXG4gICAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgICByZWNpcGllbnRQdWJrZXk6IHNwbGl0LnB1YmtleSxcbiAgICAgICAgcHIsXG4gICAgICAgIHVuaXQ6IHRoaXMudW5pdCxcbiAgICAgICAgbmlwNTdaYXBSZXF1ZXN0OiB6YXBSZXF1ZXN0LFxuICAgICAgICB0eXBlOiBcIm5pcDU3XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaGVzIGluZm9ybWF0aW9uIGFib3V0IGEgTklQLTYxIHphcCBhbmQgYXNrcyB0aGUgY2FsbGVyIHRvIGNyZWF0ZSBjYXNodSBwcm9vZnMgZm9yIHRoZSB6YXAuXG4gICAqXG4gICAqIChub3RlIHRoYXQgdGhlIGNhc2h1UGF5IGZ1bmN0aW9uIGNhbiB1c2UgYW55IG1ldGhvZCB0byBjcmVhdGUgdGhlIHByb29mcywgaW5jbHVkaW5nIHVzaW5nIGxpZ2h0bmluZ1xuICAgKiB0byBtaW50IHByb29mcyBpbiB0aGUgc3BlY2lmaWVkIG1pbnQsIHRoZSByZXNwb25zaWJpbGl0eSBvZiBtaW50aW5nIHRoZSBwcm9vZnMgaXMgZGVsZWdhdGVkIHRvIHRoZSBjYWxsZXIgKGUuZy4gbmRrLXdhbGxldCkpXG4gICAqL1xuICBhc3luYyB6YXBOaXA2MShzcGxpdCwgZGF0YSkge1xuICAgIGlmICghdGhpcy5jYXNodVBheSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2FzaHVQYXkgZnVuY3Rpb24gYXZhaWxhYmxlXCIpO1xuICAgIGxldCByZXQ7XG4gICAgcmV0ID0gYXdhaXQgdGhpcy5jYXNodVBheShcbiAgICAgIHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcbiAgICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICAgIHBheW1lbnREZXNjcmlwdGlvbjogXCJOSVAtNjEgWmFwXCIsXG4gICAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICAgIC4uLmRhdGEgPz8ge31cbiAgICAgIH0sXG4gICAgICAocHIpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFwibG5faW52b2ljZVwiLCB7XG4gICAgICAgICAgcHIsXG4gICAgICAgICAgYW1vdW50OiBzcGxpdC5hbW91bnQsXG4gICAgICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICAgICAgdW5pdDogdGhpcy51bml0LFxuICAgICAgICAgIHR5cGU6IFwibmlwNjFcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICAgIGQzKFwiTklQLTYxIFphcCByZXN1bHQ6ICVvXCIsIHJldCk7XG4gICAgaWYgKHJldCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpZiAocmV0KSB7XG4gICAgICBjb25zdCB7IHByb29mcywgbWludCB9ID0gcmV0O1xuICAgICAgaWYgKCFwcm9vZnMgfHwgIW1pbnQpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB6YXAgY29uZmlybWF0aW9uOiBtaXNzaW5nIHByb29mcyBvciBtaW50OiAke3JldH1gKTtcbiAgICAgIGNvbnN0IHJlbGF5cyA9IGF3YWl0IHRoaXMucmVsYXlzKHNwbGl0LnB1YmtleSk7XG4gICAgICBjb25zdCByZWxheVNldCA9IE5ES1JlbGF5U2V0LmZyb21SZWxheVVybHMocmVsYXlzLCB0aGlzLm5kayk7XG4gICAgICBjb25zdCBudXR6YXAgPSBuZXcgTkRLTnV0emFwKHRoaXMubmRrKTtcbiAgICAgIG51dHphcC50YWdzID0gWy4uLm51dHphcC50YWdzLCAuLi50aGlzLnRhZ3MgfHwgW11dO1xuICAgICAgbnV0emFwLnByb29mcyA9IHByb29mcztcbiAgICAgIG51dHphcC5taW50ID0gbWludDtcbiAgICAgIG51dHphcC50YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgIG51dHphcC5jb21tZW50ID0gdGhpcy5jb21tZW50O1xuICAgICAgbnV0emFwLnVuaXQgPSBcInNhdFwiO1xuICAgICAgbnV0emFwLnJlY2lwaWVudFB1YmtleSA9IHNwbGl0LnB1YmtleTtcbiAgICAgIGF3YWl0IG51dHphcC5zaWduKHRoaXMuc2lnbmVyKTtcbiAgICAgIG51dHphcC5wdWJsaXNoKHJlbGF5U2V0KTtcbiAgICAgIHJldHVybiBudXR6YXA7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHphcCBtZXRob2RzIGF2YWlsYWJsZSBmb3IgdGhlIHJlY2lwaWVudCBhbmQgaW5pdGlhdGVzIHRoZSB6YXBcbiAgICogaW4gdGhlIGRlc2lyZWQgbWV0aG9kLlxuICAgKiBAcGFyYW0gc3BsaXRcbiAgICogQHBhcmFtIG1ldGhvZHMgLSBUaGUgbWV0aG9kcyB0byB0cnksIGlmIG5vdCBwcm92aWRlZCwgYWxsIG1ldGhvZHMgd2lsbCBiZSB0cmllZC5cbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHphcFNwbGl0KHNwbGl0LCBtZXRob2RzKSB7XG4gICAgY29uc3QgcmVjaXBpZW50ID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogc3BsaXQucHVia2V5IH0pO1xuICAgIGNvbnN0IHphcE1ldGhvZHMgPSBhd2FpdCByZWNpcGllbnQuZ2V0WmFwSW5mbygyNTAwKTtcbiAgICBsZXQgcmV0VmFsO1xuICAgIGNvbnN0IGNhbkZhbGxiYWNrVG9OaXA2MSA9IHRoaXMubnV0emFwQXNGYWxsYmFjayAmJiB0aGlzLmNhc2h1UGF5O1xuICAgIGlmICh6YXBNZXRob2RzLnNpemUgPT09IDAgJiYgIWNhbkZhbGxiYWNrVG9OaXA2MSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHphcCBtZXRob2QgYXZhaWxhYmxlIGZvciByZWNpcGllbnQgYW5kIE5JUC02MSBmYWxsYmFjayBpcyBkaXNhYmxlZFwiKTtcbiAgICBjb25zdCBuaXA2MUZhbGxiYWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm51dHphcEFzRmFsbGJhY2spIHJldHVybjtcbiAgICAgIGNvbnN0IHJlbGF5TGlzdHMgPSBhd2FpdCBnZXRSZWxheUxpc3RGb3JVc2Vycyhbc3BsaXQucHVia2V5XSwgdGhpcy5uZGspO1xuICAgICAgbGV0IHJlbGF5VXJscyA9IHJlbGF5TGlzdHMuZ2V0KHNwbGl0LnB1YmtleSk/LnJlYWRSZWxheVVybHM7XG4gICAgICByZWxheVVybHMgPSB0aGlzLm5kay5wb29sLmNvbm5lY3RlZFJlbGF5cygpLm1hcCgocikgPT4gci51cmwpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuemFwTmlwNjEoc3BsaXQsIHtcbiAgICAgICAgLy8gdXNlIHRoZSB1c2VyJ3MgcmVsYXkgbGlzdFxuICAgICAgICByZWxheXM6IHJlbGF5VXJscyxcbiAgICAgICAgLy8gbG9jayB0byB0aGUgdXNlcidzIGFjdHVhbCBwdWJrZXlcbiAgICAgICAgcDJwazogc3BsaXQucHVia2V5LFxuICAgICAgICAvLyBhbGxvdyBpbnRyYW1pbnQgZmFsbGJhY2tcbiAgICAgICAgYWxsb3dJbnRyYW1pbnRGYWxsYmFjazogISFjYW5GYWxsYmFja1RvTmlwNjFcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgY2FuVXNlTmlwNjEgPSAhbWV0aG9kcyB8fCBtZXRob2RzLmluY2x1ZGVzKFwibmlwNjFcIik7XG4gICAgY29uc3QgY2FuVXNlTmlwNTcgPSAhbWV0aG9kcyB8fCBtZXRob2RzLmluY2x1ZGVzKFwibmlwNTdcIik7XG4gICAgY29uc3QgbmlwNjFNZXRob2QgPSB6YXBNZXRob2RzLmdldChcIm5pcDYxXCIpO1xuICAgIGlmIChuaXA2MU1ldGhvZCAmJiBjYW5Vc2VOaXA2MSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0VmFsID0gYXdhaXQgdGhpcy56YXBOaXA2MShzcGxpdCwgbmlwNjFNZXRob2QpO1xuICAgICAgICBpZiAocmV0VmFsIGluc3RhbmNlb2YgTkRLTnV0emFwKSByZXR1cm4gcmV0VmFsO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJub3RpY2VcIiwgYE5JUC02MSBhdHRlbXB0IGZhaWxlZDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5pcDU3TWV0aG9kID0gemFwTWV0aG9kcy5nZXQoXCJuaXA1N1wiKTtcbiAgICBpZiAobmlwNTdNZXRob2QgJiYgY2FuVXNlTmlwNTcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldFZhbCA9IGF3YWl0IHRoaXMuemFwTmlwNTcoc3BsaXQsIG5pcDU3TWV0aG9kKTtcbiAgICAgICAgaWYgKCEocmV0VmFsIGluc3RhbmNlb2YgRXJyb3IpKSByZXR1cm4gcmV0VmFsO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJub3RpY2VcIiwgYE5JUC01NyBhdHRlbXB0IGZhaWxlZDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjYW5GYWxsYmFja1RvTmlwNjEpIHtcbiAgICAgIHJldFZhbCA9IGF3YWl0IG5pcDYxRmFsbGJhY2soKTtcbiAgICAgIGlmIChyZXRWYWwgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgcmV0VmFsO1xuICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwibm90aWNlXCIsIFwiWmFwIG1ldGhvZHMgZXhoYXVzdGVkIGFuZCB0aGVyZSB3YXMgbm8gZmFsbGJhY2sgdG8gTklQLTYxXCIpO1xuICAgIGlmIChyZXRWYWwgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgcmV0VmFsO1xuICAgIHJldHVybiByZXRWYWw7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBib2x0MTEgZm9yIGEgbmlwNTcgemFwXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gYW1vdW50XG4gICAqIEBwYXJhbSB6YXBFbmRwb2ludFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgZ2V0TG5JbnZvaWNlKHphcFJlcXVlc3QsIGFtb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHphcEVuZHBvaW50ID0gZGF0YS5jYWxsYmFjaztcbiAgICBjb25zdCBldmVudFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh6YXBSZXF1ZXN0LnJhd0V2ZW50KCkpO1xuICAgIGQzKFxuICAgICAgYEZldGNoaW5nIGludm9pY2UgZnJvbSAke3phcEVuZHBvaW50fT8ke25ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhbW91bnQ6IGFtb3VudC50b1N0cmluZygpLFxuICAgICAgICBub3N0cjogZXZlbnRQYXlsb2FkXG4gICAgICB9KX1gXG4gICAgKTtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHphcEVuZHBvaW50KTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImFtb3VudFwiLCBhbW91bnQudG9TdHJpbmcoKSk7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJub3N0clwiLCBldmVudFBheWxvYWQpO1xuICAgIGQzKGBGZXRjaGluZyBpbnZvaWNlIGZyb20gJHt1cmwudG9TdHJpbmcoKX1gKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpKTtcbiAgICBkMyhgR290IHJlc3BvbnNlIGZyb20gemFwIGVuZHBvaW50OiAke3phcEVuZHBvaW50fWAsIHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICBkMyhgUmVjZWl2ZWQgbm9uLTIwMCBzdGF0dXMgZnJvbSB6YXAgZW5kcG9pbnQ6ICR7emFwRW5kcG9pbnR9YCwge1xuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgYW1vdW50LFxuICAgICAgICBub3N0cjogZXZlbnRQYXlsb2FkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmZXRjaCB6YXAgZW5kcG9pbnQgJHt6YXBFbmRwb2ludH06ICR7dGV4dH1gKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gYm9keS5wcjtcbiAgfVxuICBnZXRaYXBTcGxpdHMoKSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0IGluc3RhbmNlb2YgTkRLVXNlcikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHB1YmtleTogdGhpcy50YXJnZXQucHVia2V5LFxuICAgICAgICAgIGFtb3VudDogdGhpcy5hbW91bnRcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgemFwVGFncyA9IHRoaXMudGFyZ2V0LmdldE1hdGNoaW5nVGFncyhcInphcFwiKTtcbiAgICBpZiAoemFwVGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICBwdWJrZXk6IHRoaXMudGFyZ2V0LnB1YmtleSxcbiAgICAgICAgICBhbW91bnQ6IHRoaXMuYW1vdW50XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IHNwbGl0cyA9IFtdO1xuICAgIGNvbnN0IHRvdGFsID0gemFwVGFncy5yZWR1Y2UoKGFjYywgdGFnKSA9PiBhY2MgKyBOdW1iZXIucGFyc2VJbnQodGFnWzJdKSwgMCk7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgemFwVGFncykge1xuICAgICAgY29uc3QgcHVia2V5ID0gdGFnWzFdO1xuICAgICAgY29uc3QgYW1vdW50ID0gTWF0aC5mbG9vcihOdW1iZXIucGFyc2VJbnQodGFnWzJdKSAvIHRvdGFsICogdGhpcy5hbW91bnQpO1xuICAgICAgc3BsaXRzLnB1c2goeyBwdWJrZXksIGFtb3VudCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNwbGl0cztcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgemFwIG1ldGhvZCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHphcCBhIHB1YmJrZXlcbiAgICogQHBhcmFtIG5ka1xuICAgKiBAcGFyYW0gcHVia2V5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBnZXRaYXBNZXRob2RzKG5kaywgcmVjaXBpZW50LCB0aW1lb3V0ID0gMjUwMCkge1xuICAgIGNvbnN0IHVzZXIgPSBuZGsuZ2V0VXNlcih7IHB1YmtleTogcmVjaXBpZW50IH0pO1xuICAgIHJldHVybiBhd2FpdCB1c2VyLmdldFphcEluZm8odGltZW91dCk7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIHRoZSByZWxheXMgdG8gdXNlIGZvciB0aGUgemFwIHJlcXVlc3RcbiAgICovXG4gIGFzeW5jIHJlbGF5cyhwdWJrZXkpIHtcbiAgICBsZXQgciA9IFtdO1xuICAgIGlmICh0aGlzLm5kaz8uYWN0aXZlVXNlcikge1xuICAgICAgY29uc3QgcmVsYXlMaXN0cyA9IGF3YWl0IGdldFJlbGF5TGlzdEZvclVzZXJzKFt0aGlzLm5kay5hY3RpdmVVc2VyLnB1YmtleSwgcHVia2V5XSwgdGhpcy5uZGspO1xuICAgICAgY29uc3QgcmVsYXlTY29yZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCByZWxheUxpc3Qgb2YgcmVsYXlMaXN0cy52YWx1ZXMoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHVybCBvZiByZWxheUxpc3QucmVhZFJlbGF5VXJscykge1xuICAgICAgICAgIGNvbnN0IHNjb3JlID0gcmVsYXlTY29yZXMuZ2V0KHVybCkgfHwgMDtcbiAgICAgICAgICByZWxheVNjb3Jlcy5zZXQodXJsLCBzY29yZSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByID0gQXJyYXkuZnJvbShyZWxheVNjb3Jlcy5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKS5tYXAoKFt1cmxdKSA9PiB1cmwpLnNsaWNlKDAsIHRoaXMubWF4UmVsYXlzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmRrPy5wb29sPy5wZXJtYW5lbnRBbmRDb25uZWN0ZWRSZWxheXMoKS5sZW5ndGgpIHtcbiAgICAgIHIgPSB0aGlzLm5kay5wb29sLnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLm1hcCgocmVsYXkpID0+IHJlbGF5LnVybCk7XG4gICAgfVxuICAgIGlmICghci5sZW5ndGgpIHtcbiAgICAgIHIgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9maWx0ZXIudHNcbmZ1bmN0aW9uIG1hdGNoRmlsdGVyKGZpbHRlciwgZXZlbnQpIHtcbiAgaWYgKGZpbHRlci5pZHMgJiYgZmlsdGVyLmlkcy5pbmRleE9mKGV2ZW50LmlkKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5raW5kcyAmJiBmaWx0ZXIua2luZHMuaW5kZXhPZihldmVudC5raW5kKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5hdXRob3JzICYmIGZpbHRlci5hdXRob3JzLmluZGV4T2YoZXZlbnQucHVia2V5KSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBmIGluIGZpbHRlcikge1xuICAgIGlmIChmWzBdID09PSBcIiNcIikge1xuICAgICAgY29uc3QgdGFnTmFtZSA9IGYuc2xpY2UoMSk7XG4gICAgICBpZiAodGFnTmFtZSA9PT0gXCJ0XCIpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZmlsdGVyW2AjJHt0YWdOYW1lfWBdPy5tYXAoKHYpID0+IHYudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICh2YWx1ZXMgJiYgIWV2ZW50LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSB0YWdOYW1lICYmIHZhbHVlcz8uaW5kZXhPZih2LnRvTG93ZXJDYXNlKCkpICE9PSAtMSkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZmlsdGVyW2AjJHt0YWdOYW1lfWBdO1xuICAgICAgICBpZiAodmFsdWVzICYmICFldmVudC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gdGFnTmFtZSAmJiB2YWx1ZXM/LmluZGV4T2YodikgIT09IC0xKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZmlsdGVyLnNpbmNlICYmIGV2ZW50LmNyZWF0ZWRfYXQgPCBmaWx0ZXIuc2luY2UpIHJldHVybiBmYWxzZTtcbiAgaWYgKGZpbHRlci51bnRpbCAmJiBldmVudC5jcmVhdGVkX2F0ID4gZmlsdGVyLnVudGlsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IHtcbiAgQkVDSDMyX1JFR0VYLFxuICBOREtBcHBIYW5kbGVyRXZlbnQsXG4gIE5ES0FwcFNldHRpbmdzLFxuICBOREtBcnRpY2xlLFxuICBOREtDYXNodU1pbnRMaXN0LFxuICBOREtDYXNodVRva2VuLFxuICBOREtDYXNodVdhbGxldFR4LFxuICBOREtDbGFzc2lmaWVkLFxuICBOREtEVk1Kb2JGZWVkYmFjayxcbiAgTkRLRFZNSm9iUmVzdWx0LFxuICBOREtEVk1SZXF1ZXN0LFxuICBOREtEcmFmdCxcbiAgTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMsXG4gIE5ES0V2ZW50LFxuICBOREtIaWdobGlnaHQsXG4gIE5ES0ltYWdlLFxuICBOREtLaW5kLFxuICBOREtMaXN0LFxuICBOREtMaXN0S2luZHMsXG4gIE5ES05pcDA3U2lnbmVyLFxuICBOREtOaXA0NkJhY2tlbmQsXG4gIE5ES05pcDQ2U2lnbmVyLFxuICBOREtOb3N0clJwYyxcbiAgTkRLTnV0emFwLFxuICBOREtQb29sLFxuICBOREtQcml2YXRlS2V5U2lnbmVyLFxuICBOREtQdWJsaXNoRXJyb3IsXG4gIE5ES1JlbGF5LFxuICBOREtSZWxheUF1dGhQb2xpY2llcyxcbiAgTkRLUmVsYXlMaXN0LFxuICBOREtSZWxheVNldCxcbiAgTkRLUmVsYXlTdGF0dXMsXG4gIE5ES1JlcG9zdCxcbiAgTkRLU2ltcGxlR3JvdXAsXG4gIE5ES1NpbXBsZUdyb3VwTWVtYmVyTGlzdCxcbiAgTkRLU2ltcGxlR3JvdXBNZXRhZGF0YSxcbiAgTkRLU3RvcnksXG4gIE5ES1N0b3J5U3RpY2tlcixcbiAgTkRLU3RvcnlTdGlja2VyVHlwZSxcbiAgTkRLU3Vic2NyaXB0aW9uLFxuICBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlLFxuICBOREtTdWJzY3JpcHRpb25SZWNlaXB0LFxuICBOREtTdWJzY3JpcHRpb25TdGFydCxcbiAgTkRLU3Vic2NyaXB0aW9uVGllcixcbiAgTkRLVHJhbnNjcmlwdGlvbkRWTSxcbiAgTkRLVXNlcixcbiAgTkRLVmlkZW8sXG4gIE5ES1dpa2ksXG4gIE5ES1phcHBlcixcbiAgTklQMzNfQV9SRUdFWCxcbiAgTmRrTnV0emFwU3RhdHVzLFxuICBjYWxjdWxhdGVSZWxheVNldEZyb21FdmVudCxcbiAgY2FsY3VsYXRlVGVybUR1cmF0aW9uSW5TZWNvbmRzLFxuICBjYXNodVB1YmtleVRvTm9zdHJQdWJrZXksXG4gIGNvbXBhcmVGaWx0ZXIsXG4gIE5ESyBhcyBkZWZhdWx0LFxuICBkZWZhdWx0T3B0cyxcbiAgZGVzZXJpYWxpemUsXG4gIGR2bVNjaGVkdWxlLFxuICBldmVudEhhc0VUYWdNYXJrZXJzLFxuICBldmVudElzUGFydE9mVGhyZWFkLFxuICBldmVudElzUmVwbHksXG4gIGV2ZW50UmVwbGllcyxcbiAgZXZlbnRUaHJlYWRJZHMsXG4gIGV2ZW50VGhyZWFkcyxcbiAgZXZlbnRzQnlTYW1lQXV0aG9yLFxuICBmaWx0ZXJBbmRSZWxheVNldEZyb21CZWNoMzIsXG4gIGZpbHRlckZpbmdlcnByaW50LFxuICBmaWx0ZXJGb3JFdmVudHNUYWdnaW5nSWQsXG4gIGZpbHRlckZyb21JZCxcbiAgZ2VuZXJhdGVDb250ZW50VGFncyxcbiAgZ2VuZXJhdGVIYXNodGFncyxcbiAgZ2VuZXJhdGVTdWJJZCxcbiAgZ2VuZXJhdGVaYXBSZXF1ZXN0LFxuICBnZXRFdmVudFJlcGx5SWQsXG4gIGdldE5pcDU3WmFwU3BlY0Zyb21MdWQsXG4gIGdldFJlbGF5TGlzdEZvclVzZXIsXG4gIGdldFJlbGF5TGlzdEZvclVzZXJzLFxuICBnZXRSZXBseVRhZyxcbiAgZ2V0Um9vdEV2ZW50SWQsXG4gIGdldFJvb3RUYWcsXG4gIGdpZnRVbndyYXAsXG4gIGdpZnRXcmFwLFxuICBpbWV0YVRhZ1RvVGFnLFxuICBpc0V2ZW50T3JpZ2luYWxQb3N0LFxuICBpc05pcDMzQVZhbHVlLFxuICBtYXBJbWV0YVRhZyxcbiAgbWF0Y2hGaWx0ZXIsXG4gIG1lcmdlRmlsdGVycyxcbiAgbWVyZ2VUYWdzLFxuICBuZGtTaWduZXJGcm9tUGF5bG9hZCxcbiAgbmV3QW1vdW50LFxuICBub3JtYWxpemUsXG4gIG5vcm1hbGl6ZVJlbGF5VXJsLFxuICBub3JtYWxpemVVcmwsXG4gIHBhcnNlVGFnVG9TdWJzY3JpcHRpb25BbW91bnQsXG4gIHBpbkV2ZW50LFxuICBwb3NzaWJsZUludGVydmFsRnJlcXVlbmNpZXMsXG4gIHByb2ZpbGVGcm9tRXZlbnQsXG4gIHByb29mUDJwayxcbiAgcHJvb2ZQMnBrTm9zdHIsXG4gIHByb29mc1RvdGFsQmFsYW5jZSxcbiAgcXVlcnlGdWxseUZpbGxlZCxcbiAgcmVsYXlMaXN0RnJvbUtpbmQzLFxuICByZWxheXNGcm9tQmVjaDMyLFxuICBzZXJpYWxpemUsXG4gIHNlcmlhbGl6ZVByb2ZpbGUsXG4gIHNpZ25lclJlZ2lzdHJ5LFxuICBzdHJUb0RpbWVuc2lvbixcbiAgc3RyVG9Qb3NpdGlvbixcbiAgdHJ5Tm9ybWFsaXplUmVsYXlVcmwsXG4gIHVuaXF1ZVRhZyxcbiAgd3JhcEV2ZW50LFxuICB6YXBJbnZvaWNlRnJvbUV2ZW50XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@nostr-dev-kit/ndk/dist/index.mjs\n");

/***/ })

};
;